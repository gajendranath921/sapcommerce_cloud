'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var http = require('@angular/common/http');
var core = require('@angular/core');
var forms = require('@angular/forms');
var platformBrowser = require('@angular/platform-browser');
var _static = require('@angular/upgrade/static');
var cmscommons = require('cmscommons');
var smarteditcommons = require('smarteditcommons');
var operators = require('rxjs/operators');
var lodash = require('lodash');
var core$1 = require('@ngx-translate/core');
var common = require('@angular/common');
var core$2 = require('@fundamental-ngx/core');
var rxjs = require('rxjs');
var smarteditcontainer = require('smarteditcontainer');
var operators$1 = require('rxjs/internal/operators');
var router = require('@angular/router');
var Subject = require('rxjs/internal/Subject');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var lodash__namespace = /*#__PURE__*/_interopNamespace(lodash);

(function(){
      var angular = angular || window.angular;
      var SE_NG_TEMPLATE_MODULE = null;
      
      try {
        SE_NG_TEMPLATE_MODULE = angular.module('cmssmarteditContainerTemplates');
      } catch (err) {}
      SE_NG_TEMPLATE_MODULE = SE_NG_TEMPLATE_MODULE || angular.module('cmssmarteditContainerTemplates', []);
      SE_NG_TEMPLATE_MODULE.run(['$templateCache', function($templateCache) {
         
    $templateCache.put(
        "ItemManagerComponent.html", 
        "<div><se-generic-editor [id]=\"editorId\" [smarteditComponentId]=\"itemId\" [smarteditComponentType]=\"componentType\" [structureApi]=\"structureApi\" [content]=\"item\" [contentApi]=\"contentApi\" [(isDirty)]=\"isDirtyInternal\" [(submit)]=\"submit\" [uriContext]=\"uriContext\" [reset]=\"reset\"></se-generic-editor></div>"
    );
     
    $templateCache.put(
        "NavigationManagementPageComponent.html", 
        "<div class=\"se-navigation-management-page-list-template\"><div class=\"se-toolbar-group\"><se-toolbar cssClass=\"se-toolbar--shell\" imageRoot=\"imageRoot\" toolbarName=\"smartEditHeaderToolbar\"></se-toolbar><se-toolbar cssClass=\"se-toolbar--shell se-toolbar--shortcut\" imageRoot=\"imageRoot\" toolbarName=\"smartEditNavigationToolbar\"></se-toolbar></div><div class=\"se-navigation-editor-wrapper\" *ngIf=\"readOnly !== undefined\"><div class=\"se-navigation-editor-header\"><h1 class=\"se-navigation-editor-header__title\" translate=\"se.cms.navigationmanagement.title\"></h1><h4 class=\"se-navigation-editor-header__sub-title\">{{ catalogName | seL10n | async }} - {{ catalogVersion }}</h4></div><se-navigation-editor-tree [uriContext]=\"uriContext\" [readOnly]=\"readOnly\"></se-navigation-editor-tree></div></div>"
    );
     
    $templateCache.put(
        "CmsComponentDropdownComponent.html", 
        "<div class=\"cms-nested-component-template\"><div class=\"cms-nested-component-select\"><ng-container *ngIf=\"forceRecompile\"><se-generic-editor-dropdown [field]=\"field\" [qualifier]=\"qualifier\" [model]=\"model\" [id]=\"id\" [itemComponent]=\"itemComponent\" [actionableSearchItem]=\"actionableSearchItem\" [showRemoveButton]=\"true\"></se-generic-editor-dropdown></ng-container></div></div>"
    );
     
    $templateCache.put(
        "ComponentMenuComponent.html", 
        "<div class=\"se-component-menu\" [ngClass]=\"{ 'se-component-menu__localized': hasMultipleContentCatalogs }\"><div translate=\"se.cms.componentmenu.dropdown.header\" class=\"se-component-menu__title\"></div><div class=\"se-component-menu__tip\" translate=\"se.cms.componentmenu.label.draganddrop\"></div><se-tabs *ngIf=\"toolbarItem.isOpen\" class=\"se-component-menu__tabs\" [tabsList]=\"tabsList\" [model]=\"model\" [numTabsDisplayed]=\"2\"></se-tabs></div>"
    );
     
    $templateCache.put(
        "CmsLinkToSelectComponent.html", 
        "<se-generic-editor-dropdown [id]=\"id\" [field]=\"field\" [qualifier]=\"qualifier\" [model]=\"optionModel\"></se-generic-editor-dropdown>"
    );
     
    $templateCache.put(
        "InfoPageNameComponent.html", 
        "<div class=\"se-page-info__name\"><se-homepage-icon *ngIf=\"field.qualifier === 'name'\" [cmsPage]=\"cmsPage\" [uriContext]=\"uriContext\"></se-homepage-icon><div id=\"{{ field.qualifier }}-homepage\" class=\"se-page-info__name-value fd-form-control\" [title]=\"field.qualifier\">{{ model[qualifier] }}</div></div>"
    );
     
    $templateCache.put(
        "LinkToggleComponent.html", 
        "<div class=\"se-link-toggle\"><div class=\"se-link-toggle__row\"><div class=\"se-form-control-row se-form-control-row--action\"><label class=\"se-control-label se-link-toggle__label\" for=\"external-link\"><input class=\"fd-form__control se-link-toggle__input\" id=\"external-link\" name=\"linktoggle\" type=\"radio\" [(ngModel)]=\"model.linkToggle.external\" (ngModelChange)=\"clearUrlLink()\" [value]=\"true\"/> {{ 'se.editor.linkto.external.label' | translate}}</label></div><div class=\"se-form-control-row se-form-control-row--action\"><label class=\"se-control-label se-link-toggle__label\" for=\"internal-link\"><input class=\"fd-form__control se-link-toggle__input\" id=\"internal-link\" name=\"linktoggle\" type=\"radio\" [(ngModel)]=\"model.linkToggle.external\" (ngModelChange)=\"clearUrlLink()\" [value]=\"false\"/> {{ 'se.editor.linkto.internal.label' | translate}}</label></div></div><input class=\"fd-form-control\" id=\"urlLink\" name=\"urlLink\" type=\"text\" [(ngModel)]=\"model.linkToggle.urlLink\" (ngModelChange)=\"checkUrlLink()\" [ngClass]=\"{ 'has-error': field.hasErrors }\"/></div>"
    );
     
    $templateCache.put(
        "PageTypeEditorComponent.html", 
        "<div class=\"se-edit-page-info__basic-tab\"><div class=\"se-edit-page-info__page-type\"><label class=\"se-control-label\" translate=\"se.cms.pageinfo.page.type\"></label><div class=\"form-readonly-text form-readonly-text__tight\">{{ model.typeCode }}</div></div><div class=\"se-edit-page-info__page-template\"><label class=\"se-control-label\" translate=\"se.cms.pageinfo.page.template\"></label><div class=\"form-readonly-text form-readonly-text__tight\">{{ model.template }}</div></div></div>"
    );
     
    $templateCache.put(
        "RestrictionsListComponent.html", 
        "<div class=\"restrictions-list\"><div class=\"restrictions-list__info\"><label translate=\"se.cms.restrictions.criteria\"></label> <span>&nbsp;{{ pageInfo.restrictionsCriteria }}</span></div><div class=\"restrictions-list__items\" *ngFor=\"let restriction of restrictions\"><div class=\"restrictions-list__item\"><div class=\"restrictions-list__item-name\">{{ restriction.name }}</div><div class=\"restrictions-list__item-type\">{{ restriction.type | seL10n | async }}</div><div class=\"restrictions-list__item-description\">{{ restriction.description }}</div></div></div></div>"
    );
     
    $templateCache.put(
        "SingleActiveCatalogAwareItemSelectorComponent.html", 
        "<div *ngIf=\"propertyType\"><div id=\"product-catalog\"><label class=\"se-control-label\" [ngClass]=\"{ 'required': field.required }\" *ngIf=\"catalogs.length === 1\">{{ catalogName | seL10n | async }}</label><se-generic-editor-dropdown id=\"se-catalog-selector-dropdown\" *ngIf=\"catalogs.length > 1\" [field]=\"productCatalogField\" [qualifier]=\"'productCatalog'\" [model]=\"model\"></se-generic-editor-dropdown></div><div><label class=\"se-control-label\" [translate]=\"mainDropDownI18nKey\"></label><se-generic-editor-dropdown id=\"se-items-selector-dropdown\" [field]=\"field\" [qualifier]=\"qualifier\" [model]=\"model\" [itemComponent]=\"itemComponent\" [(reset)]=\"reset\"></se-generic-editor-dropdown></div></div><div class=\"product-catalog-item-type-missing\" *ngIf=\"!propertyType\" translate=\"se.cms.catalogawareitem.itemtype.notsupported\"></div>"
    );
     
    $templateCache.put(
        "SlotSharedCloneActionFieldComponent.html", 
        "<div class=\"fd-form__set\"><div class=\"fd-form__item fd-form__item--check\"><label for=\"components-in-slot-options\" class=\"se-control-label\" [translate]=\"'se.cms.slot.shared.replace.editor.componentsinslot'\"></label><div id=\"components-in-slot-options\"><div class=\"se-form-control-row\"><input class=\"fd-form__control\" type=\"radio\" name=\"componentsInSlot\" id=\"clone-all\" [(ngModel)]=\"page.cloneAction\" [value]=\"cloneAction.clone\"/> <label for=\"clone-all\" [translate]=\"'se.cms.slot.shared.replace.editor.componentsinslot.cloneall'\"></label></div><div class=\"se-form-control-row\"><input class=\"fd-form__control\" type=\"radio\" name=\"componentsInSlot\" id=\"use-existing\" [(ngModel)]=\"page.cloneAction\" [value]=\"cloneAction.useExisting\"/> <label for=\"use-existing\" [translate]=\"'se.cms.slot.shared.replace.editor.componentsinslot.useexisting'\"></label></div><div class=\"se-form-control-row\"><input class=\"fd-form__control\" type=\"radio\" name=\"componentsInSlot\" id=\"remove-all\" [(ngModel)]=\"page.cloneAction\" [value]=\"cloneAction.remove\"/> <label for=\"remove-all\" [translate]=\"'se.cms.slot.shared.replace.editor.componentsinslot.removeall'\"></label></div></div></div></div>"
    );
     
    $templateCache.put(
        "SlotSharedSlotTypeFieldComponent.html", 
        "<div class=\"fd-form__set\"><div class=\"fd-form__item fd-form__item--check\"><label for=\"slot-replacement-type-options\" class=\"se-control-label\" [translate]=\"'se.cms.slot.shared.replace.editor.slotreplacementtype'\"></label><div id=\"slot-replacement-type-options\"><div class=\"se-form-control-row\"><input class=\"fd-form__control\" type=\"radio\" name=\"slotReplacementType\" id=\"slot-type-custom\" [(ngModel)]=\"page.isSlotCustom\" [value]=\"true\"/> <label for=\"slot-type-custom\" [translate]=\"'se.cms.slot.shared.replace.editor.slotreplacementtype.nonshared'\"></label></div><div class=\"se-form-control-row\"><input class=\"fd-form__control\" type=\"radio\" name=\"slotReplacementType\" id=\"slot-type-local\" [(ngModel)]=\"page.isSlotCustom\" [value]=\"false\"/> <label for=\"slot-type-local\" [translate]=\"'se.cms.slot.shared.replace.editor.slotreplacementtype.local'\"></label></div></div></div></div>"
    );
     
    $templateCache.put(
        "WorkflowCreateVersionFieldComponent.html", 
        "<div class=\"fd-form__set\"><div class=\"fd-form__item fd-form__item--check\"><label class=\"fd-form__label\"><input type=\"checkbox\" class=\"fd-form__control\" name=\"createVersion\" [(ngModel)]=\"model.createVersion\"/> {{ 'se.cms.workflow.editor.create.version' | translate }}</label></div><div class=\"fd-form__item\" *ngIf=\"model.createVersion\"><label class=\"fd-form__label version-label__title\" for=\"versionLabel\" translate=\"se.cms.workflow.editor.create.version.label\"></label> <input type=\"text\" name=\"versionLabel\" class=\"fd-form__control\" [class.has-error]=\"field.hasErrors\" [(ngModel)]=\"model.versionLabel\"/></div></div>"
    );
     
    $templateCache.put(
        "NavigationEditorTreeComponent.html", 
        "<div class=\"se-navigation-editor-tree__header\" *ngIf=\"!readOnly\"><button class=\"se-navigation-editor-tree__btn fd-button\" (click)=\"actions.addTopLevelNode()\"><span [translate]=\"'se.cms.navigationmanagement.add.top.level.node'\" class=\"se-navigation-editor-tree__btn--text\"></span></button></div><div class=\"se-navigation-editor-tree categoryTable\"><div class=\"tablehead clearfix hidden-xs se-navigation-editor-tree__head\"><div [translate]=\"'se.ytree.template.header.name'\" class=\"se-navigation-editor-tree__name col-xs-3\"></div><div [translate]=\"'se.ytree.template.header.title'\" class=\"se-navigation-editor-tree__title col-xs-3\"></div><div class=\"col-xs-1 pull-right\"></div><div [translate]=\"'se.ytree.template.header.entry'\" class=\"se-navigation-editor-tree__entry col-xs-5 pull-right\"></div></div><se-tree [nodeUri]=\"nodeURI\" [rootNodeUid]=\"rootNodeUid\" [nodeComponent]=\"nodeComponent\" [removeDefaultTemplate]=\"true\" [nodeActions]=\"actions\" [dragOptions]=\"dragOptions\"></se-tree></div>"
    );
     
    $templateCache.put(
        "NavigationNodeComponent.html", 
        "<div class=\"pull-right dropdown tree-node se-tree-node__actions col-sm-1\" [hidden]=\"isReadOnly\"><se-dropdown-menu [dropdownItems]=\"dropdownItems\" [selectedItem]=\"node\" class=\"pull-right se-tree-node__actions--more-menu\"></se-dropdown-menu></div><div class=\"se-tree-node__name col-xs-3\" [title]=\"node.name | seL10n | async\"><span>{{ node.name | seL10n | async }}</span></div><div class=\"pull-right tree-node se-tree-node__entry col-xs-5\"><se-tooltip class=\"se-dropdown-item__delete-page-popover\" [triggers]=\"['mouseenter', 'mouseleave']\" [isChevronVisible]=\"true\" [appendTo]=\"'body'\"><span se-tooltip-trigger class=\"se-tree-node__popover\"><span>{{ entryString }} </span></span><span se-tooltip-body>{{ entryString }}</span></se-tooltip></div><div class=\"se-tree-node__title col-xs-2\"><span [hidden]=\"!node.title\">{{ node.title | seL10n | async }}</span></div>"
    );
     
    $templateCache.put(
        "PageTreeComponent.html", 
        "<div><div class=\"se-page-tree-node\" [ngClass]=\"component.isExpanded && 'se-page-tree-node-expand'\" [attr.node-smartedit-element-uuid]=\"!component.isHidden ?                     component.elementUuid :                     'hidden-component-has-no-uuid'\"><div (click)=\"onClickComponentNode($event)\" class=\"se-page-tree-component-node--content\"><span [ngClass]=\"component.isExpanded ?                                'sap-icon--navigation-down-arrow' :                                'sap-icon--navigation-right-arrow'\" class=\"se-page-tree-node--icon se-page-tree-component-node se-page-tree-component-node--icon\"></span> <span class=\"se-page-tree-node--icon se-page-tree-component-node--icon sap-icon--vertical-grip\"></span> <span class=\"se-page-tree-node--icon se-page-tree-component-node--icon sap-icon--background\"></span><div class=\"se-page-tree-component-node--name\"><span class=\"se-page-tree-component-node--name--up\">{{component.name}}</span> <span class=\"se-page-tree-component-node--name--down\">{{component.typeCode}}</span></div></div><se-page-tree-component-menu [component]=\"component\" [slotId]=\"slotId\" [slotUuid]=\"slotUuid\" class=\"se-page-tree-component-node-menu\"></se-page-tree-component-menu></div></div>"
    );
     
    $templateCache.put(
        "PageTreeComponentMenuComponent.html", 
        "<div class=\"se-page-tree-component-menu\"><span [ngClass]=\"component.isHidden ? 'sap-icon--hide' : 'sap-icon--show'\" class=\"se-page-tree-component-menu--icon\"></span><se-popup-overlay *ngIf=\"!!leftButton\" [popupOverlay]=\"itemTemplateOverlayWrapper\" [popupOverlayTrigger]=\"canShowTemplate(leftButton)\" [popupOverlayData]=\"{ item: leftButton }\" (popupOverlayOnHide)=\"onHideItemPopup(false)\"><span class=\"se-page-tree-component-menu--icon\" [ngClass]=\"leftButton.displayIconClass\" (click)=\"triggerMenuItemAction(leftButton, $event)\"></span></se-popup-overlay><se-popup-overlay [popupOverlay]=\"moreMenuPopupConfig\" [popupOverlayTrigger]=\"moreMenuIsOpen\"><span *ngIf=\"items && items.length > 0\" (click)=\"toggleMoreMenu()\" class=\"se-page-tree-component-menu--icon sap-icon--overflow\"></span></se-popup-overlay></div>"
    );
     
    $templateCache.put(
        "PageTreePanel.html", 
        "<div class=\"se-page-tree\"><div class=\"se-page-tree--header\"><span class=\"se-page-tree--header--icon sap-icon--Chart-Tree-Map\"></span> <span class=\"se-page-tree--header--title\">{{ 'se.page.tree.title' | translate }}</span></div><div *ngFor=\"let node of slotNodes\"><se-page-tree-slot [node]=\"node\" (onSlotExpanded)=\"onSlotExpanded($event)\"></se-page-tree-slot></div></div>"
    );
     
    $templateCache.put(
        "PageTreeSlot.html", 
        "<div><div class=\"se-page-tree-node\" [ngClass]=\"node.isExpanded && 'se-page-tree-node-expand'\" [attr.node-smartedit-element-uuid]=\"node.elementUuid\"><span (click)=\"onClickSlotNode($event)\" [ngClass]=\"node.isExpanded ?                    'sap-icon--navigation-down-arrow' :                    'sap-icon--navigation-right-arrow'\" class=\"se-page-tree-node--icon\"></span> <span class=\"se-page-tree-slot-node--name\" (click)=\"onClickSlotNode($event)\">{{node.componentId}}</span><div class=\"se-page-tree-slot-node-menu\"><span class=\"se-page-tree-slot-node-menu--icon sap-icon--chain-link\"></span> <span class=\"se-page-tree-slot-node-menu--icon sap-icon--synchronize\"></span></div></div><div *ngIf=\"node.isExpanded && node.componentNodes.length\"><div *ngFor=\"let child of node.componentNodes\"><se-page-tree-component [component]=\"child\" [slotId]=\"node.componentId\" [slotUuid]=\"node.componentUuid\" [slotElementUuid]=\"node.elementUuid\" (onComponentExpanded)=\"onComponentExpanded($event)\"></se-page-tree-component></div></div></div>"
    );
     
    $templateCache.put(
        "DeletePageToolbarItemComponent.html", 
        "<div class=\"toolbar-action\" *ngIf=\"isReady\" [attr.data-item-key]=\"toolbarItem.key\"><button type=\"button\" class=\"btn toolbar-action--button\" [disabled]=\"isDeletePageDisabled\" [ngClass]=\"{ 'toolbar-action__disabled' : isDeletePageDisabled }\" (click)=\"deletePage()\"><span class=\"icon-delete se-toolbar-menu-ddlb--button__icon\"></span><div class=\"toolbar-action-button__txt\" translate=\"se.cms.actionitem.page.trash\"></div></button><se-tooltip *ngIf=\"isDeletePageDisabled\" [appendTo]=\"'body'\" [isChevronVisible]=\"true\" [placement]=\"'bottom'\" [triggers]=\"['mouseenter', 'mouseleave']\" [additionalClasses]=\"['se-tooltip--stretched']\"><div se-tooltip-body><span [translate]=\"tooltipMessage\"></span></div></se-tooltip></div>"
    );
     
    $templateCache.put(
        "HomepageIconComponent.html", 
        "<se-tooltip *ngIf=\"isVisible()\" [isChevronVisible]=\"true\" [triggers]=\"['mouseenter', 'mouseleave']\"><span se-tooltip-trigger class=\"sap-icon--home se-homepage-icon\" [ngClass]=\"getIconClass()\"></span> <span se-tooltip-body [translate]=\"getTooltipMessage()\"></span></se-tooltip>"
    );
     
    $templateCache.put(
        "PageInfoMenuComponent.html", 
        "<div class=\"toolbar-action\" data-item-key=\"se.cms.pageInfoMenu\"><fd-popover [(isOpen)]=\"toolbarItem.isOpen\" (isOpenChange)=\"onDropdownToggle($event)\" [closeOnOutsideClick]=\"true\"><fd-popover-control><button type=\"button\" class=\"btn toolbar-action--button\" [attr.aria-pressed]=\"toolbarItem.isOpen\"><span class=\"hyicon hyicon-pageinfo se-toolbar-menu-ddlb--button__icon\"></span><div class=\"se-toolbar-page-info-wrapper\"><span class=\"toolbar-action-button__txt\" [translate]=\"toolbarItem.name\"></span></div></button></fd-popover-control><fd-popover-body><div class=\"se-page-info__dropdown-menu toolbar-action--include\"><div class=\"se-page-info-menu\" *ngIf=\"toolbarItem.isOpen\"><se-prevent-vertical-overflow><div class=\"se-page-info-menu__header\"><span class=\"se-page-info-menu__header-title\" translate=\"se.cms.pageinfo.information.title\"></span><div *seHasOperationPermission=\"editPagePermission\"><button class=\"se-page-info__edit-btn fd-button--compact\" *ngIf=\"isReady\" translate=\"se.cms.contextmenu.title.edit\" (click)=\"onEditPageClick()\"></button></div></div><div *ngIf=\"isReady\" class=\"se-page-info-menu__body\"><se-generic-editor [smarteditComponentId]=\"pageInfo.uid\" [smarteditComponentType]=\"pageInfo.typeCode\" [structure]=\"pageStructure\" [content]=\"pageInfo\"></se-generic-editor></div></se-prevent-vertical-overflow></div></div></fd-popover-body></fd-popover></div>"
    );
     
    $templateCache.put(
        "PageListComponent.html", 
        "<div class=\"se-page-list\"><se-toolbar cssClass=\"se-toolbar--shell\" imageRoot=\"imageRoot\" toolbarName=\"smartEditHeaderToolbar\"></se-toolbar><se-toolbar cssClass=\"se-toolbar--shell se-toolbar--shortcut\" imageRoot=\"imageRoot\" toolbarName=\"smartEditPagesToolbar\"></se-toolbar><div *ngIf=\"isReady\"><div class=\"se-page-list__header\"><span class=\"se-page-list__catalog-name\" translate=\"se.cms.pagelist.title\"></span><p class=\"se-page-list__sub-title\">{{ catalogName | seL10n | async }} - {{ catalogVersion }}</p></div><div class=\"se-page-list__body\"><div class=\"se-page-list__table-header\"><span class=\"se-paged-list__page-count-wrapper\"><span class=\"span-page-list__page-count-text\" translate=\"se.pagelist.countsearchresult\"></span> <span>&nbsp;</span> <span class=\"se-page-list__page-count\">({{ count }})</span></span><div class=\"se-page-list__table-header--right\"><div class=\"fd-form__group se-page-list__search\"><div class=\"se-input-group\"><input type=\"search\" class=\"se-input-group__input-area ySEPage-list-search-input\" maxlength=\"255\" name=\"query\" [ngModel]=\"query\" (ngModelChange)=\"onQueryChange($event)\" [placeholder]=\"'se.cms.pagelist.searchplaceholder' | translate\"/> <span class=\"sap-icon--search se-input-group__addon\"></span><div *ngIf=\"query\" aria-label=\"clear\" class=\"se-input-group__addon se-input-group__clear-btn\" (click)=\"reset()\"><span class=\"sap-icon--decline\"></span></div></div></div><button class=\"fd-button se-page-list__add\" (click)=\"openAddPageWizard()\" translate=\"se.cms.addpagewizard.addpage\"></button></div></div><div class=\"se-page-list__table-body\"><se-dynamic-paged-list [config]=\"pageListConfig\" [mask]=\"query\" (getApi)=\"getApi($event);\" (onItemsUpdate)=\"onPageItemsUpdate($event.pagination)\"></se-dynamic-paged-list></div></div></div></div>"
    );
     
    $templateCache.put(
        "PageListLinkComponent.html", 
        "<div><a class=\"page-list-link-item__link\" [href]=\"getLink()\" translate=\"se.cms.cataloginfo.pagelist\" (click)=\"onClick()\"></a></div>"
    );
     
    $templateCache.put(
        "PagesLinkComponent.html", 
        "<div class=\"se-page-list__page-link--left\" (click)=\"backToPagelist()\"><span class=\"se-page-list__page-link-icon icon-navigation-left-arrow\"></span> <a class=\"se-page-list__page-link-anchor\">{{ 'se.cms.back.to.pagelist' | translate }}</a></div>"
    );
     
    $templateCache.put(
        "RestrictionsModalComponent.html", 
        "<div class=\"se-restrictions-list fd-menu__list fd-menu__list--separated\"><div class=\"se-restriction__item fd-menu__item\" *ngFor=\"let restriction of restrictions\"><div class=\"se-restrictions-list__item-content\"><div class=\"se-restriction__item-name\">{{ restriction.name }}</div><div class=\"se-restriction__item-type-and-id\">{{ restriction.type | seL10n | async }}</div><div class=\"se-restriction__item-description\">{{ restriction.description }}</div></div></div></div>"
    );
     
    $templateCache.put(
        "RestrictionsViewerComponent.html", 
        "<div *ngIf=\"restrictions?.length > 0; else noRestrictions\"><a href=\"\" class=\"show-restrictions-btn\" (click)=\"showRestrictions($event)\">{{restrictions.length}}</a></div><ng-template #noRestrictions><div>-</div></ng-template>"
    );
     
    $templateCache.put(
        "TrashLinkComponent.html", 
        "<div *ngIf=\"isNonActiveCatalog\" (click)=\"goToTrash()\" class=\"se-page-list__page-link--right\"><a translate=\"se.cms.pagelist.trashcan.link.text\" [translateParams]=\"trashedPagesTranslationData\" class=\"se-page-list__page-link-anchor\"></a> <span class=\"se-page-list__page-link-icon sap-icon--navigation-right-arrow\"></span></div>"
    );
     
    $templateCache.put(
        "TrashedPageListComponent.html", 
        "<div class=\"se-page-list\"><se-toolbar cssClass=\"se-toolbar--shell\" imageRoot=\"imageRoot\" toolbarName=\"smartEditHeaderToolbar\"></se-toolbar><se-toolbar cssClass=\"se-toolbar--shell ySmartEditTrashPageToolbar\" imageRoot=\"imageRoot\" toolbarName=\"smartEditTrashPageToolbar\"></se-toolbar><div class=\"se-page-list__header\"><span class=\"se-page-list__catalog-name\" translate=\"se.cms.trashedpagelist.title\"></span><p class=\"se-page-list__sub-title\">{{ catalogName | seL10n | async }} - {{ catalogVersion }}</p></div><div class=\"se-page-list__body\"><div class=\"se-page-list__table-header\"><span class=\"se-paged-list__page-count-wrapper\"><span class=\"span-page-list__page-count-text\" translate=\"se.pagelist.countsearchresult\"></span> <span>&nbsp;</span> <span class=\"se-page-list__page-count\">({{ count }})</span></span><div class=\"fd-form__group se-page-list__search\"><div class=\"se-input-group\"><input type=\"search\" class=\"se-input-group__input-area ySEPage-list-search-input\" placeholder=\"{{ 'se.cms.pagelist.searchplaceholder' | translate }}\" [ngModel]=\"mask\" (ngModelChange)=\"onMaskChange($event)\" name=\"mask\"/> <span class=\"sap-icon--search se-input-group__addon\"></span><div *ngIf=\"mask\" aria-label=\"clear\" class=\"se-input-group__addon se-input-group__clear-btn\" (click)=\"reset()\"><span class=\"sap-icon--decline\"></span></div></div></div></div><div class=\"se-page-list__table-body\"><se-dynamic-paged-list class=\"se-trashed-pages\" [config]=\"trashedPageListConfig\" [mask]=\"mask\" (getApi)=\"getApi($event);\" (onItemsUpdate)=\"onPageItemsUpdate($event.pagination)\"></se-dynamic-paged-list></div></div></div>"
    );
     
    $templateCache.put(
        "catalogDetailsSyncTemplate.html", 
        "<se-synchronize-catalog [catalog]=\"$ctrl.catalog\" [catalog-version]=\"$ctrl.catalogVersion\" [active-catalog-version]=\"$ctrl.activeCatalogVersion\"></se-synchronize-catalog>"
    );
     
    $templateCache.put(
        "CmsDropdownItemComponent.html", 
        "<div class=\"cms-nested-component\" *ngIf=\"item\" [attr.data-component-id]=\"item.uid\"><span class=\"cms-nested-component__item\" *ngIf=\"isSelected\" (click)=\"onClick($event);\"><span class=\"sap-icon--card cms-nested-component__item-icon\"></span><div class=\"cms-nested-component__item-data\"><p class=\"cms-nested-component__item-name\" [title]=\"item.name\">{{ item.name }}</p><p class=\"cms-nested-component__item-type\" [title]=\"item.typeCode\">{{ item.typeCode }}</p></div></span><div class=\"cms-nested-component__result-item\" *ngIf=\"!isSelected\"><span class=\"cms-nested-component__result-name\" [title]=\"item.name\">{{ item.name }}</span> <span class=\"cms-nested-component__result-code\" [title]=\"item.typeCode\">{{ item.typeCode }}</span></div></div>"
    );
     
    $templateCache.put(
        "ComponentItemComponent.html", 
        "<div class=\"se-component-item\" [ngClass]=\"{ 'se-component-item--disabled': isComponentDisabled, 'smartEditComponent': !isComponentDisabled }\" [attr.data-smartedit-component-id]=\"componentInfo.uid\" [attr.data-smartedit-component-uuid]=\"componentInfo.uuid\" [attr.data-smartedit-component-type]=\"componentInfo.typeCode\"><se-tooltip *ngIf=\"isComponentDisabled\" class=\"se-component-item__tooltip\" [appendTo]=\"'body'\" [placement]=\"'bottom'\" [triggers]=\"['mouseenter', 'mouseleave']\" [additionalClasses]=\"['se-component-item__tooltip--for-disabled']\"><div se-tooltip-trigger class=\"se-component-item--disabled-overlay\"></div><div se-tooltip-body class=\"se-popover--inner-content\" translate=\"se.cms.component.non.cloneable.tooltip\" [translateParams]=\"{ componentName: componentInfo.name }\"></div></se-tooltip><div class=\"se-component-item--image\"><span class=\"sap-icon--card\"></span><div *ngIf=\"isSharedComponent\"><span class=\"se-component-item--image-shared--background\"></span> <span class=\"glyphicon glyphicon-link se-component-item--image-shared\"></span></div></div><div class=\"se-component-item--details-container\"><div class=\"se-component-item--details\" title=\"{{ componentInfo.name }} - {{ componentInfo.typeCode }}\"><div class=\"se-component-item--details-name\">{{ componentInfo.name }}</div><div class=\"se-component-item--details-type\">{{ componentInfo.typeCode }}</div></div><se-tooltip *ngIf=\"!componentInfo.visible\" [appendTo]=\"'body'\" [triggers]=\"['mouseenter', 'mouseleave']\" [additionalClasses]=\"['se-component-item--visibility']\"><span se-tooltip-trigger class=\"hyicon hyicon-unpowered\"></span><div se-tooltip-body translate=\"se.cms.component.display.off.tooltip\"></div></se-tooltip></div></div>"
    );
     
    $templateCache.put(
        "ComponentSearchComponent.html", 
        "<div class=\"se-input-group se-component-menu__input-group\"><input type=\"text\" class=\"se-input-group__input-area\" name=\"search-term\" [(ngModel)]=\"searchQuery\" (ngModelChange)=\"onSearchQueryChange($event)\" placeholder=\"{{ placeholderI18nKey | translate }}\"/> <span class=\"sap-icon--search se-input-group__addon\"></span><div *ngIf=\"showResetButton\" class=\"se-input-group__addon se-input-group__clear-btn\" (click)=\"resetSearch($event)\"><span class=\"sap-icon--decline\"></span></div></div>"
    );
     
    $templateCache.put(
        "ComponentTypeComponent.html", 
        "<div class=\"se-component-item smartEditComponent\" [attr.data-smartedit-component-type]=\"typeInfo.code\"><div class=\"se-component-item--image\"><span class=\"sap-icon--card\"></span></div><div class=\"se-component-item--details-type\" [title]=\"typeInfo.i18nKey | translate\">{{ typeInfo.name }}</div></div>"
    );
     
    $templateCache.put(
        "ComponentTypesTabComponent.html", 
        "<div class=\"se-component-menu__types-header\"><se-component-search (onChange)=\"onSearchTermChanged($event)\" [placeholderI18nKey]=\"'se.cms.componentmenu.search.type.placeholder'\" class=\"se-component-menu__type-search\"></se-component-search></div><div class=\"se-component-menu__result-container\"><se-infinite-scrolling class=\"se-component-menu__infinite-scroll\" *ngIf=\"isMenuOpen() || isTabActive()\" [pageSize]=\"10\" [mask]=\"searchTerm\" [fetchPage]=\"loadComponentTypes\" [context]=\"componentsContext\"><div class=\"se-component-menu__result se-component-menu__result--types\"><div class=\"se-component-menu__item-wrap\" *ngFor=\"let componentType of componentsContext.items\"><se-component-type [typeInfo]=\"componentType\"></se-component-type></div></div></se-infinite-scrolling></div>"
    );
     
    $templateCache.put(
        "ComponentsTabComponent.html", 
        "<div class=\"se-component-menu__tabs-header\"><div class=\"se-component-menu__tabs-header--upper\" *ngIf=\"hasMultipleContentCatalogs()\"><se-select id=\"se-components-tab-catalog-versions\" class=\"se-component-menu__select\" [(model)]=\"selectedCatalogVersionId\" (modelChange)=\"onCatalogVersionChange()\" [fetchStrategy]=\"catalogVersionsFetchStrategy\" [searchEnabled]=\"false\" [itemComponent]=\"itemComponent\"></se-select></div><div class=\"se-component-menu__tabs-header--lower\"><se-component-search (onChange)=\"onSearchTermChanged($event)\" [placeholderI18nKey]=\"'se.cms.componentmenu.search.placeholder'\" class=\"se-component-menu__tabs-search\"></se-component-search><fieldset class=\"fd-form__set\"><div class=\"fd-form__item fd-form__item--check se-component-menu__clone-on-drop\"><input type=\"checkbox\" class=\"fd-form__control se-component-menu__clone-check-box\" id=\"component-clone-checkbox\" name=\"clone-on-drop\" [(ngModel)]=\"cloneOnDrop\" (ngModelChange)=\"onComponentCloneOnDropChange($event)\"/> <label class=\"fd-form__label se-component-menu__clone-label\" for=\"component-clone-checkbox\" translate=\"se.cms.component.clone.on.drop.label\"></label></div></fieldset></div></div><div class=\"se-component-menu__result-container\" *ngIf=\"forceRecompile\"><se-infinite-scrolling *ngIf=\"isActive()\" class=\"se-component-menu__infinite-scroll\" [ngClass]=\"{'se-component-menu__infinite-scroll--short': hasMultipleContentCatalogs() }\" [pageSize]=\"10\" [mask]=\"searchTerm\" [fetchPage]=\"loadComponentItems\" [context]=\"componentsContext\"><div class=\"se-component-menu__result\" *ngIf=\"componentsContext.items.length\"><se-component-item class=\"se-component-menu__item-wrap\" *ngFor=\"let item of componentsContext.items; trackBy: trackById\" [componentInfo]=\"item\" [cloneOnDrop]=\"cloneOnDrop\"></se-component-item></div></se-infinite-scrolling></div>"
    );
     
    $templateCache.put(
        "ComponentRestrictionsEditorComponent.html", 
        "<se-restrictions-editor [editable]=\"isEditable\" [getRestrictionTypes]=\"getRestrictionTypes\" [getSupportedRestrictionTypes]=\"getSupportedRestrictionTypes\" [item]=\"model\" [restrictionUuids]=\"model.restrictions\" (onRestrictionsChange)=\"onRestrictionsChange($event)\"></se-restrictions-editor>"
    );
     
    $templateCache.put(
        "DuplicatePrimaryContentPageLabelComponent.html", 
        "<div><div class=\"fd-form__item fd-form__item--check\"><input class=\"fd-form__control\" type=\"radio\" name=\"duplicateResolution\" id=\"overwritePrimaryPageOption\" [(ngModel)]=\"conflictResolution\" (click)=\"selectResolution(RESOLUTION_OPTIONS.overwritePage)\" [value]=\"RESOLUTION_OPTIONS.overwritePage\"/> <label for=\"overwritePrimaryPageOption\" class=\"fd-form__label\" [translate]=\"'se.cms.page.restore.content.duplicate.primaryforvariation.option.overwrite'\"></label></div><div class=\"fd-form__item fd-form__item--check\"><input class=\"fd-form__control\" type=\"radio\" name=\"duplicateResolution\" id=\"renamePrimaryPageOption\" [(ngModel)]=\"conflictResolution\" (click)=\"selectResolution(RESOLUTION_OPTIONS.renamePageLabel)\" [value]=\"RESOLUTION_OPTIONS.renamePageLabel\"/> <label for=\"renamePrimaryPageOption\" class=\"fd-form__label\" [translate]=\"'se.cms.page.restore.content.duplicate.primaryforvariation.option.rename'\"></label></div><div class=\"rename-label-section\" *ngIf=\"conflictResolution === RESOLUTION_OPTIONS.renamePageLabel\"><label [translate]=\"'se.cms.page.restore.page.label'\"></label> <input type=\"text\" class=\"form-control\" [(ngModel)]=\"page['label']\"/></div></div>"
    );
     
    $templateCache.put(
        "DuplicatePrimaryNonContentPageComponent.html", 
        "<div><label [translate]=\"label\"></label></div>"
    );
     
    $templateCache.put(
        "MissingPrimaryContentPageComponent.html", 
        "<div><div><label class=\"missing-primary-content-page-message__label\" [translate]=\"'se.cms.page.restore.content.page.noprimaryforvariation.msg'\"></label></div><se-select id=\"se-page-restore-change-primary-selector-dropdown\" [(model)]=\"cmsPage.label\" [fetchStrategy]=\"fetchStrategy\"></se-select></div>"
    );
     
    $templateCache.put(
        "MuteBooleanComponent.html", 
        "<div class=\"se-boolean fd-form__item fd-form__item--check\"><span class=\"fd-toggle fd-toggle--xs fd-form__control\"><label class=\"fd-form__label\" for=\"{{widget.qualifier}}-checkbox\"><input type=\"checkbox\" id=\"{{widget.qualifier}}-checkbox\" class=\"se-boolean__input\" [placeholder]=\"(widget.field.tooltip || '') | translate\" [attr.name]=\"widget.qualifier\" [disabled]=\"!widget.field.editable\" [(ngModel)]=\"widget.model[widget.qualifier]\"/> <span class=\"fd-toggle__switch\" role=\"presentation\"></span></label></span><p *ngIf=\"widget.field.labelText && !widget.model[widget.qualifier]\" class=\"se-boolean__text\">{{widget.field.labelText| translate}}</p></div>"
    );
     
    $templateCache.put(
        "ThumbnailSelectComponent.html", 
        "<se-generic-editor-dropdown [id]=\"id\" [field]=\"field\" [qualifier]=\"qualifier\" [model]=\"model\"></se-generic-editor-dropdown>"
    );
     
    $templateCache.put(
        "clonePageInfoStepTemplate.html", 
        "<se-component-clone-info-form data-ng-if=\"clonePageWizardCtrl.isPageInfoActive()\" [structure]=\"clonePageWizardCtrl.getPageInfoStructure()\" [content]=\"clonePageWizardCtrl.getPageInfo()\" [(submit)]=\"clonePageWizardCtrl.callbacks.savePageInfo\" [(reset)]=\"clonePageWizardCtrl.callbacks.resetPageInfo\" [(is-dirty)]=\"clonePageWizardCtrl.callbacks.isDirtyPageInfo\" [(is-valid)]=\"clonePageWizardCtrl.callbacks.isValidPageInfo\" [page-template]=\"clonePageWizardCtrl.getPageTemplate()\" [page-type-code]=\"clonePageWizardCtrl.getPageTypeCode()\" [uri-context]=\"clonePageWizardCtrl.uriContext\" [target-catalog-version]=\"clonePageWizardCtrl.getTargetCatalogVersion()\"></se-component-clone-info-form>"
    );
     
    $templateCache.put(
        "clonePageOptionsStepTemplate.html", 
        "<se-event-message class=\"existing-homepage__ymessage\" [show-event]=\"'CMS_EVENT_SHOW_REPLACE_PARENT_HOMEPAGE_INFO'\" [hide-event]=\"'CMS_EVENT_HIDE_REPLACE_PARENT_HOMEPAGE_INFO'\"></se-event-message><se-select-target-catalog-version data-ng-if=\"clonePageWizardCtrl.isBasePageInfoAvailable()\" [page-type-code]=\"clonePageWizardCtrl.getPageTypeCode()\" [page-label]=\"clonePageWizardCtrl.getPageLabel()\" [uri-context]=\"clonePageWizardCtrl.uriContext\" (on-target-catalog-version-selected)=\"clonePageWizardCtrl.onTargetCatalogVersionSelected($event)\"></se-select-target-catalog-version><se-new-page-display-condition [page-type-code]=\"clonePageWizardCtrl.getPageTypeCode()\" [uri-context]=\"clonePageWizardCtrl.uriContext\" [result-fn]=\"clonePageWizardCtrl.variationResult\" [initial-condition-selected-key]=\"'page.displaycondition.variation'\" [initial-primary-page-selected-label]=\"clonePageWizardCtrl.getPageLabel()\" [target-catalog-version]=\"clonePageWizardCtrl.getTargetCatalogVersion()\"></se-new-page-display-condition><se-component-clone-option-form (on-selection-change)=\"clonePageWizardCtrl.triggerUpdateCloneOptionResult($event)\"></se-component-clone-option-form>"
    );
     
    $templateCache.put(
        "clonePageRestrictionsStepTemplate.html", 
        "<span data-ng-if=\"clonePageWizardCtrl.isRestrictionsActive()\" class=\"se-clone-page-restriction-step\"><div data-ng-if=\"clonePageWizardCtrl.getPageRestrictions().length > 1\"><se-page-restrictions-info-message></se-page-restrictions-info-message></div><se-restrictions-editor [editable]=\"true\" [(reset-fn)]=\"clonePageWizardCtrl.restrictionsEditorFunctionBindings.reset\" [(cancel-fn)]=\"clonePageWizardCtrl.restrictionsEditorFunctionBindings.cancel\" [(is-dirty-fn)]=\"clonePageWizardCtrl.restrictionsEditorFunctionBindings.isDirty\" (on-restrictions-change)=\"clonePageWizardCtrl.restrictionsResult($event)\" [get-restriction-types]=\"clonePageWizardCtrl.getRestrictionTypes\" [get-supported-restriction-types]=\"clonePageWizardCtrl.getSupportedRestrictionTypes\" [item]=\"clonePageWizardCtrl.getBasePageInfo()\" [restrictionUuids]=\"clonePageWizardCtrl.model.restrictions\"></se-restrictions-editor></span>"
    );
     
    $templateCache.put(
        "DisplayConditionsEditorComponent.html", 
        "<div><se-event-message class=\"existing-homepage__ymessage\" [showEvent]=\"'CMS_EVENT_SHOW_REPLACE_PARENT_HOMEPAGE_INFO'\" [hideEvent]=\"'CMS_EVENT_HIDE_REPLACE_PARENT_HOMEPAGE_INFO'\"></se-event-message><se-display-conditions-page-info [pageName]=\"getPageName()\" [pageType]=\"getPageType()\" [isPrimary]=\"isPagePrimary()\"></se-display-conditions-page-info><se-display-conditions-page-variations *ngIf=\"isPagePrimary()\" [variations]=\"getVariations()\"></se-display-conditions-page-variations><se-display-conditions-primary-page *ngIf=\"!isPagePrimary()\" [readOnly]=\"getIsAssociatedPrimaryReadOnly()\" [associatedPrimaryPage]=\"getAssociatedPrimaryPage()\" [pageType]=\"getPageType()\" (onPrimaryPageSelect)=\"onPrimaryPageSelect($event)\"></se-display-conditions-primary-page><div *ngIf=\"showHomePageWidget()\"><div class=\"se-component-homepage\"><label class=\"se-control-label\"><input type=\"checkbox\" id=\"set-homepage-checkbox\" class=\"fd-form__control se-display-conditions__homepage-input\" name=\"clone-on-drop\" [disabled]=\"disableHomepageCheckbox()\" (ngModelChange)=\"homePageChanged($event)\" [ngModel]=\"page.homepage\"/> <span translate=\"se.cms.display.conditions.homepage.set\"></span><se-help *ngIf=\"disableHomepageCheckbox()\"><span translate=\"se.cms.display.conditions.homepage.disabled\"></span></se-help></label></div><div class=\"se-display-conditions__replace-home-message\" *ngIf=\"showReplaceLabel\" translate=\"se.cms.display.conditions.homepage.replace\" [translateParams]=\"{ currentHomepage: currentHomePageName }\"></div></div></div>"
    );
     
    $templateCache.put(
        "DisplayConditionsPageInfoComponent.html", 
        "<div class=\"se-edit-page-info__display-conditions\"><div class=\"se-edit-page-info-display-conditions__basic-info\"><div><label class=\"se-control-label\" translate=\"se.cms.pagelist.headerpagename\"></label><div class=\"form-readonly-text form-readonly-text__tight dc-page-name\">{{ pageName }}</div></div><div><label class=\"se-control-label\" translate=\"se.cms.pagelist.headerpagetype\"></label><div class=\"form-readonly-text form-readonly-text__tight dc-page-type\">{{ pageType }}</div></div></div><label class=\"se-control-label\"><span translate=\"se.cms.display.conditions.label\"></span><se-help><span [translate]=\"getPageDisplayConditionDescriptionI18nKey()\"></span></se-help></label><p class=\"form-readonly-text form-readonly-text__tight dc-page-display-condition\" [translate]=\"getPageDisplayConditionI18nKey()\"></p></div>"
    );
     
    $templateCache.put(
        "DisplayConditionsPageVariationsComponent.html", 
        "<div class=\"form-group dc-page-variations\"><label class=\"se-control-label control-label__margin\"><span translate=\"se.cms.display.conditions.variation.pages.title\"></span><se-help *ngIf=\"variations.length > 0\"><span translate=\"se.cms.display.conditions.variations.description\"></span></se-help></label><div *ngIf=\"variations.length === 0\" class=\"dc-no-variations form-readonly-text form-readonly-text__tight form-readonly-text__inline\" translate=\"se.cms.display.conditions.no.variations\"></div><div *ngIf=\"variations.length > 0\"><se-client-paged-list [items]=\"variations\" [keys]=\"keys\" [itemsPerPage]=\"itemsPerPage\" class=\"dc-page-variations-list\"></se-client-paged-list></div></div>"
    );
     
    $templateCache.put(
        "DisplayConditionsPrimaryPageComponent.html", 
        "<div class=\"form-group form-group__inline\"><label class=\"se-control-label control-label__margin\" translate=\"se.cms.display.conditions.primary.page.label\"></label><div *ngIf=\"readOnly\" class=\"dc-associated-primary-page form-readonly-text form-readonly-text__tight\">{{ associatedPrimaryPage?.name }}</div><div *ngIf=\"!readOnly\"><se-select id=\"display-conditions-primary-association-selector\" [model]=\"associatedPrimaryPageUid\" (modelChange)=\"associatedPrimaryPageUidOnChange($event)\" [fetchStrategy]=\"fetchStrategy\"></se-select><span *ngIf=\"associatedPrimaryPage?.name\" class=\"se-form-help-message\"><span>{{ 'se.cms.page.label.label' | translate }}: {{ associatedPrimaryPage.label }}</span></span></div></div>"
    );
     
    $templateCache.put(
        "ClonePageItemComponent.html", 
        "<div *seHasOperationPermission=\"clonePagePermission\"><a class=\"se-dropdown-item fd-menu__item\" (click)=\"onClickOnClone()\"><span class=\"se-dropdown-item--label\" translate=\"se.cms.actionitem.page.clone\"></span></a></div>"
    );
     
    $templateCache.put(
        "DeletePageItemComponent.html", 
        "<div *seHasOperationPermission=\"deletePagePermission\"><div class=\"se-dropdown-item__delete-wrapper\"><div class=\"se-dropdown-item__delete-link-wrapper\" [ngClass]=\"{'se-dropdown-item__delete-link-wrapper--disabled': !isDeletePageEnabled}\"><a class=\"se-dropdown-item se-dropdown-item__delete fd-menu__item\" [ngClass]=\"{'se-dropdown-item--disabled': !isDeletePageEnabled}\" (click)=\"isDeletePageEnabled && onClickOnDeletePage()\"><span class=\"se-dropdown-item--label\" translate=\"se.cms.actionitem.page.trash\"></span></a></div><se-tooltip *ngIf=\"!isDeletePageEnabled\" class=\"se-dropdown-item__delete-page-popover\" [placement]=\"'left'\" [triggers]=\"['mouseenter', 'mouseleave']\" [isChevronVisible]=\"true\" [appendTo]=\"'body'\"><span se-tooltip-trigger class=\"sap-icon--message-error\"></span><div se-tooltip-body class=\"popover-tooltip\"><span [translate]=\"tooltipMessage\"></span></div></se-tooltip></div></div>"
    );
     
    $templateCache.put(
        "EditPageItemComponent.html", 
        "<div *seHasOperationPermission=\"editPagePermission\"><a class=\"se-dropdown-item fd-menu__item\" (click)=\"onClickOnEdit()\"><span class=\"se-dropdown-item--label\" translate=\"se.cms.actionitem.page.edit\"></span></a></div>"
    );
     
    $templateCache.put(
        "PermanentlyDeletePageItemComponent.html", 
        "<div *seHasOperationPermission=\"permanentlyDeletePagePermission\"><div class=\"se-dropdown-item__delete-wrapper\"><div class=\"se-dropdown-item__delete-link-wrapper\" [ngClass]=\"{'se-dropdown-item__delete-link-wrapper--disabled': isDeleteButtonDisabled()}\"><a class=\"se-dropdown-item se-dropdown-item__delete fd-menu__item\" [ngClass]=\"{'se-dropdown-item--disabled': isDeleteButtonDisabled()}\" (click)=\"permanentlyDelete()\"><span [translate]=\"'se.cms.actionitem.page.permanently.delete'\"></span></a></div><se-tooltip class=\"se-dropdown-item__delete-page-popover\" *ngIf=\"isDeleteButtonDisabled()\" [placement]=\"'left'\" [triggers]=\"['mouseenter', 'mouseleave']\" [isChevronVisible]=\"true\" [appendTo]=\"'body'\"><span se-tooltip-trigger class=\"sap-icon--message-error\"></span> <span se-tooltip-body [translate]=\"'se.cms.actionitem.page.permanently.delete.blocked'\"></span></se-tooltip></div></div>"
    );
     
    $templateCache.put(
        "RestorePageItemComponent.html", 
        "<div *seHasOperationPermission=\"restorePagePermission\"><a class=\"se-dropdown-item fd-menu__item\" (click)=\"restorePage()\"><span [translate]=\"'se.cms.actionitem.page.restore'\"></span></a></div>"
    );
     
    $templateCache.put(
        "SyncPageItemComponent.html", 
        "<div *seHasOperationPermission=\"syncPagePermission\"><a class=\"se-dropdown-item fd-menu__item\" (click)=\"sync()\" translate=\"se.cms.actionitem.page.sync\"></a></div>"
    );
     
    $templateCache.put(
        "UpdatePageStatusComponent.html", 
        "<div *ngIf=\"showButton\"><a class=\"se-dropdown-item fd-menu__item\" (click)=\"onClickOnSync()\"><span [translate]=\"'se.cms.actionitem.page.sync'\"></span></a></div>"
    );
     
    $templateCache.put(
        "RestrictionManagementComponent.html", 
        "<div *ngIf=\"isReady\"><div *ngIf=\"isEditMode\"><se-restriction-management-edit [restriction]=\"config?.restriction\" [getSupportedRestrictionTypes]=\"config?.getSupportedRestrictionTypesFn\" [uriContext]=\"uriContext\" [(isDirtyFn)]=\"isDirtyInternal\" [(submitFn)]=\"submitInternal\"></se-restriction-management-edit></div><div *ngIf=\"!isEditMode\"><se-restriction-management-select [existingRestrictions]=\"config?.existingRestrictions\" [fetchRestrictionTypes]=\"config?.getRestrictionTypesFn\" [getSupportedRestrictionTypes]=\"config?.getSupportedRestrictionTypesFn\" [uriContext]=\"uriContext\" [(isDirtyFn)]=\"isDirtyInternal\" [(submitFn)]=\"submitInternal\"></se-restriction-management-select></div></div>"
    );
     
    $templateCache.put(
        "RestrictionManagementEditComponent.html", 
        "<div *ngIf=\"ready\"><div *ngIf=\"isTypeSupported\"><div class=\"se-restriction-management-edit__header\"><div>{{ restriction.name }}</div><div>{{ restriction.typeCode }}</div></div><div><se-item-manager [item]=\"restriction\" [mode]=\"itemManagementMode\" [structureApi]=\"structureApi\" [contentApi]=\"contentApi\" [uriContext]=\"uriContext\" [componentType]=\"restriction.itemtype\" [(submitFunction)]=\"submitInternal\" [(isDirty)]=\"isDirtyInternal\"></se-item-manager></div></div><div *ngIf=\"!isTypeSupported\"><div class=\"se-restrictions-list__item-content\"><div translate=\"se.cms.restriction.management.select.type.not.supported.warning\"></div><p class=\"se-restriction__item-name\">{{ restriction.name }}</p><div class=\"se-restriction__item-description\">{{ restriction.description }}</div></div></div></div>"
    );
     
    $templateCache.put(
        "RestrictionManagementSelectComponent.html", 
        "<div><se-message [style.display]=\"showWarningMessage() ? 'block' : 'none'\" [type]=\"'warning'\"><span se-message-title translate=\"se.cms.restriction.management.select.type.not.supported.warning\"></span></se-message><div class=\"se-restriction-management-select__select\"><label class=\"se-control-label\">{{ 'se.cms.restriction.management.select.type.label' | translate }}</label><se-select id=\"restriction-type\" [fetchStrategy]=\"fetchStrategy\" [itemComponent]=\"itemComponent\" [placeholder]=\"'se.cms.restriction.management.select.type.placeholder'\" [(model)]=\"selectModel.selectedIds.restrictionType\" (modelChange)=\"selectRestrictionType()\" [searchEnabled]=\"false\"></se-select></div><div *ngIf=\"viewConfig.showRestrictionSelector\" class=\"se-restriction-management-select__restriction-info\"><label class=\"se-control-label\" translate=\"se.cms.restriction.management.select.restriction.label\"></label><se-select id=\"restriction-name\" [fetchStrategy]=\"fetchOptions\" [(model)]=\"selectModel.selectedIds.restriction\" (modelChange)=\"selectRestriction()\" [placeholder]=\"'se.cms.restriction.management.select.restriction.placeholder'\" [disableChoiceFn]=\"disableRestrictionChoice\" [itemComponent]=\"itemComponent\" [resultsHeaderLabel]=\"resultsHeaderLabel\" [actionableSearchItem]=\"actionableSearchItem\" [(reset)]=\"reset\"></se-select></div><div class=\"se-restriction-management-select__restriction-editor\" *ngIf=\"viewConfig.showRestrictionEditor\"><p class=\"se-restriction-management-select__new-restriction-message\" [translate]=\"editorHeader\"></p><div *ngIf=\"selectModel.isTypeSupported()\"><se-item-manager [item]=\"selectModel.getRestriction()\" [mode]=\"viewConfig.mode\" [structureApi]=\"viewConfig.structureApi\" [contentApi]=\"viewConfig.contentApi\" [uriContext]=\"uriContext\" [componentType]=\"selectModel.getRestrictionTypeCode()\" [(submitFunction)]=\"submitInternal\" [(isDirty)]=\"isDirtyInternal\"></se-item-manager></div><div *ngIf=\"!selectModel.isTypeSupported()\"><p class=\"se-restriction__item-name\">{{ selectModel.getRestriction().name }}</p><div class=\"se-restriction__item-description\">{{ selectModel.getRestriction().description }}</div></div></div></div>"
    );
     
    $templateCache.put(
        "RestrictionsEditorComponent.html", 
        "<div class=\"se-restrictions-container\"><div class=\"se-restrictions-container__header\" [ngClass]=\"{ 'se-restrictions-container__header--empty': restrictions.length === 0 }\"><label class=\"se-restrictions__sub-header\" translate=\"se.cms.restrictions.list.title\"></label><div class=\"se-restrictions-container__header--right\"><div *ngIf=\"restrictions.length > 1\"><div *ngIf=\"editable\"><se-select id=\"criteria-type\" [fetchStrategy]=\"criteriaFetchStrategy\" [itemComponent]=\"itemComponent\" [placeholder]=\"'se.cms.restrictions.picker.type.placeholder'\" [model]=\"criteria.id\" (modelChange)=\"matchCriteriaChanged($event)\" [searchEnabled]=\"false\"></se-select></div><div *ngIf=\"!editable\">{{ 'se.cms.restrictions.criteria' | translate }} {{ criteria.label | translate }}</div></div><button *ngIf=\"!showRestrictionPicker\" type=\"button\" class=\"se-restrictions__add-restriction-btn fd-button--cozy\" [disabled]=\"!editable\" (click)=\"onAddRestriction()\"><span translate=\"se.cms.restrictions.editor.button.add.new\"></span></button> <button class=\"cms-clean-btn se-restriction__clear-all__btn fd-button--light fd-button--compact\" *ngIf=\"showRemoveAllButton()\" (click)=\"removeAllRestrictions()\" translate=\"se.cms.restrictions.list.clear.all\"></button></div></div><se-slider-panel [sliderPanelConfiguration]=\"sliderPanelConfiguration\" [(sliderPanelHide)]=\"sliderPanelHide\" [(sliderPanelShow)]=\"sliderPanelShow\" (isShownChange)=\"onSliderVisibilityChange($event)\" class=\"se-add-restriction-panel\"><se-restriction-management *ngIf=\"isSliderVisible\" class=\"se-se-add-restriction-panel__restriction-management\" [config]=\"restrictionManagement.config\" [uriContext]=\"restrictionManagement.uriContext\" [(submitFn)]=\"restrictionManagement.submitFn\" [(isDirtyFn)]=\"restrictionManagement.isDirtyFn\"></se-restriction-management></se-slider-panel><div *ngIf=\"errors.length > 0\"><span class=\"se-help-block--has-error help-block fd-form__message fd-form__message--error\" *ngFor=\"let error of errors\" [translate]=\"error.message\"></span></div><se-restrictions-table *ngIf=\"isRestrictionsReady\" [editable]=\"editable\" [restrictions]=\"restrictions\" [restrictionCriteria]=\"criteria\" [errors]=\"errors\" [customClass]=\"'ySERestrictionListLink'\" (onEdit)=\"onEditRestriction($event)\" (onRemove)=\"onRemoveRestriction($event)\"></se-restrictions-table></div>"
    );
     
    $templateCache.put(
        "RestrictionsTableComponent.html", 
        "<div class=\"se-restriction-table-wrapper se-restriction-table-left\" [ngClass]=\"customClass\"><div class=\"se-restrictions-list fd-menu__list fd-menu__list--separated\" *ngIf=\"restrictions.length > 0\"><div id=\"restriction-{{ index + 1 }}\" *ngFor=\"let restriction of restrictions; let index = index\" class=\"se-restriction__item fd-menu__item\"><div class=\"se-restrictions-list__item-content\"><p class=\"se-restriction__item-name\" [ngClass]=\"{ 'error-input': isInError(index) }\">{{ restriction.name }}</p><div class=\"se-restriction__item-type-and-id\" [ngClass]=\"{ 'error-input': isInError(index) }\">{{ restriction.typeCode }}</div><div class=\"se-restriction__item-description\" [ngClass]=\"{ 'error-input': isInError(index) }\" [title]=\"restriction.description\">{{ restriction.description }}</div><div id=\"restrictionPartOfWorkflow\" *ngIf=\"restriction.canBeEdited!==undefined && !restriction.canBeEdited\" translate=\"se.cms.restrictions.editor.part.of.workflow\"></div></div><div *ngIf=\"editable\"><se-dropdown-menu [dropdownItems]=\"restriction.actions || defaultActions\" [selectedItem]=\"restriction\" [placement]=\"'bottom-start'\"></se-dropdown-menu></div></div></div><div *ngIf=\"restrictions.length === 0\" class=\"se-restrictions-list--empty\"><span class=\"se-restrictions-list--empty__message\" translate=\"se.cms.restrictions.emptylist.message\"></span></div></div>"
    );
     
    $templateCache.put(
        "PageSyncMenuToolbarItemComponent.html", 
        "<ng-container *seHasOperationPermission=\"'se.sync.catalog'\"><fd-popover [(isOpen)]=\"toolbarItem.isOpen\" [closeOnOutsideClick]=\"true\"><fd-popover-control><button type=\"button\" class=\"btn toolbar-action--button\" [attr.aria-expanded]=\"toolbarItem.isOpen\"><span class=\"icon-synchronize se-toolbar-menu-ddlb--button__icon\"><span *ngIf=\"isNotInSync\" class=\"hyicon hyicon-caution se-toolbar-menu-ddlb--button__caution\"></span> </span><span class=\"toolbar-action-button__txt\" [ngClass]=\"{'se-toolbar-menu-ddlb--button__txt': isNotInSync }\" [translate]=\"toolbarItem.name\"></span></button></fd-popover-control><fd-popover-body><div *ngIf=\"toolbarItem.isOpen && isReady\" class=\"toolbar-action--include se-sync-menu-content__dropdown\"><se-prevent-vertical-overflow><div class=\"se-sync-menu-content__header\"><span class=\"se-sync-menu-content__header-title\" translate=\"se.cms.synchronization.page.title\"></span><se-help *ngIf=\"!syncPageConditions?.canSyncHomepage && !syncPageConditions?.pageHasNoDepOrNoSyncStatus\" class=\"se-page-sync__y-help\"><span>{{ helpText }}</span></se-help></div><se-page-synchronization-panel [cmsPage]=\"cmsPage\" [uriContext]=\"uriContext\"></se-page-synchronization-panel></se-prevent-vertical-overflow></div></fd-popover-body></fd-popover></ng-container>"
    );
     
    $templateCache.put(
        "PageSynchronizationHeaderComponent.html", 
        "<ng-container *ngIf=\"ready\"><div class=\"se-sync-panel-header\"><span class=\"se-sync-panel-header__sub-header\" [translate]=\"getSubHeaderText()\"></span></div><div *ngIf=\"isNewPage()\" class=\"se-sync-panel-new-page\"><div class=\"se-sync-panel-new-page__header\" translate=\"se.cms.synchronization.page.new.header\"></div><div class=\"se-sync-panel-new-page__message\">{{ headerText }}</div></div><div class=\"se-sync-panel-header__timestamp\" *ngIf=\"!isNewPage()\"><div translate=\"se.cms.synchronization.panel.lastsync.text\"></div><span class=\"se-sync-panel-header__timestamp-text\">{{ syncStatus.lastSyncStatus | date: 'M/d/yy h:mm a' }}</span></div></ng-container>"
    );
     
    $templateCache.put(
        "PageSynchronizationPanelComponent.html", 
        "<se-page-synchronization-header class=\"se-sync-panel__sync-status\" [syncStatus]=\"syncStatus\" [pageSyncConditions]=\"pageSyncConditions\"></se-page-synchronization-header><se-synchronization-panel *ngIf=\"!showFooter\" [itemId]=\"cmsPage.uuid\" [showFooter]=\"false\" [getSyncStatus]=\"getSyncStatus\" [performSync]=\"performSync\" (selectedItemsUpdate)=\"onSelectedItemsUpdate($event)\" (syncStatusReady)=\"onSyncStatusReady($event)\" (getApi)=\"onGetApi($event)\"></se-synchronization-panel><se-synchronization-panel *ngIf=\"showFooter\" [itemId]=\"cmsPage.uuid\" [getSyncStatus]=\"getSyncStatus\" [performSync]=\"performSync\" (syncStatusReady)=\"onSyncStatusReady($event)\" (getApi)=\"onGetApi($event)\"></se-synchronization-panel>"
    );
     
    $templateCache.put(
        "SynchronizeCatalogComponent.html", 
        "<div class=\"se-synchronize-catalog\"><div class=\"se-synchronize-catalog__sync-info\"><div *ngIf=\"isSyncJobFinished()\"><label class=\"se-synchronize-catalog__sync-info__sync-label\" *ngIf=\"catalogVersion.active\"><span translate=\"se.cms.cataloginfo.lastsyncedfrom\"></span>&nbsp; <span>{{ syncJobStatus.source }}</span></label> <label class=\"se-synchronize-catalog__sync-info__sync-label\" *ngIf=\"!catalogVersion.active\" translate=\"se.cms.cataloginfo.lastsynced\"></label> <span class=\"se-synchronize-catalog__sync-info__last-synched\">{{ syncJobStatus.syncEndTime | date: 'M/d/yy h:mm a' }}</span></div><span class=\"se-synchronize-catalog__in-progress\" *ngIf=\"isSyncJobInProgress()\" translate=\"se.sync.status.synced.inprogress\"></span> <span class=\"label-error se-synchronize-catalog__sync-failed\" *ngIf=\"isSyncJobFailed()\" translate=\"se.sync.status.synced.syncfailed\"></span></div><ng-container *seHasOperationPermission=\"syncCatalogPermission\"><ng-container *ngIf=\"!catalogVersion.active\"><button class=\"se-synchronize-catalog__sync-btn fd-button--emphasized\" [disabled]=\"!isSyncButtonEnabled()\" (click)=\"syncCatalog()\" translate=\"se.cms.cataloginfo.btn.sync\"></button></ng-container></ng-container></div>"
    );
     
    $templateCache.put(
        "VersionItemContextComponent.html", 
        "<div class=\"se-version-item-context\"><span class=\"sap-icon--navigation-right-arrow\"></span><se-tooltip *ngIf=\"(pageVersion$ | async) as pageVersion\" [triggers]=\"['mouseenter', 'mouseleave']\" [placement]=\"'bottom'\" [isChevronVisible]=\"true\"><div se-tooltip-trigger class=\"se-version-item-context__info\"><div class=\"se-version-item-context__info-label\" [title]=\"pageVersion.label\">{{ pageVersion.label }}</div><div class=\"se-version-item-context__info-date\">{{ pageVersion.creationtime | date: 'M/d/yy h:mm a' }}</div></div><div se-tooltip-body class=\"se-version-item-context__description-wrapper\"><span class=\"se-version-item-context__description\">{{ pageVersion.description || (EMPTY_DESCRIPTION_MSG_KEY | translate) }}</span></div></se-tooltip><button type=\"button\" (click)=\"deselectPageVersion()\" class=\"se-version-item-context__remove-btn fd-button--light sap-icon--decline\"></button></div>"
    );
     
    $templateCache.put(
        "VersionsPanelComponent.html", 
        "<div class=\"se-toolbar-menu-content--wrapper\"><div class=\"se-toolbar-menu-content__header\"><div class=\"se-toolbar-menu-content__header-title\" translate=\"se.cms.actionitem.page.versions\"></div><button class=\"se-versions-panel__manage-btn fd-button fd-button--compact\" *ngIf=\"showManageButton\" (click)=\"switchToVersioningMode()\" translate=\"se.cms.toolbaritem.versioning.manageversions.name\"></button></div><div class=\"se-versions-toolbar-menu-content__body\" [ngClass]=\"{ 'se-versions-toolbar-menu-content__body--narrow': showManageButton }\"><se-versions-search [versionsFoundCount]=\"versionsFound\" [showSearchControls]=\"pageHasVersions()\" (searchTermChange)=\"onSearchTermChanged($event)\"></se-versions-search><div><se-infinite-scrolling class=\"se-versions-panel__infinite-scroll\" *ngIf=\"pageHasVersionsOrIsLoading()\" [pageSize]=\"10\" [mask]=\"searchTerm\" [fetchPage]=\"fetchPageOfVersions\" (itemsChange)=\"onVersionItemsLoaded($event)\"><div *ngFor=\"let item of versionItems; let isLast = last\"><se-version-item [ngClass]=\"{ 'se-version-item--last': isLast }\" [pageVersion]=\"item\"></se-version-item></div></se-infinite-scrolling><div class=\"se-versions-panel__empty-list\" *ngIf=\"!pageHasVersionsOrIsLoading()\"><img src=\"static-resources/images/emptyVersions.svg\" alt=\"no versions\"/> <span class=\"se-versions-panel__no-versions-message\" translate=\"se.cms.toolbaritem.versioning.noversionsfound\"></span> <a class=\"se-versions-panel__manage-link fd-link\" *ngIf=\"showManageLink\" (click)=\"switchToVersioningMode()\" translate=\"se.cms.toolbaritem.versioning.manageversionslink.name\"></a></div></div></div></div>"
    );
     
    $templateCache.put(
        "PageApprovalSelectorComponent.html", 
        "<fd-popover *ngIf=\"showDropdown\" [triggers]=\"[]\" [closeOnOutsideClick]=\"false\" [isOpen]=\"isOpen\" [placement]=\"'bottom-end'\"><fd-popover-control><button (click)=\"onClickDropdown()\" class=\"se-page-approval-selector__toggle-btn fd-button--light sap-icon--navigation-down-arrow\"></button></fd-popover-control><fd-popover-body><div *ngIf=\"showApprovalInfo\" class=\"se-page-approval-info\">{{ approvalInfo }}</div><fd-menu *ngIf=\"!showApprovalInfo\"><ul fd-menu-list class=\"se-dropdown-menu__list se-page-approval-selector-list\"><se-dropdown-menu-item *ngFor=\"let dropdownItem of pageApprovalOptions$ | async\" [dropdownItem]=\"dropdownItem\"></se-dropdown-menu-item></ul></fd-menu></fd-popover-body></fd-popover>"
    );
     
    $templateCache.put(
        "PageDisplayStatusComponent.html", 
        "<ng-container *ngIf=\"showLastSyncTime; else pageStatus\"><se-tooltip [triggers]=\"['click']\" [placement]=\"'left'\" [isChevronVisible]=\"true\"><ng-container se-tooltip-trigger *ngTemplateOutlet=\"pageStatus\"></ng-container><div se-tooltip-body class=\"popover-tooltip\"><ng-container *ngIf=\"hasBeenSynchedBefore(); else notPublished\"><span [translate]=\"'se.cms.page.displaystatus.lastpublished.date'\"></span> <span>&ngsp;{{ lastSynchedDate | date: 'M/d/yy h:mm a' }}</span></ng-container><ng-template #notPublished><span [translate]=\"'se.cms.page.displaystatus.not.published'\"></span></ng-template></div></se-tooltip></ng-container><ng-template #pageStatus><se-page-status [uuid]=\"page?.uuid\" [displayStatus]=\"page?.displayStatus\"></se-page-status></ng-template>"
    );
     
    $templateCache.put(
        "PageInWorkflowNotificationComponent.html", 
        "<div><span translate=\"se.cms.workflow.page.in.workflow\"></span></div>"
    );
     
    $templateCache.put(
        "PageWorkflowMenuComponent.html", 
        "<div *ngIf=\"isReady\"><div *ngIf=\"!pageHasWorkflow && isWorkflowEnabled\"><ng-container *seHasOperationPermission=\"'se.start.page.workflow'\"><button id=\"smartEditPerspectiveToolbar_option_se.cms.startWorkflow_btn\" class=\"btn toolbar-action--button\" type=\"button\" (click)=\"startWorkflow()\" aria-expanded=\"false\"><span id=\"smartEditPerspectiveToolbar_option_se.cms.startWorkflow_btn_lbl\" class=\"toolbar-action-button__txt\" translate=\"se.cms.workflow.toolbar.start.workflow\"></span></button></ng-container></div><div *seHasOperationPermission=\"'se.view.page.workflowMenu'\"><fd-popover *ngIf=\"pageHasWorkflow\" class=\"toolbar-action\" [closeOnOutsideClick]=\"true\" [isOpen]=\"actionItem.isOpen\" (isOpenChange)=\"onDropdownToggle($event)\"><fd-popover-control><button type=\"button\" class=\"page-tasks-btn toolbar-action--button\" [attr.aria-expanded]=\"actionItem.isOpen\"><span class=\"page-tasks-btn__icon sap-icon--workflow-tasks\"></span> <span class=\"page-tasks-btn__label\" translate=\"se.cms.workflow.toolbar.view.workflow.menu\"></span></button></fd-popover-control><fd-popover-body><div *ngIf=\"actionItem.isOpen\" class=\"toolbar-action--include se-page-workflow-menu\"><div class=\"se-page-workflow-menu__header\"><div class=\"se-page-workflow-menu__header-text\" translate=\"se.cms.workflow.toolbar.view.workflow.menu\"></div><div class=\"se-page-workflow-menu__header-menu\"><se-workflow-item-menu [workflowInfo]=\"workflow\"></se-workflow-item-menu></div></div><div class=\"se-version-toolbar-menu-content__body\"><div class=\"se-page-workflow-menu-tabs\"><se-tabs *ngIf=\"areTabsReady; else spinner\" [tabsList]=\"tabsList\" [model]=\"tabsData\" [numTabsDisplayed]=\"2\"></se-tabs><ng-template #spinner><se-spinner [isSpinning]=\"true\"></se-spinner></ng-template></div></div></div></fd-popover-body></fd-popover></div></div>"
    );
     
    $templateCache.put(
        "WorkflowInboxComponent.html", 
        "<fd-popover class=\"toolbar-action se-workflow-inbox-container dropdown\" [class.open]=\"actionItem.isOpen\" [(isOpen)]=\"actionItem.isOpen\" (isOpenChange)=\"onDropdownToggle(isOpen)\" [closeOnOutsideClick]=\"true\" [triggers]=\"['click']\" [placement]=\"'bottom-' + actionItem.dropdownPosition\"><fd-popover-control class=\"se-workflow-inbox-toggle-control\"><button type=\"button\" class=\"se-workflow-inbox-toggle toolbar-action--button--compact\" [attr.aria-pressed]=\"actionItem.isOpen\"><span class=\"se-toolbar-actions__icon sap-icon--task\"></span><se-workflow-inbox-badge></se-workflow-inbox-badge></button></fd-popover-control><fd-popover-body><div [ngClass]=\"{                'se-toolbar__dropdown--right': actionItem.dropdownPosition === 'right',                'se-toolbar__dropdown--center': actionItem.dropdownPosition === 'center',                'se-toolbar__dropdown--left': actionItem.dropdownPosition === 'left'            }\" class=\"toolbar-action--include--compact\"><div *ngIf=\"actionItem.isOpen\" class=\"se-workflow-inbox\"><div class=\"se-workflow-inbox\"><div class=\"se-workflow-inbox-header\"><div class=\"se-workflow-inbox-header__title\" [translate]=\"'se.cms.workflow.toolbar.inbox'\"></div></div><div class=\"se-workflow-inbox-tasks se-cms-dev-workflow-inbox-tasks fd-panel__body\"><div *ngIf=\"!tasksNotReady && totalNumberOfTasks === 0\" class=\"se-workflow-inbox-tasks__no-tasks\"><img src=\"static-resources/images/Inbox.svg\" alt=\"empty-inbox\"/> <span class=\"se-workflow-inbox__empty-inbox-message\" [translate]=\"'se.cms.workflow.toolbar.inbox.emptyinbox.message'\"></span> <span class=\"se-workflow-inbox__empty-inbox-message-alt\" [translate]=\"'se.cms.workflow.toolbar.inbox.emptyinbox.message.alt'\"></span></div><se-infinite-scrolling class=\"se-version-panel__infinite-scroll se-infinite-scrolling--narrowed\" [pageSize]=\"pageSize\" [fetchPage]=\"fetchPageOfInboxTasks\" (itemsChange)=\"onInboxTasksLoaded($event)\"><div *ngFor=\"let task of workflowTasks; let i = index; let last = last; trackBy: trackByIndex\" class=\"se-workflow-inbox-task se-cms-dev-workflow-inbox-task\"><se-workflow-inbox-task id=\"workflow-inbox-task-{{i}}\" [class.se-workflow-inbox-task-last]=\"last\" [task]=\"task\"></se-workflow-inbox-task></div></se-infinite-scrolling></div></div></div></div></fd-popover-body></fd-popover>"
    );
     
    $templateCache.put(
        "WorkflowInboxBadgeComponent.html", 
        "<ng-container *ngIf=\"inboxCount$ | async as count\"><div *ngIf=\"count > 0\" aria-label=\"Notifications\"><div class=\"fd-counter fd-counter--notification se-inbox-badge\" aria-label=\"Unread count\">{{ stringifyCount(count) }}</div></div></ng-container>"
    );
     
    $templateCache.put(
        "WorkflowInboxMultipleTasksAnnouncementComponent.html", 
        "<div (click)=\"onClick($event)\" class=\"se-announcement__message--multi\">{{ 'se.cms.workflow.tasks.announcement' | translate: count }}</div>"
    );
     
    $templateCache.put(
        "WorkflowInboxSingleTaskAnnouncementComponent.html", 
        "<div (click)=\"onClick($event)\"><div class=\"se-announcement__title\">{{ task.action.name | seL10n | async }}</div><div class=\"se-announcement__message\">{{ task.attachments[0].catalogName | seL10n | async }} | {{ task.attachments[0].pageName }}</div><div class=\"se-announcement__time-stamp\">{{ startedAgo }}</div></div>"
    );
     
    $templateCache.put(
        "WorkflowInboxTaskComponent.html", 
        "<div class=\"se-workflow-inbox-task-header\"><a href=\"#\" (click)=\"onClick($event)\">{{ taskName | async }}</a></div><div class=\"se-workflow-inbox-task-desc\">{{ taskDescription | async }}</div><div class=\"se-workflow-inbox-task-body\">{{ getTaskCreatedAgo() }}</div>"
    );
     
    $templateCache.put(
        "WorkflowItemMenuComponent.html", 
        "<se-popup-overlay class=\"popup-anchor\" [ngClass]=\"{ 'popup-anchor--open': isMenuOpen }\" [popupOverlay]=\"popupConfig\" [popupOverlayTrigger]=\"isMenuOpen\" (popupOverlayOnHide)=\"hideMenu()\"><span *ngIf=\"menuItems.length > 0\" (click)=\"toggleMenu()\" class=\"workflow-item-menu__toggle-btn sap-icon--overflow\"></span><div se-popup-overlay-body><div class=\"workflow-item-menu\"><div class=\"workflow-item-menu__item\" *ngFor=\"let dropdownItem of menuItems\"><ng-container class=\"container\" [ngSwitch]=\"dropdownItem.i18nKey\"><div *ngSwitchCase=\"'se.cms.actionitem.page.workflow.description'\" class=\"workflow-description\"><div class=\"se-dropdown-item--label\"><div class=\"workflow-description__label fd-has-type-1 fd-has-margin-bottom-tiny\"><div [translate]=\"dropdownItem.i18nKey\"></div><div *seHasOperationPermission=\"'se.edit.workflow.workflowMenu'\"><a title=\"Edit\" class=\"workflow-description__edit-btn sap-icon--edit fd-has-float-right\" (click)=\"editDescription()\"></a></div></div><div *ngIf=\"workflowInfo.description; else noDescription\" class=\"workflow-description__text\">{{ workflowInfo.description }}</div><ng-template #noDescription><div translate=\"se.cms.actionitem.page.workflow.no.description\"></div></ng-template></div></div><div *ngSwitchCase=\"'se.cms.actionitem.page.workflow.cancel'\" class=\"workflow-cancel-btn fd-has-color-status-3\" [translate]=\"dropdownItem.i18nKey\" (click)=\"cancelWorkflow()\"></div></ng-container></div></div></div></se-popup-overlay>"
    );
     
    $templateCache.put(
        "SubTypeSelectorComponent.html", 
        "<ul class=\"se-sub-type__selector fd-menu__list\"><li class=\"cms-sub-type__selector-link fd-menu__item\" *ngFor=\"let subType of subTypes\" (click)=\"select(subType)\" [translate]=\"subType.label\"></li></ul>"
    );
     
    $templateCache.put(
        "PageRestrictionsEditorComponent.html", 
        "<se-page-restrictions-info-message *ngIf=\"page.restrictions?.length > 1\"></se-page-restrictions-info-message><se-restrictions-editor [editable]=\"isEditable\" [getRestrictionTypes]=\"getRestrictionTypes\" [getSupportedRestrictionTypes]=\"getSupportedRestrictionTypes\" [item]=\"page\" [restrictionUuids]=\"page.restrictions\" [removeValidationMessages]=\"onRemoveValidationMessages\" (onRestrictionsChange)=\"onRestrictionsChange($event)\"></se-restrictions-editor>"
    );
     
    $templateCache.put(
        "PageRestrictionsInfoMessageComponent.html", 
        "<se-message [type]=\"'info'\" class=\"se-restrictions-info__message\"><ng-container se-message-title>{{ 'se.cms.restrictions.editor.ymessage.title' | translate }}</ng-container><ng-container se-message-description>{{ 'se.cms.restrictions.editor.ymessage.description' | translate }}</ng-container></se-message>"
    );
     
    $templateCache.put(
        "CatalogAwareSelectorComponent.html", 
        "<div *ngIf=\"selectedItemListIsEmpty()\"><button type=\"button\" id=\"catalog-aware-selector-add-item\" class=\"fd-button fd-button--compact se-catalog-aware-selector__add-item-btn\" *ngIf=\"editable\" (click)=\"openItemSelectorPanel()\"><span translate=\"se.cms.catalogaware.newbutton.title\" [translateParams]=\"{ catalogItemType: catalogItemTypeI18nKey | translate }\" class=\"se-catalog-aware-selector__add-item-btn-text\"></span></button></div><div *ngIf=\"!selectedItemListIsEmpty()\" class=\"se-catalog-aware-selector__content\"><div class=\"se-catalog-aware-selector__add-more-btn-wrapper\" *ngIf=\"editable\"><button type=\"button\" class=\"fd-button--light\" translate=\"se.cms.catalogaware.list.addmore\" (click)=\"openItemSelectorPanel()\"></button></div><se-editable-list [id]=\"editableListId\" [itemComponent]=\"nodeComponent\" [(items)]=\"itemList\" [onChange]=\"onListChange\" [editable]=\"editable\" [(refresh)]=\"refreshItemListWidget\" class=\"se-catalog-aware-selector__list\"></se-editable-list></div><se-item-selector-panel [itemComponent]=\"itemComponent\" [getCatalogs]=\"getCatalogs\" [itemsFetchStrategy]=\"itemsFetchStrategy\" [catalogItemTypeI18nKey]=\"catalogItemTypeI18nKey\" (onSaveChanges)=\"onItemSelectorPanelSaveChanges($event)\"></se-item-selector-panel>"
    );
     
    $templateCache.put(
        "ItemSelectorPanelComponent.html", 
        "<se-slider-panel [sliderPanelConfiguration]=\"panelConfig\" [(sliderPanelHide)]=\"hidePanel\" [(sliderPanelShow)]=\"showPanel\" class=\"se-item-selector-panel\"><div *ngIf=\"catalogs.length > 0\"><div *ngIf=\"catalogs.length > 1\" class=\"se-item-selector-panel__selector\"><label class=\"se-control-label\" translate=\"se.cms.catalogaware.panel.catalogs.label\"></label><se-select id=\"se-catalog-selector-dropdown\" [(model)]=\"catalogInfo.catalogId\" [fetchStrategy]=\"catalogSelectorFetchStrategy\" [onChange]=\"onCatalogSelectorChange\"></se-select><label>{{ catalogInfo.name | seL10n | async }}</label></div><div class=\"se-item-selector-panel__selector\"><label class=\"se-control-label\" translate=\"se.cms.catalogaware.panel.catalogsversion.label\"></label><se-select id=\"se-catalog-version-selector-dropdown\" [(model)]=\"catalogInfo.catalogVersion\" [fetchStrategy]=\"catalogVersionSelectorFetchStrategy\" [onChange]=\"onCatalogVersionSelectorChange\" [searchEnabled]=\"false\" [(reset)]=\"resetCatalogVersionSelector\"></se-select></div><div class=\"se-item-selector-panel__selector\" *ngIf=\"catalogInfo.catalogVersion\"><label class=\"se-control-label\" [translate]=\"catalogItemTypeI18nKey\"></label><se-select id=\"se-items-selector-dropdown\" [multiSelect]=\"true\" [controls]=\"true\" [(model)]=\"internalItemsSelected\" [onChange]=\"onItemsSelectorChange\" [fetchStrategy]=\"itemsSelectorFetchStrategy\" [(reset)]=\"resetItemsListSelector\" [itemComponent]=\"itemComponent\" [isReadOnly]=\"!isItemSelectorEnabled()\"></se-select></div></div></se-slider-panel>"
    );
     
    $templateCache.put(
        "MultiCategorySelectorComponent.html", 
        "<se-catalog-aware-selector [id]=\"id\" [selectedItemIds]=\"selectedItemIds\" (selectedItemIdsChange)=\"onSelectedItemIdsChange($event)\" [getCatalogs]=\"getCatalogs\" [itemComponent]=\"categorySelectorItemComponent\" [nodeComponent]=\"categoryNodeComponent\" [itemsFetchStrategy]=\"itemsFetchStrategy\" [catalogItemTypeI18nKey]=\"'se.cms.catalogaware.catalogitemtype.category'\" [editable]=\"editable\"></se-catalog-aware-selector>"
    );
     
    $templateCache.put(
        "MultiProductSelectorComponent.html", 
        "<se-catalog-aware-selector [id]=\"id\" [selectedItemIds]=\"selectedItemIds\" (selectedItemIdsChange)=\"onSelectedItemIdsChange($event)\" [getCatalogs]=\"getCatalogs\" [itemComponent]=\"productSelectorItemComponent\" [nodeComponent]=\"productNodeComponent\" [itemsFetchStrategy]=\"itemsFetchStrategy\" [catalogItemTypeI18nKey]=\"'se.cms.catalogaware.catalogitemtype.product'\" [editable]=\"editable\"></se-catalog-aware-selector>"
    );
     
    $templateCache.put(
        "MediaComponent.html", 
        "<div class=\"se-media\"><se-media-selector *ngIf=\"!image\" [id]=\"mediaSelectorId\" [isDisabled]=\"isFieldDisabled\" [mediaId]=\"mediaIdByLang[lang]\" [mimeType]=\"field.allowMediaType\" (mediaIdChange)=\"onMediaIdChange($event)\"></se-media-selector><se-media-file-selector *ngIf=\"canShowFileSelector()\" [labelI18nKey]=\"'se.upload.image.to.library'\" [acceptedFileTypes]=\"acceptedFileTypes\" [selectionMode]=\"'upload'\" [disabled]=\"isFieldDisabled\" (onFileSelect)=\"onFileSelect($event)\"></se-media-file-selector><se-media-upload-form *ngIf=\"image\" class=\"se-media-upload-form-wrapper\" [image]=\"image\" [allowMediaType]=\"field.allowMediaType\" [maxUploadFileSize]=\"maxUploadFileSize\" (onCancel)=\"resetImage()\" (onSelect)=\"onFileSelect($event)\" (onUploadSuccess)=\"onMediaUploaded($event)\"></se-media-upload-form><se-message *ngIf=\"previewMessage\" [type]=\"'warning'\"><ng-container se-message-description>{{ 'se.upload.video.cant.preview' | translate }}</ng-container></se-message><se-media-errors *ngIf=\"fileErrors.length > 0\" [errors]=\"fileErrors\" [maxUploadFileSize]=\"maxUploadFileSize\"></se-media-errors></div>"
    );
     
    $templateCache.put(
        "MediaActionLabelComponent.html", 
        "<span class=\"se-media-action-label\" [ngClass]=\"{ 'se-media-action-label--disabled': state === 'disabled' }\" [translate]=\"i18nKey\"></span>"
    );
     
    $templateCache.put(
        "MediaAdvancedPropertiesComponent.html", 
        "<se-tooltip [appendTo]=\"'body'\" [placement]=\"'bottom'\" [isChevronVisible]=\"true\" [triggers]=\"['click']\" class=\"se-media-advanced-info\"><span se-tooltip-trigger class=\"se-media-advanced-info__trigger\"><span class=\"sap-icon--message-information se-media__action-icon se-media__action-icon--basic\" [title]=\"i18nKeys.INFORMATION | translate\"></span><se-media-action-label [i18nKey]=\"i18nKeys.INFORMATION\"></se-media-action-label></span><div se-tooltip-body><div class=\"se-media-advanced-info-body\"><div class=\"se-media-advanced-info-row advanced-information-description\" *ngIf=\"description\"><div class=\"se-media-advanced-info-row__label se-control-label\" [translate]=\"i18nKeys.DESCRIPTION\"></div><div class=\"se-media-advanced-info-row__description\">{{ description }}</div></div><div class=\"se-media-advanced-info-row advanced-information-code\"><div class=\"se-media-advanced-info-row__label se-control-label\" [translate]=\"i18nKeys.CODE\"></div><div class=\"se-media-advanced-info-row__description\">{{ code }}</div></div><div class=\"se-media-advanced-info-row advanced-information-alt-text\" *ngIf=\"altText\"><div class=\"se-media-advanced-info-row__label se-control-label\" [translate]=\"i18nKeys.ALT_TEXT\"></div><div class=\"se-media-advanced-info-row__description\">{{ altText }}</div></div></div></div></se-tooltip>"
    );
     
    $templateCache.put(
        "MediaContainerComponent.html", 
        "<div *ngIf=\"hasReadPermissionOnMediaRelatedTypes && advancedMediaContainerManagementEnabled\"><se-media-container-selector [eventNameAffix]=\"selectorEventNameAffix\" [isAdvancedCloning]=\"isAdvancedCloning()\" [initialName]=\"initialMediaContainerName\" [name]=\"getMediaContainerName()\" [isEditable]=\"field.editable\" (nameChange)=\"onMediaContainerNameChange($event)\" (onCreate)=\"onMediaContainerCreate($event)\" (onRemove)=\"onMediaContainerRemove()\" (onSelect)=\"setMediaContainer($event)\" (onCreationInProgressChange)=\"onMediaContainerCreationInProgressChange($event)\"></se-media-container-selector></div><div class=\"se-media-container-field\" *ngIf=\"canShowMediaFormatWithUploadForm()\"><div class=\"se-media-container-field__media-list\"><se-media-format class=\"se-media-container-cell\" *ngFor=\"let format of field.options\" [ngClass]=\"getMediaContainerCellClassName(format.id)\" [errorMessages]=\"field.messages\" [isEditable]=\"field.editable\" [isUnderEdit]=\"isMediaFormatUnderEdit(format.id)\" [isFieldDisabled]=\"isFieldDisabled()\" [mediaUuid]=\"model[lang]?.medias[format.id]\" [mediaFormat]=\"format.id\" [mediaLabel]=\"format.label\" [allowMediaType]=\"field.allowMediaType\" (onFileSelect)=\"onFileSelect($event, format.id)\" (onDelete)=\"removeMediaByFormat(format.id)\"></se-media-format></div><se-media-upload-form *ngIf=\"image\" class=\"se-media-upload-form-wrapper se-media-upload-form-wrapper--spaced\" [image]=\"image.file\" [allowMediaType]=\"field.allowMediaType\" [maxUploadFileSize]=\"maxUploadFileSize\" (onCancel)=\"resetImage()\" (onSelect)=\"onFileSelect($event)\" (onUploadSuccess)=\"onFileUploadSuccess($event, image.format)\"></se-media-upload-form><se-media-errors [errors]=\"fileValidationErrors\" [maxUploadFileSize]=\"maxUploadFileSize\"></se-media-errors></div><div *ngIf=\"!hasReadPermissionOnMediaRelatedTypes\"><span translate=\"se.cms.media.typepermissions.error\" [translateParams]=\"{ containedTypes: field.containedTypes }\"></span></div>"
    );
     
    $templateCache.put(
        "MediaErrorsComponent.html", 
        "<div class=\"se-media-error field-errors\"><div *ngFor=\"let error of errors\">{{ error.message | translate: { sizeLimitationOfFile: maxUploadFileSize } }}</div></div>"
    );
     
    $templateCache.put(
        "MediaFileSelectorComponent.html", 
        "<div class=\"se-file-selector\" [ngClass]=\"customClass\"><label *ngIf=\"!disabled\" class=\"se-button se-button--text\" [ngClass]=\"{ 'se-button--disabled': disabled,                     'se-file-selector__custombtn': customComponent,                      'se-file-selector__btn': !customComponent }\"><ng-container *ngIf=\"customComponent\"><ng-container *ngComponentOutlet=\"customComponent.component; injector: customComponent.injector\"></ng-container></ng-container><span class=\"sap-icon--share se-media__action-icon\" [ngClass]=\"{        'sap-icon--share': isReplaceMode(),        'sap-icon--upload': !isReplaceMode()    }\"></span> <span class=\"se-file-selector__label\">{{ labelI18nKey | translate }}</span><ng-container *ngIf=\"!customComponent\"><input type=\"file\" class=\"hide se-file-selector__input\" [accept]=\"buildAcceptedFileTypesList()\" (change)=\"onSelect($event.target.files)\"/></ng-container></label></div>"
    );
     
    $templateCache.put(
        "MediaFormatComponent.html", 
        "<div class=\"se-media-format\" [ngClass]=\"mediaFormat\"><div *ngIf=\"mediaLabel\" class=\"se-media-format__screen-type\" [translate]=\"mediaFormatI18nKey\"></div><se-media-format-uploaded *ngIf=\"isMediaPreviewEnabled()\" [media]=\"media\" [replaceLabelI18nKey]=\"mediaSelectorI18nKeys.REPLACE\" [acceptedFileTypes]=\"acceptedFileTypes\" [isFieldDisabled]=\"isFieldDisabled\" (onFileSelect)=\"onFileSelectorFileSelect($event)\" (onDelete)=\"onRemoveButtonClick()\"></se-media-format-uploaded><div class=\"se-media--absent\" *ngIf=\"isMediaAbsent()\"><se-media-file-selector *ngIf=\"isEditable\" [selectionMode]=\"'upload'\" [labelI18nKey]=\"mediaSelectorI18nKeys.UPLOAD\" [acceptedFileTypes]=\"acceptedFileTypes\" [customClass]=\"isFieldDisabled ? 'file-selector-disabled' : ''\" [disabled]=\"isFieldDisabled\" (onFileSelect)=\"onFileSelectorFileSelect($event)\"></se-media-file-selector><se-media-file-selector *ngIf=\"!isEditable\" [selectionMode]=\"'upload'\" [labelI18nKey]=\"mediaSelectorI18nKeys.UPLOAD\" [acceptedFileTypes]=\"acceptedFileTypes\" [customClass]=\"!isEditable ? 'file-selector-disabled' : ''\" [disabled]=\"!isEditable\" (onFileSelect)=\"onFileSelectorFileSelect($event)\"></se-media-file-selector></div><div *ngIf=\"isUnderEdit\" class=\"se-media--edit-wrapper\"><se-media-file-selector class=\"se-media--edit\" [labelI18nKey]=\"mediaSelectorI18nKeys.UPLOAD\" [acceptedFileTypes]=\"acceptedFileTypes\" [customClass]=\"'file-selector-disabled'\" [disabled]=\"true\" (onFileSelect)=\"onFileSelectorFileSelect($event)\"></se-media-file-selector><span class=\"se-media-preview--edit\" [translate]=\"mediaSelectorI18nKeys.UNDER_EDIT\"></span></div><ng-container *ngIf=\"!isUnderEdit\"><div class=\"error-input se-media-format__error\" *ngFor=\"let error of getErrors()\"><span>{{ error }}</span></div></ng-container></div>"
    );
     
    $templateCache.put(
        "MediaPreviewComponent.html", 
        "<se-tooltip [appendTo]=\"'body'\" [placement]=\"'bottom'\" [isChevronVisible]=\"true\" [triggers]=\"['click']\"><span se-tooltip-trigger><div class=\"sap-icon--search se-media-preview__icon\"></div></span><div se-tooltip-body><img class=\"se-media-preview__image\" [src]=\"imageUrl\"/></div></se-tooltip>"
    );
     
    $templateCache.put(
        "MediaRemoveButtonComponent.html", 
        "<button type=\"button\" class=\"se-media-action-btn se-media-remove-btn\" [disabled]=\"isDisabled\" (click)=\"clickHandler.emit($event)\"><span class=\"se-media__action-icon se-media__action-icon--delete sap-icon--delete\"></span> <span class=\"se-media-remove-btn-txt\" [ngClass]=\"{ 'se-media-remove-btn-txt--disabled': isDisabled }\" translate=\"se.media.format.remove\"></span></button>"
    );
     
    $templateCache.put(
        "MediaSelectorComponent.html", 
        "<div class=\"media-selector\"><se-select [id]=\"id\" [(model)]=\"mediaId\" (modelChange)=\"onMediaIdChange($event)\" [fetchStrategy]=\"fetchStrategy\" [isReadOnly]=\"isDisabled\" [itemComponent]=\"mediaPrinterComponent\"></se-select></div>"
    );
     
    $templateCache.put(
        "MediaUploadFormComponent.html", 
        "<div class=\"se-media-upload-form\"><div class=\"se-media-upload-form__header\"><div class=\"se-media-upload-form__header-content\"><div class=\"se-media-upload-form__header-title\" translate=\"se.upload.image.to.folder\"></div><se-select id=\"se-media-upload-form__header-folder\" class=\"se-media-upload-form__header-folder\" [ngClass]=\"{ 'is-invalid': hasError() }\" [multiSelect]=\"false\" [controls]=\"false\" [(model)]=\"folderSelected\" (modelChange)=\"folderSelectedChanged($event)\" [fetchStrategy]=\"folderFetchStrategy\" [placeholder]=\"folderSelected\"></se-select><div class=\"se-media-upload-form__header-actions\"><button type=\"button\" class=\"fd-button--light se-media-upload-btn__cancel fd-button--compact\" translate=\"se.upload.image.cancel\" (click)=\"cancel()\"></button> <button type=\"button\" class=\"fd-button se-media-upload-btn__submit fd-button--compact\" translate=\"se.upload.image.submit\" (click)=\"uploadMedia()\"></button></div></div><div class=\"se-media-upload-form__header-error\"><span class=\"upload-field-error fd-form__message fd-form__message--error\" *ngFor=\"let error of folderErrors\">{{ error | translate }}</span></div></div><div class=\"se-media-upload-form__replace-file\"><div class=\"se-media-upload-form__file-name\">{{ image.name }}</div><se-media-file-selector [labelI18nKey]=\"'se.upload.image.replace'\" [acceptedFileTypes]=\"acceptedFileTypes\" (onFileSelect)=\"onFileSelect($event)\"></se-media-file-selector></div><form class=\"se-media-upload-form__file-info\"><se-media-upload-field [fieldName]=\"'code'\" [fieldValue]=\"imageParams?.code\" [fieldErrors]=\"getErrorsForFieldByCode('code')\" [isRequired]=\"true\" [labelI18nKey]=\"'se.uploaded.image.code'\" (fieldValueChange)=\"onChangeFieldValue($event, 'code')\"></se-media-upload-field><se-media-upload-field [fieldName]=\"'description'\" [fieldValue]=\"imageParams?.description\" [fieldErrors]=\"getErrorsForFieldByCode('description')\" [isRequired]=\"true\" [labelI18nKey]=\"'se.uploaded.image.description'\" (fieldValueChange)=\"onChangeFieldValue($event, 'description')\"></se-media-upload-field><se-media-upload-field [fieldName]=\"'alt-text'\" [fieldValue]=\"imageParams?.altText\" [fieldErrors]=\"getErrorsForFieldByCode('altText')\" [isRequired]=\"true\" [labelI18nKey]=\"'se.uploaded.image.alt.text'\" (fieldValueChange)=\"onChangeFieldValue($event, 'altText')\"></se-media-upload-field></form><se-spinner [isSpinning]=\"isUploading\"></se-spinner></div>"
    );
     
    $templateCache.put(
        "BreadcrumbComponent.html", 
        "<div class=\"se-breadcrumb\"><div *ngFor=\"let node of breadcrumb; index as idx; last as isLast\" class=\"se-breadcrumb__node\"><div class=\"se-breadcrumb__info\" [ngClass]=\"{'se-breadcrumb__info--last': isLast}\"><span class=\"se-breadcrumb__info--level\">{{ node.formattedLevel | translate: node }}</span> <span class=\"se-breadcrumb__info--name\">{{ node.name }}</span></div><div class=\"se-breadcrumb__divider\" *ngIf=\"idx < breadcrumb.length - 1\"><span class=\"sap-icon--navigation-right-arrow\"></span></div></div></div>"
    );
     
    $templateCache.put(
        "NavigationNodePickerComponent.html", 
        "<div class=\"categoryTable\"><div class=\"tablehead clearfix hidden-xs se-navigation-editor-tree__head\"><div translate=\"se.ytree.template.header.name\" class=\"se-navigation-editor-tree__name col-md-offset-1 col-sm-5\"></div></div><se-tree [nodeUri]=\"nodeURI\" [rootNodeUid]=\"rootNodeUid\" [nodeComponent]=\"nodePickerRenderComponent\" [removeDefaultTemplate]=\"removeDefaultTemplate\" [nodeActions]=\"actions\"></se-tree></div>"
    );
     
    $templateCache.put(
        "NavigationNodePickerRenderComponent.html", 
        "<div class=\"se-tree-node__name col-xs-6\" [title]=\"node.name | seL10n | async\"><span>{{ node.name | seL10n | async }}</span></div><div class=\"col-sm-4 pull-right tree-node se-navigation-picker-renderer\" (click)=\"pick(node)\" *ngIf=\"isEditable()\"><a translate=\"se.cms.navigationcomponent.management.node.selection.select.action\" class=\"btn btn-link se-navigation-picker-renderer__btn\"></a></div>"
    );
     
    $templateCache.put(
        "NavigationNodeSelectorComponent.html", 
        "<div *ngIf=\"isReady\"><div *ngIf=\"cmsItem[qualifier]\" class=\"se-navigation-mode\"><div class=\"se-navigation__node\"><se-breadcrumb class=\"se-navigation__node-breadcrumb\" [nodeUuid]=\"cmsItem[qualifier]\" [uriContext]=\"uriContext\"></se-breadcrumb><div class=\"se-navigation__node-button\"><button class=\"btn btn-link btn-block se-navigation__button\" (click)=\"remove($event)\" [disabled]=\"!field.editable\" translate=\"se.cms.navigationcomponent.management.node.selection.remove.action\"></button></div></div><se-navigation-editor-tree [uriContext]=\"uriContext\" [readOnly]=\"true\" [rootNodeUid]=\"nodeUid\"></se-navigation-editor-tree></div><div *ngIf=\"!cmsItem[qualifier]\"><label translate=\"se.cms.navigationcomponent.management.node.selection.invite.action\"></label><se-navigation-node-picker [uriContext]=\"uriContext\" [editable]=\"field.editable\"></se-navigation-node-picker></div></div>"
    );
     
    $templateCache.put(
        "NewPageDisplayConditionComponent.html", 
        "<div *ngIf=\"isReady\"><div class=\"form-group\"><label for=\"page-condition-selector-id\" class=\"se-control-label\" translate=\"se.cms.page.condition.selection.label\"></label><se-select id=\"page-condition-selector-id\" [model]=\"conditionSelected.label\" (modelChange)=\"onConditionChange($event)\" [fetchStrategy]=\"conditionSelectorFetchStrategy\" [onChange]=\"onDataChange\" [searchEnabled]=\"false\"></se-select><span class=\"se-form-help-message\"><span [translate]=\"conditionSelected.description\"></span></span></div><div *ngIf=\"showPrimarySelector()\" class=\"form-group\"><label for=\"page-condition-primary-selector-id\" class=\"se-control-label\" translate=\"se.cms.page.condition.primary.association.label\"></label><se-select id=\"page-condition-primary-selector-id\" [model]=\"primarySelectedModel\" (modelChange)=\"primarySelectedModelOnChange($event)\" [fetchStrategy]=\"primaryPageChoicesFetchStrategy\" [onChange]=\"onDataChange\"></se-select><span *ngIf=\"primarySelected?.label\" class=\"se-form-help-message\"><span>{{ 'se.cms.page.label.label' | translate }}: {{ primarySelected.label }}</span></span></div><div *ngIf=\"showHomePageWidget()\"><div class=\"fd-form__item\"><input type=\"checkbox\" id=\"set-homepage-checkbox\" class=\"se-component-item--details se-component-homepage__checkbox-input fd-form__control\" name=\"clone-on-drop\" (ngModelChange)=\"onHomePageChange($event)\" [ngModel]=\"homepage\"/> <label class=\"se-control-label se-component-homepage--label fd-form__label\" for=\"set-homepage-checkbox\" translate=\"se.cms.display.conditions.homepage.set\"></label></div><label class=\"se-control-label se-component-homepage--label\" for=\"set-homepage-checkbox\" *ngIf=\"showReplaceLabel\">{{ \"se.cms.display.conditions.homepage.replace\" | translate: { currentHomepage: currentHomePageName } }}</label></div></div>"
    );
     
    $templateCache.put(
        "SelectPageTemplateComponent.html", 
        "<div class=\"se-page-type-step-template\"><div class=\"se-add-page__sub-header\"><div class=\"se-add-page__sub-header-title\">{{ 'se.cms.addpagewizard.pagetemplate.description' | translate }}</div><div class=\"se-input-group se-page-type-step-template-list-search\"><input type=\"text\" class=\"se-input-group__input-area ySEPage-list-search-input\" placeholder=\"{{ 'se.cms.pagewizard.templatestep.searchplaceholder' | translate }}\" [ngModel]=\"searchString\" (ngModelChange)=\"onSearchChange($event)\" name=\"query\"/> <span class=\"sap-icon--search se-input-group__addon\"></span><div *ngIf=\"searchString\" class=\"se-input-group__addon se-input-group__clear-btn\" (click)=\"clearSearch()\"><span class=\"sap-icon--decline\"></span></div></div></div><div class=\"se-add-page__list fd-menu\" *ngIf=\"pageTemplates.length > 0\"><div *ngFor=\"let template of filteredPageTemplates\" [ngClass]=\"{ 'is-selected': isSelected(template)}\" (click)=\"templateSelected(template)\" class=\"se-add-page__item se-add-page__item--page-template fd-menu__item\"><div class=\"se-add-page__item-title\">{{ template.name }}</div></div></div></div>"
    );
     
    $templateCache.put(
        "SelectPageTypeComponent.html", 
        "<div><div class=\"se-add-page__sub-header\">{{ 'se.cms.addpagewizard.pagetype.description' | translate }}</div><div class=\"se-add-page__list fd-menu\" *ngIf=\"pageTypes.length > 0\"><div class=\"se-add-page__item fd-menu__item\" *ngFor=\"let pageType of pageTypes\" [ngClass]=\"{ 'is-selected': isSelected(pageType)}\" (click)=\"selectType(pageType)\"><div class=\"se-add-page__item-title\">{{ pageType.name | seL10n | async }}</div><div class=\"se-add-page__item-description\">{{ pageType.description | seL10n | async }}</div></div></div></div>"
    );
     
    $templateCache.put(
        "SelectTargetCatalogVersionComponent.html", 
        "<div class=\"target-catalog-version-selector-wrapper form-group\"><label for=\"se-catalog-version-selector-dropdown\" class=\"se-control-label\" translate=\"se.cms.clonepagewizard.options.targetcatalogversion.label\"></label><se-select *ngIf=\"!!catalogVersions.length\" id=\"se-catalog-version-selector-dropdown\" [(model)]=\"selectedCatalogVersion\" [fetchStrategy]=\"catalogVersionSelectorFetchStrategy\" [onChange]=\"onSelectionChange\" [searchEnabled]=\"false\" (getApi)=\"setSelectApi($event)\"></se-select><div *ngIf=\"catalogVersionContainsPageWithSameLabel\"><span class=\"help-block\" translate=\"se.cms.clonepagewizard.options.targetcatalogversion.label.exists.message\"></span></div></div>"
    );
     
    $templateCache.put(
        "ComponentCloneInfoComponent.html", 
        "<se-message *ngIf=\"catalogVersionContainsPageWithSameTypeCode\" type=\"warning\"><span se-message-description translate=\"se.cms.clonepagewizard.pageinfo.targetcatalogversion.pagetype.exists.message\" [translateParams]=\"{ typeCode: pageTypeCode }\"></span></se-message><se-generic-editor [id]=\"genericEditorId\" [structure]=\"structure\" [content]=\"content\" [(submit)]=\"submitInternal\" [(reset)]=\"resetInternal\" [(isDirty)]=\"isDirtyInternal\" [(isValid)]=\"isValidInternal\" (getApi)=\"setGenericEditorApi($event)\"></se-generic-editor>"
    );
     
    $templateCache.put(
        "ComponentCloneOptionFormComponent.html", 
        "<label for=\"components-cloned-selector-id\" class=\"se-control-label\"><span translate=\"se.cms.clonepagewizard.options.title\"></span><se-help><span translate=\"se.cms.clonepagewizard.options.tooltip\"></span></se-help></label><div id=\"components-cloned-selector-id\"><div class=\"se-form-control-row\"><input class=\"components-cloned-option-id fd-form__control\" type=\"radio\" name=\"componentsclone\" id=\"reference-cloning\" [(ngModel)]=\"componentInSlotOption\" (click)=\"updateComponentInSlotOption(CLONE_COMPONENTS_IN_CONTENT_SLOTS_OPTION.REFERENCE_EXISTING)\" [value]=\"CLONE_COMPONENTS_IN_CONTENT_SLOTS_OPTION.REFERENCE_EXISTING\"/> <label for=\"reference-cloning\" translate=\"se.cms.clonepagewizard.options.existing\"></label></div><div class=\"se-form-control-row\"><input class=\"components-cloned-option-id fd-form__control\" type=\"radio\" id=\"deep-cloning\" name=\"componentsclone\" [(ngModel)]=\"componentInSlotOption\" (click)=\"updateComponentInSlotOption(CLONE_COMPONENTS_IN_CONTENT_SLOTS_OPTION.CLONE)\" [value]=\"CLONE_COMPONENTS_IN_CONTENT_SLOTS_OPTION.CLONE\"/> <label for=\"deep-cloning\" translate=\"se.cms.clonepagewizard.options.copies\"></label></div></div>"
    );
     
    $templateCache.put(
        "VersionItemComponent.html", 
        "<div class=\"se-version-item\" [ngClass]=\"{ 'se-version-item--selected': isSelectedVersion() }\"><div class=\"se-version-item__header\" [title]=\"pageVersion.label\"><button class=\"se-version-item__label se-button--text\" (click)=\"selectVersion()\">{{ pageVersion.label }}</button><se-version-item-menu *ngIf=\"isVersionMenuEnabled()\" [item]=\"pageVersion\"></se-version-item-menu></div><div class=\"se-version-item__date\">{{ pageVersion.creationtime | date: 'M/d/yy h:mm a' }}</div><div class=\"se-version-item__description\" *ngIf=\"pageVersion.description\"><se-more-text class=\"se-version-item__description-text\" [text]=\"pageVersion.description\" [limit]=\"32\" [ellipsis]=\"'...'\" [capitalizeLabel]=\"true\"></se-more-text></div></div>"
    );
     
    $templateCache.put(
        "VersionItemMenuComponent.html", 
        "<se-popup-overlay class=\"se-version-item-menu__popup-anchor\" [ngClass]=\"{ 'se-version-item-menu__popup-anchor--open': isMenuOpen }\" [popupOverlay]=\"popupConfig\" [popupOverlayTrigger]=\"isMenuOpen\" (popupOverlayOnHide)=\"hideMenu()\"><div *ngIf=\"menuItems.length > 0\" (click)=\"onButtonClick($event)\" class=\"sap-icon--overflow se-version-item-menu__toggle\"></div><div se-popup-overlay-body class=\"se-version-item-menu fd-menu\"><div class=\"se-version-item-menu__item fd-menu__list\" *ngFor=\"let item of menuItems\" (click)=\"executeItemCallback(item)\"><span class=\"se-version-item-menu__item-link fd-menu__item\">{{ item.i18nKey | translate }}</span></div></div></se-popup-overlay>"
    );
     
    $templateCache.put(
        "VersionsSearchComponent.html", 
        "<div class=\"se-versions-panel__search\" *ngIf=\"showSearchControls\"><div class=\"se-input-group\"><input type=\"text\" class=\"se-input-group__input-area\" name=\"search-term\" [ngModel]=\"searchTerm\" (ngModelChange)=\"onChange($event)\" [placeholder]=\"'se.cms.versions.search.placeholder' | translate\"/> <span class=\"sap-icon--search se-input-group__addon\"></span> <button class=\"se-input-group__addon se-input-group__clear-btn sap-icon--decline\" [style.visibility]=\"showResetButton ? 'visible' : 'hidden'\" (click)=\"resetSearchBox()\"></button></div><span class=\"se-versions-panel__count\" [translate]=\"'se.cms.versions.search.versions.found'\" [translateParams]=\"{ versionsFound: versionsFoundCount }\"></span></div>"
    );
     
    $templateCache.put(
        "PageStatusComponent.html", 
        "<div class=\"se-page-status\"><div class=\"se-page-status__icon\" [ngClass]=\"statusIconCssClass\"></div><div class=\"se-page-status__label\">{{ statusLabel | translate }}</div></div>"
    );
     
    $templateCache.put(
        "WorkflowActionCommentComponent.html", 
        "<ng-container *ngIf=\"isDecisionComment; then decisionComment; else generalComment\"></ng-container><ng-template #decisionComment><div class=\"se-workflow-action-comment\"><div class=\"fd-tile\"><div class=\"fd-tile__content\"><h2 class=\"fd-tile__title se-workflow-action-comment__header sap-icon--workflow-tasks sap-icon--m\" [class.sap-icon--flip-h]=\"!isIncomingDecision()\">{{ actionComment.decisionName }}</h2><p class=\"fd-has-type-minus-1\">{{ actionComment.authorName }} | {{ createdAgo }}</p><p *ngIf=\"!!actionComment.text\"><strong>{{'se.cms.page.workflow.action.item.comment.header' | translate}}:</strong><ng-container *ngTemplateOutlet=\"comment\"></ng-container></p></div></div></div></ng-template><ng-template #generalComment><div class=\"se-workflow-action-comment\"><div class=\"fd-tile\"><div class=\"fd-tile__content\"><h2 class=\"fd-panel__title\">{{'se.cms.page.workflow.action.item.comment.header' | translate}}</h2><p>{{ createdAgo }}</p><p class=\"se-workflow-action-comment__author\">{{ actionComment.authorName }}</p><ng-container *ngTemplateOutlet=\"comment\"></ng-container></div></div></div></ng-template><ng-template #comment><se-more-text class=\"se-workflow-action-comment__body\" [ellipsis]=\"'...'\" [text]=\"actionComment.text\"></se-more-text></ng-template>"
    );
     
    $templateCache.put(
        "WorkflowActionItemComponent.html", 
        "<div class=\"se-workflow-action-item\" [ngClass]=\"getWorkflowActionStatusClass()\"><se-collapsible-container class=\"se-catalog-details__collapse se-collapsible-container--noshadow fd-panel\" [id]=\"workflowAction.code\" (getApi)=\"setCollapsibleContainerApi($event)\"><se-collapsible-container-header><div class=\"fd-panel__header\"><div class=\"fd-panel__head\"><h1 class=\"fd-panel__title\">{{ workflowAction.name | seL10n | async }}</h1><p class=\"fd-panel__description\">{{ getReadableStatus() | translate }} {{ getActiveSince() }}</p></div></div><div class=\"fd-panel__body\">{{ workflowAction.description | seL10n | async }}<div *ngIf=\"canShowDecisionButtons()\" class=\"se-workflow-action-item__decision-buttons fd-dropdown\"><div class=\"fd-popover\"><div class=\"fd-popover__control\"><div [ngClass]=\"{ 'fd-button-split': workflowAction.decisions.length > 1 }\"><button class=\"se-workflow-action-item__decision-button fd-button--compact\" [id]=\"workflowAction.code + '-decision-button'\" (click)=\"onMainButtonClick($event, workflowAction.decisions[0])\" type=\"button\">{{ workflowAction.decisions[0].name | seL10n | async }}</button><se-popup-overlay [popupOverlay]=\"{                                        halign: 'right',                                        valign: 'bottom'                                    }\" [popupOverlayTrigger]=\"isMenuOpen\" (popupOverlayOnHide)=\"onMenuHide()\"><button *ngIf=\"workflowAction.decisions.length > 1\" [id]=\"workflowAction.code + '-decision-split-button'\" class=\"fd-button--compact menu-button sap-icon--slim-arrow-down\" (click)=\"onSplitButtonClick($event)\"></button><div se-popup-overlay-body class=\"fd-popover__body fd-popover__body--right fd-popover__body--no-arrow se-workflow-action-item__decision-list\"><nav class=\"fd-menu\"><ul class=\"fd-menu__list\"><li *ngFor=\"let decision of workflowAction.decisions\"><a class=\"fd-menu__item se-workflow-action-item__decision\" (click)=\"onMainButtonClick($event, decision)\">{{ decision.name | seL10n | async }}</a></li></ul></nav></div></se-popup-overlay></div></div></div></div></div></se-collapsible-container-header><se-collapsible-container-content><div class=\"se-workflow-action-item__content\" *ngIf=\"canShowComments()\"><span *ngIf=\"!hasComments\" class=\"se-workflow-action-item__comment-list fd-has-font-style-italic fd-has-color-text-4\" [translate]=\"'se.cms.actionitem.page.workflow.action.no.comments.available'\"></span><se-infinite-scrolling [pageSize]=\"pageSize\" [fetchPage]=\"fetchPageOfComments\" (itemsChange)=\"onCommentsLoaded($event)\"><div *ngFor=\"let actionComment of workflowActionComments; trackBy: trackByIndex\"><se-workflow-action-comment [workflowAction]=\"workflowAction\" [actionComment]=\"actionComment\"></se-workflow-action-comment></div></se-infinite-scrolling></div></se-collapsible-container-content></se-collapsible-container><fd-popover [isOpen]=\"showApprovalInfo\" [closeOnOutsideClick]=\"false\"><fd-popover-body><div class=\"se-workflow-approval-info\">{{ approvalInfo }}</div></fd-popover-body></fd-popover></div>"
    );
     
    $templateCache.put(
        "CategoryNodeComponent.html", 
        "<div class=\"se-product-row\"><div class=\"se-category-node\" [ngClass]=\"{          'se-category-node--no-drag': !parent.dragEnabled,          'se-category-node--drag': parent.dragEnabled        }\"><div class=\"se-product-row__product\" [title]=\"node.name | seL10n | async\">{{ node.name | seL10n | async }}</div><div class=\"se-product-row__product\" [title]=\"node.code\">{{ node.code }}</div><div class=\"se-product-row__catalog\" title=\"{{ node.catalogId }} - {{ node.catalogVersion }}\">{{ node.catalogId }} - {{ node.catalogVersion }}</div><div><se-dropdown-menu *ngIf=\"parent.dragEnabled\" [dropdownItems]=\"dropdownItems\" [selectedItem]=\"node\" class=\"pull-right se-tree-node__actions--more-menu\"></se-dropdown-menu></div></div></div>"
    );
     
    $templateCache.put(
        "CategorySelectorItemComponent.html", 
        "<div class=\"se-product-row\"><div class=\"se-category-row-container--item\"><div class=\"se-product-row__product\" [title]=\"item.name | seL10n | async\">{{ item.name | seL10n | async }}</div><div class=\"se-product-row__product\" [title]=\"item.code\">{{ item.code }}</div><div class=\"se-product-row__catalog\" title=\"{{ item.catalogId }} - {{ item.catalogVersion }}\">{{ item.catalogId }} - {{ item.catalogVersion }}</div></div></div>"
    );
     
    $templateCache.put(
        "ProductNodeComponent.html", 
        "<div class=\"se-product-row\"><div class=\"se-product-node\" [ngClass]=\"{            'se-product-node--no-drag' : !parent.dragEnabled,            'se-product-node--drag': parent.dragEnabled         }\"><img class=\"se-product-row__img\" [src]=\"node.thumbnail.url || '/cmssmartedit/images/product_thumbnail_default.png'\" alt=\"product image\"/><div class=\"se-product-row__product se-nowrap-ellipsis\" [title]=\"node.name | seL10n  | async\">{{ node.name | seL10n | async }}</div><div class=\"se-product-row__product se-nowrap-ellipsis\" [title]=\"node.code\">{{ node.code }}</div><div class=\"se-product-row__catalog se-nowrap-ellipsis\" title=\"{{ node.catalogId }} - {{ node.catalogVersion }}\">{{ node.catalogId }} - {{ node.catalogVersion }}</div><se-dropdown-menu *ngIf=\"parent.dragEnabled\" [dropdownItems]=\"dropdownItems\" [selectedItem]=\"node\" class=\"pull-right se-tree-node__actions--more-menu\"></se-dropdown-menu></div></div>"
    );
     
    $templateCache.put(
        "ProductSelectorItemComponent.html", 
        "<div class=\"se-product-row\"><div class=\"se-product-node\"><img class=\"se-product-row__img\" [src]=\"getThumbnailUrl(item.thumbnail?.url)\" alt=\"product image\"/><div class=\"se-product-row__product se-nowrap-ellipsis\" [title]=\"item.name | seL10n | async\">{{ item.name | seL10n | async }}</div><div class=\"se-product-row__product se-nowrap-ellipsis\" [title]=\"item.code\">{{ item.code }}</div><div class=\"se-product-row__catalog\"><div class=\"se-nowrap-ellipsis\" title=\"{{ item.catalogId }} - {{ item.catalogVersion }}\">{{ item.catalogId }} - {{ item.catalogVersion }}</div></div></div></div>"
    );
     
    $templateCache.put(
        "MediaContainerSelectorComponent.html", 
        "<se-generic-editor-dropdown [id]=\"id\" [field]=\"field\" [qualifier]=\"field.qualifier\" [model]=\"mediaContainerNameModel\" [showRemoveButton]=\"true\" [itemComponent]=\"itemComponent\" [actionableSearchItem]=\"actionableSearchItem\" [(reset)]=\"reset\"></se-generic-editor-dropdown><div *ngIf=\"isSelected() || creationInProgress\"><label [for]=\"'media-container-qualifier-' + id\" class=\"se-control-label required se-media-container-name-label\">{{ 'se.cms.media.responsive.name' | lowercase | translate }}</label> <input type=\"text\" name=\"media-container-qualifier\" [id]=\"'media-container-qualifier-' + id\" class=\"fd-form-control\" [ngModel]=\"name\" (ngModelChange)=\"onNameChange($event)\" [readOnly]=\"isNameReadOnly()\" [disabled]=\"!field.editable\"/></div>"
    );
     
    $templateCache.put(
        "MediaContainerSelectorItemComponent.html", 
        "<div class=\"media-container-selector-item__row\"><img class=\"media-container-selector-item__img\" [ngClass]=\"{ 'media-container-selector-item__img--selected': isSelected }\" [src]=\"getThumbnailUrl(item.thumbnailUrl)\"/><div class=\"media-container-selector-item__label\">{{ item.qualifier }}</div></div>"
    );
     
    $templateCache.put(
        "MediaFormatUploadedComponent.html", 
        "<div class=\"se-media--present\"><div class=\"se-media--present-img-container se-media-preview-container\"><div *ngIf=\"isImage()\" class=\"se-media-preview__image-wrapper\"><se-media-preview [imageUrl]=\"getSafeUrl()\"></se-media-preview><img class=\"se-media-preview__image-thumbnail\" [src]=\"getSafeUrl()\"/></div><div *ngIf=\"isVideo()\" class=\"se-media-preview__image-wrapper\"><video class=\"se-media-preview__image-thumbnail\" controls><source [src]=\"getSafeUrl()\" type=\"video/mp4\"/></video></div><div *ngIf=\"isPdf()\" class=\"se-media-preview__image-wrapper\"><iframe class=\"se-media-preview__image-thumbnail\" [src]=\"getSafeUrl()\" style=\"width: 100%;height: 100%;border: none;\"></iframe></div></div><se-media-advanced-properties [code]=\"media.code\" [description]=\"media.description\" [altText]=\"media.altText\"></se-media-advanced-properties><se-media-file-selector [labelI18nKey]=\"replaceLabelI18nKey\" [acceptedFileTypes]=\"acceptedFileTypes\" [customClass]=\"'media-format-present-replace' + (isFieldDisabled ? ' file-selector-disabled' : '')\" [disabled]=\"isFieldDisabled\" (onFileSelect)=\"onFileSelectorFileSelect($event)\"></se-media-file-selector><se-media-remove-button [isDisabled]=\"isFieldDisabled\" (clickHandler)=\"onRemoveButtonClick()\"></se-media-remove-button></div>"
    );
     
    $templateCache.put(
        "MediaPrinterComponent.html", 
        "<div class=\"se-media-selector\" *ngIf=\"isSelected\"><span class=\"se-media-selector__left-section se-media-preview-container\"><div *ngIf=\"isImage()\" class=\"se-media-selector__left-section se-media-preview-container\"><se-media-preview [imageUrl]=\"getSafeUrl()\"></se-media-preview><img class=\"se-media-preview__image-thumbnail\" [alt]=\"media.code\" [src]=\"getSafeUrl()\"/></div><div *ngIf=\"isVideo()\" class=\"se-media-selector__left-section se-media-preview-container\"><video class=\"se-media-preview__image-thumbnail\" controls><source [src]=\"getSafeUrl()\" type=\"video/mp4\"/></video></div><div *ngIf=\"isPdf()\" class=\"se-media-selector__left-section se-media-preview-container\"><iframe class=\"se-media-preview__image-thumbnail\" [src]=\"getSafeUrl()\" style=\"width: 100%;height: 100%;border: none;\"></iframe></div></span><span class=\"se-media-selector__right-section\"><se-media-advanced-properties [code]=\"media.code\" [description]=\"media.description\" [altText]=\"media.altText\"></se-media-advanced-properties><button class=\"se-media-action-btn replace-image\" [disabled]=\"isDisabled()\"><span class=\"sap-icon--share se-media__action-icon\"></span><se-media-action-label [state]=\"isDisabled() ? 'disabled' : null\" [i18nKey]=\"'se.upload.image.replace'\"></se-media-action-label></button><se-media-remove-button [isDisabled]=\"isDisabled()\" (clickHandler)=\"select.removeSelectedOption($event, media)\"></se-media-remove-button></span></div><div class=\"se-media-selector__search\" *ngIf=\"!isSelected\"><div *ngIf=\"isImage()\" class=\"se-media-selector__search-img-wrapper\"><img [src]=\"getSafeUrl()\" class=\"se-media-selector__search-img\" [alt]=\"media.code\"/></div><div *ngIf=\"isVideo()\" class=\"se-media-selector__search-img-wrapper\"><video class=\"se-media-selector__search-img\" controls><source [src]=\"getSafeUrl()\" type=\"video/mp4\"/></video></div><div *ngIf=\"isPdf()\" class=\"se-media-selector__search-img-wrapper\"><iframe class=\"se-media-selector__search-img\" [src]=\"getSafeUrl()\" style=\"width: 100%;height: 100%;border: none;\"></iframe></div><div class=\"se-media-selector__search-name\">{{ media.code }}</div></div>"
    );
     
    $templateCache.put(
        "MediaUploadFieldComponent.html", 
        "<div class=\"se-media-upload__file-info-field\" [ngClass]=\"getContainerClassName()\"><label class=\"se-control-label\" [ngClass]=\"{ 'se-media-upload-has-error': hasError(), required: isRequired }\" [translate]=\"labelI18nKey\"></label> <input type=\"text\" [ngClass]=\"{ 'is-invalid': hasError() }\" class=\"fd-form__control\" [attr.name]=\"fieldName\" [ngModel]=\"fieldValue\" (ngModelChange)=\"onChangeValue($event)\"/> <span class=\"upload-field-error fd-form__message fd-form__message--error\" [ngClass]=\"getErrorClassName()\" *ngFor=\"let error of fieldErrors\">{{ error | translate }}</span></div>"
    );
    
      }]);
    })();

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

window.__smartedit__.addDecoratorPayload("Component", "SubTypeSelectorComponent", {
    selector: 'se-sub-type-selector',
    template: `<ul class="se-sub-type__selector fd-menu__list"><li class="cms-sub-type__selector-link fd-menu__item" *ngFor="let subType of subTypes" (click)="select(subType)" [translate]="subType.label"></li></ul>`,
    styles: [`.cms-sub-type__selector-link{display:flex;flex-direction:row;align-items:center;color:#0a6ed1;height:46px}.cms-sub-type__selector-link:hover{color:#085caf}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
/* @ngInject */ exports.SubTypeSelectorComponent = class /* @ngInject */ SubTypeSelectorComponent {
    constructor() {
        this.onSubTypeSelect = new core.EventEmitter();
    }
    select({ id }) {
        this.onSubTypeSelect.emit(id);
    }
};
__decorate([
    core.Input(),
    __metadata("design:type", Array)
], /* @ngInject */ exports.SubTypeSelectorComponent.prototype, "subTypes", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ exports.SubTypeSelectorComponent.prototype, "onSubTypeSelect", void 0);
/* @ngInject */ exports.SubTypeSelectorComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-sub-type-selector',
        template: `<ul class="se-sub-type__selector fd-menu__list"><li class="cms-sub-type__selector-link fd-menu__item" *ngFor="let subType of subTypes" (click)="select(subType)" [translate]="subType.label"></li></ul>`,
        styles: [`.cms-sub-type__selector-link{display:flex;flex-direction:row;align-items:center;color:#0a6ed1;height:46px}.cms-sub-type__selector-link:hover{color:#085caf}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    })
], /* @ngInject */ exports.SubTypeSelectorComponent);

window.__smartedit__.addDecoratorPayload("Component", "SelectComponentTypeModalComponent", {
    selector: 'se-select-component-type-modal',
    template: `
        <se-sub-type-selector
            class="sub-type-selector"
            [subTypes]="subTypes"
            (onSubTypeSelect)="closeWithSelectedId($event)"
        >
        </se-sub-type-selector>
    `,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
exports.SelectComponentTypeModalComponent = class SelectComponentTypeModalComponent {
    constructor(modalManager) {
        this.modalManager = modalManager;
    }
    ngOnInit() {
        this.modalManager
            .getModalData()
            .pipe(operators.take(1))
            .subscribe(({ subTypes }) => (this.subTypes = this.mapSubTypesToIdWithLabel(subTypes)));
    }
    closeWithSelectedId(subTypeId) {
        this.modalManager.close(subTypeId);
    }
    mapSubTypesToIdWithLabel(subTypes) {
        return Object.keys(subTypes).map((key) => ({
            id: key,
            label: subTypes[key]
        }));
    }
};
exports.SelectComponentTypeModalComponent = __decorate([
    core.Component({
        selector: 'se-select-component-type-modal',
        template: `
        <se-sub-type-selector
            class="sub-type-selector"
            [subTypes]="subTypes"
            (onSubTypeSelect)="closeWithSelectedId($event)"
        >
        </se-sub-type-selector>
    `,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [smarteditcommons.ModalManagerService])
], exports.SelectComponentTypeModalComponent);

/*
 * Copyright (c) 2022 SAP SE or an SAP affiliate company. All rights reserved.
 */
const ON_EDIT_NESTED_COMPONENT_EVENT = 'ON_EDIT_NESTED_COMPONENT';
const CREATE_COMPONENT_BUTTON_PRESSED_EVENT_ID = 'CREATE_NESTED_COMPONENT_BUTTON_PRESSED_EVENT';

window.__smartedit__.addDecoratorPayload("Component", "CmsDropdownItemComponent", {
    selector: 'se-cms-dropdown-item',
    template: `<div class="cms-nested-component" *ngIf="item" [attr.data-component-id]="item.uid"><span class="cms-nested-component__item" *ngIf="isSelected" (click)="onClick($event);"><span class="sap-icon--card cms-nested-component__item-icon"></span><div class="cms-nested-component__item-data"><p class="cms-nested-component__item-name" [title]="item.name">{{ item.name }}</p><p class="cms-nested-component__item-type" [title]="item.typeCode">{{ item.typeCode }}</p></div></span><div class="cms-nested-component__result-item" *ngIf="!isSelected"><span class="cms-nested-component__result-name" [title]="item.name">{{ item.name }}</span> <span class="cms-nested-component__result-code" [title]="item.typeCode">{{ item.typeCode }}</span></div></div>`,
    styles: [`.cms-nested-component__item{display:flex;flex-direction:row;align-items:center;justify-content:flex-start;color:#0a6ed1}.cms-nested-component__item-icon{display:flex;flex-direction:row;align-items:center;justify-content:center;background-color:#0a6ed1;height:28px;flex:0 0 28px;color:#fff;border-radius:4px;margin-right:16px}.cms-nested-component__item-data{width:100%;display:grid;grid-template-columns:auto auto;grid-gap:0 16px}.cms-nested-component__item-name,.cms-nested-component__item-type{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;margin-bottom:0}.cms-nested-component__result-item{display:grid;grid-template-columns:repeat(2,1fr);grid-gap:0 16px}.cms-nested-component__result-code,.cms-nested-component__result-name{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all}.cms-nested-component__item[draggable=true],.ui-select-match-item[draggable=true]{cursor:move}.y-select-item-printer{width:100%}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    encapsulation: core.ViewEncapsulation.None
});
/* @ngInject */ exports.CmsDropdownItemComponent = class /* @ngInject */ CmsDropdownItemComponent {
    constructor(data, systemEventService) {
        this.systemEventService = systemEventService;
        ({
            item: this.item,
            select: { id: this.qualifier },
            selected: this.isSelected
        } = data);
    }
    onClick(event) {
        event.stopPropagation();
        if (this.isSelected) {
            this.systemEventService.publishAsync(ON_EDIT_NESTED_COMPONENT_EVENT, {
                qualifier: this.qualifier,
                item: this.item
            });
        }
    }
};
exports.CmsDropdownItemComponent.$inject = ["data", "systemEventService"];
/* @ngInject */ exports.CmsDropdownItemComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-cms-dropdown-item',
        template: `<div class="cms-nested-component" *ngIf="item" [attr.data-component-id]="item.uid"><span class="cms-nested-component__item" *ngIf="isSelected" (click)="onClick($event);"><span class="sap-icon--card cms-nested-component__item-icon"></span><div class="cms-nested-component__item-data"><p class="cms-nested-component__item-name" [title]="item.name">{{ item.name }}</p><p class="cms-nested-component__item-type" [title]="item.typeCode">{{ item.typeCode }}</p></div></span><div class="cms-nested-component__result-item" *ngIf="!isSelected"><span class="cms-nested-component__result-name" [title]="item.name">{{ item.name }}</span> <span class="cms-nested-component__result-code" [title]="item.typeCode">{{ item.typeCode }}</span></div></div>`,
        styles: [`.cms-nested-component__item{display:flex;flex-direction:row;align-items:center;justify-content:flex-start;color:#0a6ed1}.cms-nested-component__item-icon{display:flex;flex-direction:row;align-items:center;justify-content:center;background-color:#0a6ed1;height:28px;flex:0 0 28px;color:#fff;border-radius:4px;margin-right:16px}.cms-nested-component__item-data{width:100%;display:grid;grid-template-columns:auto auto;grid-gap:0 16px}.cms-nested-component__item-name,.cms-nested-component__item-type{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;margin-bottom:0}.cms-nested-component__result-item{display:grid;grid-template-columns:repeat(2,1fr);grid-gap:0 16px}.cms-nested-component__result-code,.cms-nested-component__result-name{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all}.cms-nested-component__item[draggable=true],.ui-select-match-item[draggable=true]{cursor:move}.y-select-item-printer{width:100%}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush,
        encapsulation: core.ViewEncapsulation.None
    }),
    __param(0, core.Inject(smarteditcommons.ITEM_COMPONENT_DATA_TOKEN)),
    __metadata("design:paramtypes", [Object, smarteditcommons.SystemEventService])
], /* @ngInject */ exports.CmsDropdownItemComponent);

let /* @ngInject */ SelectComponentTypeModalService = class /* @ngInject */ SelectComponentTypeModalService {
    constructor(logService, modalService) {
        this.logService = logService;
        this.modalService = modalService;
    }
    open(subTypes) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.modalService
                .open({
                component: exports.SelectComponentTypeModalComponent,
                data: {
                    subTypes
                },
                config: {
                    modalPanelClass: 'modal-lg'
                },
                templateConfig: {
                    title: 'se.cms.nestedcomponenteditor.select.type'
                }
            })
                .afterClosed.toPromise()
                .catch((error) => {
                this.logService.debug('Select Component Type Modal dismissed', error);
            });
        });
    }
};
SelectComponentTypeModalService.$inject = ["logService", "modalService"];
/* @ngInject */ SelectComponentTypeModalService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.LogService, smarteditcommons.ModalService])
], /* @ngInject */ SelectComponentTypeModalService);

let /* @ngInject */ NestedComponentManagementService = class /* @ngInject */ NestedComponentManagementService {
    constructor(editorModalService) {
        this.editorModalService = editorModalService;
    }
    openNestedComponentEditor(componentInfo, editorStackId) {
        const componentAttributes = this.prepareComponentAttributes(componentInfo);
        return this.editorModalService.open(componentAttributes, null, null, null, null, editorStackId);
    }
    prepareComponentAttributes({ componentUuid, componentType, content }) {
        return {
            smarteditComponentUuid: componentUuid,
            smarteditComponentType: componentType,
            content: lodash.defaultsDeep({}, content, {
                typeCode: componentType,
                itemtype: componentType,
                visible: true
            })
        };
    }
};
NestedComponentManagementService.$inject = ["editorModalService"];
/* @ngInject */ NestedComponentManagementService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.IEditorModalService])
], /* @ngInject */ NestedComponentManagementService);

/**
 * Implementation of Dropdown Populator for "CMSItemDropdown" Structure Type.
 * Methods of this service will be used to populate the dropdown rendered by GenericEditorDropdownComponent.
 */
let /* @ngInject */ CMSItemDropdownDropdownPopulator = class /* @ngInject */ CMSItemDropdownDropdownPopulator extends smarteditcommons.DropdownPopulatorInterface {
    constructor(genericEditorStackService, languageService, translateService, uriDropdownPopulator) {
        super(lodash__namespace, languageService, translateService);
        this.genericEditorStackService = genericEditorStackService;
        this.uriDropdownPopulator = uriDropdownPopulator;
        this.CMS_ITEMS_URI = '/cmswebservices/v1/sites/CURRENT_CONTEXT_SITE_ID/cmsitems';
    }
    fetchAll(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            this.preparePayload(payload);
            const items = yield this.uriDropdownPopulator.fetchAll(payload);
            return this.getNonNestedComponents(payload.field.editorStackId, items);
        });
    }
    fetchPage(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            this.preparePayload(payload);
            const page = yield this.uriDropdownPopulator.fetchPage(payload);
            page.response = this.getNonNestedComponents(payload.field.editorStackId, page.response);
            return page;
        });
    }
    getItem(payload) {
        this.preparePayload(payload);
        return this.uriDropdownPopulator.getItem(payload);
    }
    preparePayload(payload) {
        payload.field.uri = this.CMS_ITEMS_URI;
    }
    getNonNestedComponents(editorStackId, components) {
        // Get the IDs of the components that are already opened in the editor's stack.
        const componentsInStack = this.genericEditorStackService
            .getEditorsStack(editorStackId)
            .filter((componentInStack) => componentInStack.component.uuid)
            .map((componentInStack) => componentInStack.component.uuid);
        components = components.filter((componentInList) => !componentInList.uuid || !componentsInStack.includes(componentInList.uuid));
        return components;
    }
};
CMSItemDropdownDropdownPopulator.$inject = ["genericEditorStackService", "languageService", "translateService", "uriDropdownPopulator"];
/* @ngInject */ CMSItemDropdownDropdownPopulator = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.GenericEditorStackService,
        smarteditcommons.LanguageService,
        core$1.TranslateService,
        smarteditcommons.UriDropdownPopulator])
], /* @ngInject */ CMSItemDropdownDropdownPopulator);

window.__smartedit__.addDecoratorPayload("Component", "CmsComponentDropdownComponent", {
    selector: 'se-cms-component-dropdown',
    template: `<div class="cms-nested-component-template"><div class="cms-nested-component-select"><ng-container *ngIf="forceRecompile"><se-generic-editor-dropdown [field]="field" [qualifier]="qualifier" [model]="model" [id]="id" [itemComponent]="itemComponent" [actionableSearchItem]="actionableSearchItem" [showRemoveButton]="true"></se-generic-editor-dropdown></ng-container></div></div>`,
    styles: [`se-cms-component-dropdown div.se-actionable-search-item{display:flex;align-items:center;justify-content:space-between;padding:0 0 0 13px}se-cms-component-dropdown se-item-printer{width:100%}`],
    encapsulation: core.ViewEncapsulation.None,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
/* @ngInject */ exports.CmsComponentDropdownComponent = class /* @ngInject */ CmsComponentDropdownComponent {
    constructor(data, systemEventService, genericEditorStackService, nestedComponentManagementService, selectComponentTypeModalService, logService, cdr) {
        this.systemEventService = systemEventService;
        this.genericEditorStackService = genericEditorStackService;
        this.nestedComponentManagementService = nestedComponentManagementService;
        this.selectComponentTypeModalService = selectComponentTypeModalService;
        this.logService = logService;
        this.cdr = cdr;
        ({ field: this.field, model: this.model, id: this.id, qualifier: this.qualifier } = data);
        this.editorStackId = data.editor.editorStackId;
        this.forceRecompile = true;
    }
    ngOnInit() {
        this.itemComponent = exports.CmsDropdownItemComponent;
        this.field.params = this.field.params || {};
        this.field.editorStackId = this.editorStackId;
        this.field.params.catalogId = cmscommons.CONTEXT_CATALOG;
        this.field.params.catalogVersion = cmscommons.CONTEXT_CATALOG_VERSION;
        this.componentButtonPressedEventId = `${CREATE_COMPONENT_BUTTON_PRESSED_EVENT_ID}_${this.qualifier}`;
        this.actionableSearchItem =
            !!this.field.subTypes && Object.keys(this.field.subTypes).length > 0
                ? { eventId: this.componentButtonPressedEventId }
                : undefined;
        this.createComponentButtonUnRegFn = this.systemEventService.subscribe(this.componentButtonPressedEventId, (_eventId, data) => this.onCreateComponentButtonPressed(data));
        this.editComponentClickedUnRegFn = this.systemEventService.subscribe(ON_EDIT_NESTED_COMPONENT_EVENT, (_eventId, data) => this.onEditComponentClicked(data));
    }
    ngOnDestroy() {
        this.createComponentButtonUnRegFn();
        this.editComponentClickedUnRegFn();
    }
    onCreateComponentButtonPressed(query) {
        return __awaiter(this, void 0, void 0, function* () {
            this.searchQuery = query;
            if (!this.genericEditorStackService.isTopEditorInStack(this.editorStackId, this.id)) {
                return;
            }
            if (this.field.subTypes) {
                const keys = Object.keys(this.field.subTypes);
                if (keys.length > 1) {
                    const subTypeId = yield this.selectComponentTypeModalService.open(this.field.subTypes);
                    if (!!subTypeId) {
                        this.createNestedComponent(subTypeId);
                    }
                }
                else {
                    this.createNestedComponent(keys[0]);
                }
            }
        });
    }
    onEditComponentClicked(payload) {
        if (this.genericEditorStackService.isTopEditorInStack(this.editorStackId, this.id)) {
            if (this.qualifier === payload.qualifier) {
                this.editComponent(payload.item);
            }
        }
    }
    createNestedComponent(componentType) {
        return __awaiter(this, void 0, void 0, function* () {
            const componentInfo = {
                componentId: null,
                componentUuid: null,
                componentType,
                content: {
                    name: this.searchQuery,
                    catalogVersion: this.model.catalogVersion
                }
            };
            yield this.nestedComponentEditorHandler(componentInfo);
        });
    }
    editComponent(itemToEdit) {
        return __awaiter(this, void 0, void 0, function* () {
            const componentInfo = {
                componentId: itemToEdit.uid,
                componentUuid: itemToEdit.uuid,
                componentType: itemToEdit.typeCode || itemToEdit.itemtype,
                content: itemToEdit
            };
            yield this.nestedComponentEditorHandler(componentInfo);
        });
    }
    nestedComponentEditorHandler(componentInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const item = yield this.nestedComponentManagementService.openNestedComponentEditor(componentInfo, this.editorStackId);
                if (this.field.collection) {
                    if (!this.model[this.qualifier]) {
                        this.model[this.qualifier] = [];
                    }
                    this.model[this.qualifier] = this.model[this.qualifier]
                        .filter((uid) => uid !== item.uuid)
                        .concat(item.uuid);
                }
                else {
                    this.forceRecompile = false;
                    setTimeout(() => {
                        this.forceRecompile = true;
                        this.model[this.qualifier] = item.uuid;
                        if (!this.cdr.destroyed) {
                            this.cdr.detectChanges();
                        }
                    });
                }
                if (!this.cdr.destroyed) {
                    this.cdr.detectChanges();
                }
            }
            catch (error) {
                if (error) {
                    this.logService.warn(`Something went wrong when creating or editing Nested component (${componentInfo.componentType})`, error);
                }
            }
        });
    }
};
exports.CmsComponentDropdownComponent.$inject = ["data", "systemEventService", "genericEditorStackService", "nestedComponentManagementService", "selectComponentTypeModalService", "logService", "cdr"];
/* @ngInject */ exports.CmsComponentDropdownComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-cms-component-dropdown',
        template: `<div class="cms-nested-component-template"><div class="cms-nested-component-select"><ng-container *ngIf="forceRecompile"><se-generic-editor-dropdown [field]="field" [qualifier]="qualifier" [model]="model" [id]="id" [itemComponent]="itemComponent" [actionableSearchItem]="actionableSearchItem" [showRemoveButton]="true"></se-generic-editor-dropdown></ng-container></div></div>`,
        styles: [`se-cms-component-dropdown div.se-actionable-search-item{display:flex;align-items:center;justify-content:space-between;padding:0 0 0 13px}se-cms-component-dropdown se-item-printer{width:100%}`],
        encapsulation: core.ViewEncapsulation.None,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(0, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [Object, smarteditcommons.SystemEventService,
        smarteditcommons.GenericEditorStackService,
        NestedComponentManagementService,
        SelectComponentTypeModalService,
        smarteditcommons.LogService,
        core.ChangeDetectorRef])
], /* @ngInject */ exports.CmsComponentDropdownComponent);

/*
 * Copyright (c) 2022 SAP SE or an SAP affiliate company. All rights reserved.
 */
const OPEN_COMPONENT_EVENT = 'ySEComponentMenuOpen';
const RESET_COMPONENT_MENU_EVENT = 'RESET_COMPONENT_MENU_EVENT';

var AlertTypesMapping;
(function (AlertTypesMapping) {
    AlertTypesMapping["information"] = "showInfo";
    AlertTypesMapping["success"] = "showSuccess";
    AlertTypesMapping["warning"] = "showWarning";
    AlertTypesMapping["error"] = "showDanger";
})(AlertTypesMapping || (AlertTypesMapping = {}));
/**
 * The actionableAlertService is used by external modules to render an
 * Alert structured around a description, an hyperlink label and a custom
 * controller.
 **/
/* @ngInject */ exports.ActionableAlertService = class /* @ngInject */ ActionableAlertService {
    constructor(alertService) {
        this.alertService = alertService;
    }
    /**
     * @param alertContent A JSON object containing the specific configuration to be applied on the actionableAlert.
     * @param alertType A string representing the type of alert to display. The string must match one of the types
     * If the alert type is null, or it doesn't match any of the valid types this method will default to INFO.
     */
    displayActionableAlert(alertContent, alertType) {
        const alertMethodName = this.getMethodNameByAlertType(alertType);
        return this.alertService[alertMethodName](alertContent);
    }
    getMethodNameByAlertType(alertType) {
        if (alertType && AlertTypesMapping[alertType]) {
            return AlertTypesMapping[alertType];
        }
        return AlertTypesMapping.information;
    }
};
exports.ActionableAlertService.$inject = ["alertService"];
/* @ngInject */ exports.ActionableAlertService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.IAlertService])
], /* @ngInject */ exports.ActionableAlertService);

window.__smartedit__.addDecoratorPayload("Component", "PageRestoredAlertComponent", {
    selector: 'se-page-restored-alert-component',
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    template: `<se-actionable-alert
        [description]="message"
        [hyperlinkLabel]="hyperlinkLabel"
        [hyperlinkDetails]="hyperLinkDetails"
        (hyperLinkClick)="onClick()"
    ></se-actionable-alert>`
});
/* @ngInject */ exports.PageRestoredAlertComponent = class /* @ngInject */ PageRestoredAlertComponent {
    constructor(alertRef, experienceService) {
        this.alertRef = alertRef;
        this.experienceService = experienceService;
        this.hyperlinkLabel = 'se.cms.page.restored.alert.info.hyperlink';
        this.message = 'se.cms.page.restored.alert.info.description';
    }
    ngOnInit() {
        const { pageInfo } = this.alertRef.data;
        this.hyperLinkDetails = { pageName: pageInfo.name };
    }
    onClick() {
        const { catalogVersion, pageInfo } = this.alertRef.data;
        this.alertRef.dismiss();
        this.experienceService.loadExperience({
            siteId: catalogVersion.siteId,
            catalogId: catalogVersion.catalogId,
            catalogVersion: catalogVersion.version,
            pageId: pageInfo.uid
        });
    }
};
exports.PageRestoredAlertComponent.$inject = ["alertRef", "experienceService"];
/* @ngInject */ exports.PageRestoredAlertComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-restored-alert-component',
        changeDetection: core.ChangeDetectionStrategy.OnPush,
        template: `<se-actionable-alert
        [description]="message"
        [hyperlinkLabel]="hyperlinkLabel"
        [hyperlinkDetails]="hyperLinkDetails"
        (hyperLinkClick)="onClick()"
    ></se-actionable-alert>`
    }),
    __metadata("design:paramtypes", [core$2.AlertRef, smarteditcommons.IExperienceService])
], /* @ngInject */ exports.PageRestoredAlertComponent);

/* @ngInject */ exports.PageRestoredAlertService = class /* @ngInject */ PageRestoredAlertService {
    constructor(catalogService, actionableAlertService) {
        this.catalogService = catalogService;
        this.actionableAlertService = actionableAlertService;
    }
    displayPageRestoredSuccessAlert(pageInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!pageInfo) {
                throw new Error('[pageRestoredAlertService] - page info not provided.');
            }
            const catalogVersion = yield this.catalogService.getCatalogVersionByUuid(pageInfo.catalogVersion);
            const alertConfig = {
                component: exports.PageRestoredAlertComponent,
                data: {
                    catalogVersion,
                    pageInfo
                }
            };
            return this.actionableAlertService.displayActionableAlert(alertConfig, smarteditcommons.IAlertServiceType.SUCCESS);
        });
    }
};
exports.PageRestoredAlertService.$inject = ["catalogService", "actionableAlertService"];
/* @ngInject */ exports.PageRestoredAlertService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.ICatalogService,
        exports.ActionableAlertService])
], /* @ngInject */ exports.PageRestoredAlertService);

window.__smartedit__.addDecoratorPayload("Component", "ClonePageAlertComponent", {
    selector: 'se-clone-page-alert',
    template: `
        <se-actionable-alert
            [description]="description"
            [descriptionDetails]="descriptionDetails"
            [hyperlinkLabel]="hyperlinkLabel"
            (hyperLinkClick)="onClick()"
        ></se-actionable-alert>
    `,
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    providers: [smarteditcommons.L10nPipe]
});
/* @ngInject */ exports.ClonePageAlertComponent = class /* @ngInject */ ClonePageAlertComponent {
    constructor(alertRef, experienceService, cdr, l10n) {
        this.alertRef = alertRef;
        this.experienceService = experienceService;
        this.cdr = cdr;
        this.l10n = l10n;
        this.description = 'se.cms.clonepage.alert.info.description';
        this.hyperlinkLabel = 'se.cms.clonepage.alert.info.hyperlink';
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            ({
                clonedPageInfo: this.clonedPageInfo,
                catalogVersion: this.catalogVersion
            } = this.alertRef.data);
            this.description = 'se.cms.clonepage.alert.info.description';
            this.descriptionDetails = {
                catalogName: yield this.getTranslatedName(this.catalogVersion.catalogName),
                catalogVersion: this.catalogVersion.version
            };
            this.hyperlinkLabel = 'se.cms.clonepage.alert.info.hyperlink';
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    onClick() {
        if (smarteditcommons.stringUtils.isBlank(this.clonedPageInfo.uid)) {
            throw new Error("ClonePageAlertService.displayClonePageAlert - missing required parameter 'uid'");
        }
        this.experienceService.loadExperience({
            siteId: this.catalogVersion.siteId,
            catalogId: this.catalogVersion.catalogId,
            catalogVersion: this.catalogVersion.version,
            pageId: this.clonedPageInfo.uid
        });
    }
    getTranslatedName(name) {
        return this.l10n.transform(name).pipe(operators.take(1)).toPromise();
    }
};
exports.ClonePageAlertComponent.$inject = ["alertRef", "experienceService", "cdr", "l10n"];
/* @ngInject */ exports.ClonePageAlertComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-clone-page-alert',
        template: `
        <se-actionable-alert
            [description]="description"
            [descriptionDetails]="descriptionDetails"
            [hyperlinkLabel]="hyperlinkLabel"
            (hyperLinkClick)="onClick()"
        ></se-actionable-alert>
    `,
        changeDetection: core.ChangeDetectionStrategy.OnPush,
        providers: [smarteditcommons.L10nPipe]
    }),
    __metadata("design:paramtypes", [core$2.AlertRef,
        smarteditcommons.IExperienceService,
        core.ChangeDetectorRef,
        smarteditcommons.L10nPipe])
], /* @ngInject */ exports.ClonePageAlertComponent);

/* @ngInject */ exports.ClonePageAlertService = class /* @ngInject */ ClonePageAlertService {
    constructor(actionableAlertService, catalogService) {
        this.actionableAlertService = actionableAlertService;
        this.catalogService = catalogService;
    }
    /**
     * Displays an alert containing an hyperlink allowing for the user
     * to navigate to the newly cloned page.
     */
    displayClonePageAlert(clonedPageInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            const catalogVersion = yield this.catalogService.getCatalogVersionByUuid(clonedPageInfo.catalogVersion);
            return this.actionableAlertService.displayActionableAlert({
                component: exports.ClonePageAlertComponent,
                mousePersist: true,
                data: {
                    catalogVersion,
                    clonedPageInfo
                }
            });
        });
    }
};
exports.ClonePageAlertService.$inject = ["actionableAlertService", "catalogService"];
/* @ngInject */ exports.ClonePageAlertService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [exports.ActionableAlertService,
        smarteditcommons.ICatalogService])
], /* @ngInject */ exports.ClonePageAlertService);

var AlertMessage;
(function (AlertMessage) {
    AlertMessage["HIDDEN"] = "se.cms.component.visibility.alert.description.hidden";
    AlertMessage["RESTRICTED"] = "se.cms.component.visibility.alert.description.restricted";
})(AlertMessage || (AlertMessage = {}));
/* @ngInject */ exports.ComponentVisibilityAlertService = class /* @ngInject */ ComponentVisibilityAlertService extends cmscommons.IComponentVisibilityAlertService {
    constructor(sharedDataService, alertService, actionableAlertService) {
        super();
        this.sharedDataService = sharedDataService;
        this.alertService = alertService;
        this.actionableAlertService = actionableAlertService;
    }
    checkAndAlertOnComponentVisibility(component) {
        return __awaiter(this, void 0, void 0, function* () {
            const shouldShowAlert = !component.visible || component.restricted;
            if (!shouldShowAlert) {
                return;
            }
            const experience = (yield this.sharedDataService.get(smarteditcommons.EXPERIENCE_STORAGE_KEY));
            const message = !component.visible ? AlertMessage.HIDDEN : AlertMessage.RESTRICTED;
            const isExternal = component.catalogVersion !== experience.pageContext.catalogVersionUuid;
            if (isExternal) {
                this.alertService.showAlert({
                    message
                });
            }
            else {
                const actionableAlertConf = {
                    component: cmscommons.ComponentVisibilityAlertComponent,
                    duration: 6000,
                    data: {
                        component,
                        message
                    }
                };
                this.actionableAlertService.displayActionableAlert(actionableAlertConf, smarteditcommons.IAlertServiceType.INFO);
            }
        });
    }
};
exports.ComponentVisibilityAlertService.$inject = ["sharedDataService", "alertService", "actionableAlertService"];
/* @ngInject */ exports.ComponentVisibilityAlertService = __decorate([
    smarteditcommons.SeDowngradeService(cmscommons.IComponentVisibilityAlertService),
    smarteditcommons.GatewayProxied('checkAndAlertOnComponentVisibility'),
    __metadata("design:paramtypes", [smarteditcommons.ISharedDataService,
        smarteditcommons.IAlertService,
        exports.ActionableAlertService])
], /* @ngInject */ exports.ComponentVisibilityAlertService);

/* @ngInject */ exports.ComponentSharedService = class /* @ngInject */ ComponentSharedService extends cmscommons.IComponentSharedService {
};
/* @ngInject */ exports.ComponentSharedService = __decorate([
    smarteditcommons.SeDowngradeService(cmscommons.IComponentSharedService),
    smarteditcommons.GatewayProxied()
], /* @ngInject */ exports.ComponentSharedService);

/*
 * Copyright (c) 2022 SAP SE or an SAP affiliate company. All rights reserved.
 */
const CMS_LINK_TO_RELOAD_STRUCTURE_EVENT_ID = 'cms-link-to-reload-structure';
const CMS_CLEAR_MEDIA_CONTAINER_SELECTED_OPTION = 'clear_mediaContainer_selected_option';
const MAX_UPLOAD_FILE_SIZE = 'maxUploadFileSize';
const RULE_PERMISSION_READ_PAGE = 'se.read.page';
const RULE_PERMISSION_READ_SLOT = 'se.read.slot';
const RULE_PERMISSION_READ_COMPONENT = 'se.read.component';
const RULE_PERMISSION_READ_CURRENT_CATALOG_VERSION = 'se.read.current.catalog.version';
const RULE_PERMISSION_WRITE_PAGE = 'se.write.page';
const RULE_PERMISSION_WRITE_SLOT = 'se.write.slot';
const RULE_PERMISSION_WRITE_COMPONENT = 'se.write.component';
const RULE_PERMISSION_WRITE_TO_CURRENT_CATALOG_VERSION = 'se.write.to.current.catalog.version';
const RULE_PERMISSION_CATALOG_NON_ACTIVE = 'se.content.catalog.non.active';
const RULE_PERMISSION_NOT_VERSIONING_PERSPECTIVE = 'se.not.versioning.perspective';
const RULE_PERMISSION_VERSION_PAGE_SELECTED = 'se.version.page.selected';
const RULE_PERMISSION_CURRENT_PAGE_HAS_ACTIVE_WORKFLOW = 'se.current.page.has.active.workflow';
const RULE_PERMISSION_HAS_CHANGE_TYPE_PERMISSION_ON_CURRENT_PAGE = 'se.has.change.type.permissions.on.current.page';
const RULE_PERMISSION_HAS_READ_TYPE_PERMISSION_ON_CURRENT_PAGE = 'se.has.read.type.permissions.on.current.page';
const RULE_PERMISSION_HAS_READ_PERMISSION_ON_VERSION_TYPE = 'se.has.read.permission.on.version.type';
const RULE_PERMISSION_HAS_CREATE_PERMISSION_ON_VERSION_TYPE = 'se.has.create.permission.on.version.type';
const RULE_PERMISSION_HAS_CHANGE_PERMISSION_ON_WORKFLOW_TYPE = 'se.has.change.permission.on.workflow.type';
const RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_PAGE_IN_WORKFLOW = 'se.current.user.can.act.on.page.in.workflow';
const RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_WORKFLOW_CURRENT_ACTION = 'se.current.user.can.act.on.workflow.current.action';
const RULE_PERMISSION_SYNC_CATALOG = 'se.sync.catalog';
const RULE_PERMISSION_PAGE_BELONGS_TO_EXPERIENCE = 'se.page.belongs.to.experience';

window.__smartedit__.addDecoratorPayload("Component", "GenericEditorModalComponent", {
    selector: 'se-generic-editor-modal',
    template: `
        <se-message
            class="se-ge-modal--messages"
            *ngIf="showDisclaimer"
            type="info"
            messageId="VisibilityTab.DisplayComponentOffDisclaimer"
        >
            <ng-container se-message-description>
                {{ 'se.cms.editortabset.visibilitytab.disclaimer' | translate }}
            </ng-container>
        </se-message>

        <ng-container *ngIf="data && data.messages">
            <se-message
                class="se-ge-modal--messages"
                *ngFor="let msg of data.messages; let i = index"
                [type]="msg.type"
                messageId="generic-editor-model-message-{{ i }}"
            >
                <ng-container se-message-description> {{ msg.message }} </ng-container>
            </se-message>
        </ng-container>

        <se-generic-editor
            *ngIf="isSetupCompleted"
            [id]="genericEditorId"
            [smarteditComponentId]="data.componentUuid"
            [smarteditComponentType]="data.componentType"
            [structure]="structure"
            [structureApi]="structureApi"
            [content]="data.content"
            [contentApi]="contentApi"
            [(submit)]="controls.submit"
            [(reset)]="controls.reset"
            [(isDirty)]="controls.isDirty"
            [editorStackId]="editorStackId"
            (getApi)="getApi($event)"
        >
        </se-generic-editor>
    `
});
/* @ngInject */ exports.GenericEditorModalComponent = class /* @ngInject */ GenericEditorModalComponent {
    constructor(modalManager, confirmationModalService, crossFrameEventService, systemEventService) {
        this.modalManager = modalManager;
        this.confirmationModalService = confirmationModalService;
        this.crossFrameEventService = crossFrameEventService;
        this.systemEventService = systemEventService;
        this.data = {};
        this.controls = {};
        this.genericEditorId = smarteditcommons.stringUtils.generateIdentifier();
        this.showDisclaimer = false;
        this.STRUCTURE_API_BASE_URL = `${cmscommons.TYPES_RESOURCE_URI}?code=:smarteditComponentType&mode=:structureApiMode`;
        this.isSetupCompleted = false;
        this.isReset = false;
        this.isEscapeInProgress = false;
    }
    onEscapeDown() {
        if (this.isEscapeInProgress) {
            return;
        }
        this.onEscapeClicked();
    }
    getApi(genericEditorAPI) {
        this.controls.genericEditorAPI = genericEditorAPI;
        if (this.data.targetedQualifier) {
            genericEditorAPI.switchToTabContainingQualifier(this.data.targetedQualifier);
        }
        if (this.data.initialDirty) {
            genericEditorAPI.considerFormDirty();
        }
    }
    onSave() {
        return this.controls.submit().then((item) => {
            this.crossFrameEventService.publish(cmscommons.CMSITEMS_UPDATE_EVENT);
            if (this.saveCallback) {
                this.saveCallback(item);
            }
            this.removeEventListeners();
            return item;
        });
    }
    onCancel() {
        return new Promise((resolve, reject) => {
            if (this.genericEditorIsDirty() && !this.isReset) {
                this.confirmationModalService.confirm({
                    description: 'se.editor.cancel.confirm'
                }).then(() => {
                    this.controls.reset().then(() => {
                        this.markAsReset();
                        this.removeEventListeners();
                        resolve();
                    }, () => {
                        reject();
                    });
                    this.crossFrameEventService.publish('GENERIC_EDITOR_CANCEL', {
                        confirmed: true
                    });
                }, () => {
                    reject();
                    this.crossFrameEventService.publish('GENERIC_EDITOR_CANCEL', {
                        confirmed: false
                    });
                });
            }
            else {
                this.removeEventListeners();
                resolve();
            }
        });
    }
    setup() {
        this.structure = this.data.structure;
        if (!this.structure) {
            this.structureApi = this.getStructureApiByMode('DEFAULT');
            if (this.isGenericEditorInReadOnlyMode()) {
                this.structureApi = this.applyReadOnlyModeToStructureApiUrl(this.structureApi);
            }
        }
        else if (this.isGenericEditorInReadOnlyMode()) {
            this.structure = this.makeStructureReadOnly(this.structure);
        }
        this.changeStructureEventListener = this.systemEventService.subscribe(CMS_LINK_TO_RELOAD_STRUCTURE_EVENT_ID, (event, data) => this.onChangeStructureEvent(event, data));
        this.unrelatedValidationErrorsEvent = this.systemEventService.subscribe(smarteditcommons.GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT, (event, data) => this.onUnrelatedErrors(event, data));
        this.contentApi =
            this.data.contentApi || `/cmswebservices/v1/sites/${smarteditcommons.CONTEXT_SITE_ID}/cmsitems`;
        this.modalManager.setDismissCallback(() => this.onCancel());
        this.modalManager.addButtons([
            {
                id: 'save',
                label: this.data.saveLabel || 'se.cms.component.confirmation.modal.save',
                style: smarteditcommons.ModalButtonStyle.Primary,
                action: smarteditcommons.ModalButtonAction.Close,
                callback: () => rxjs.from(this.onSave()),
                disabledFn: () => (this.controls.genericEditorAPI &&
                    this.controls.genericEditorAPI.isSubmitDisabled()) ||
                    this.isGenericEditorInReadOnlyMode()
            },
            {
                id: 'cancel',
                label: this.data.cancelLabel || 'se.cms.component.confirmation.modal.cancel',
                style: smarteditcommons.ModalButtonStyle.Default,
                action: smarteditcommons.ModalButtonAction.Dismiss,
                callback: () => rxjs.from(this.onCancel())
            }
        ]);
        this.isSetupCompleted = true;
    }
    /**
     * Method makes each attribute of the structure non editable.
     */
    makeStructureReadOnly(structure) {
        structure.attributes = structure.attributes || [];
        structure.attributes.forEach(function (element) {
            element.editable = false;
        });
        return structure;
    }
    /**
     * Method verifies whether the generic editor is in read only mode or not.
     * Returns TRUE if the generic editor is in read only mode, FALSE otherwise.
     */
    isGenericEditorInReadOnlyMode() {
        return !!this.data.readOnlyMode;
    }
    /**
     * Method returns generic editor content object.
     */
    getGenericEditorContent() {
        return this.controls.genericEditorAPI && this.controls.genericEditorAPI.getContent();
    }
    /**
     * Method verifies whether the generic editor is in dirty state or not.
     * Returns TRUE if the generic editor is in dirty state, FALSE otherwise.
     */
    genericEditorIsDirty() {
        return this.controls.isDirty && this.controls.isDirty();
    }
    onChangeStructureEvent(eventId, payload) {
        // Structure is reloaded only for the Generic Editor that owns the component where this event came from.
        // This is done to avoid contaminating editors in a nested set-up.
        if (this.genericEditorId === payload.editorId) {
            if (payload.structureApiMode) {
                this.structure = null;
                this.structureApi = this.getStructureApiByMode(payload.structureApiMode);
                if (this.isGenericEditorInReadOnlyMode()) {
                    this.structureApi = this.applyReadOnlyModeToStructureApiUrl(this.structureApi);
                }
            }
            else if (payload.structure) {
                this.structureApi = null;
                this.structure = payload.structure;
                if (this.isGenericEditorInReadOnlyMode()) {
                    this.structure = this.makeStructureReadOnly(this.structure);
                }
            }
            this.data.content = payload.content;
        }
    }
    onUnrelatedErrors(eventId, eventData) {
        if (eventData.sourceGenericEditorId === this.data.componentUuid && this.errorCallback) {
            this.errorCallback(eventData.messages, this);
        }
    }
    /**
     * Converts the structure api url to read only mode. All fields return in read only mode will not be editable.
     */
    applyReadOnlyModeToStructureApiUrl(structureApiUrl) {
        return `${structureApiUrl}&readOnly=true`;
    }
    getStructureApiByMode(structureApiMode) {
        return this.STRUCTURE_API_BASE_URL.replace(/:structureApiMode/gi, structureApiMode);
    }
    removeEventListeners() {
        this.unrelatedValidationErrorsEvent();
        this.changeStructureEventListener();
    }
    ngOnInit() {
        this.modalManager.getModalData().subscribe((config) => {
            this.data = config.data;
            this.saveCallback = config.saveCallback;
            this.errorCallback = config.errorCallback;
            this.editorStackId = config.data.editorStackId;
            if (!this.isSetupCompleted) {
                this.setup();
            }
        });
    }
    markAsReset() {
        this.isReset = true;
    }
    onEscapeClicked() {
        this.isEscapeInProgress = true;
        this.onCancel()
            .then(() => this.modalManager.dismiss())
            .finally(() => {
            this.isEscapeInProgress = false;
        });
    }
};
exports.GenericEditorModalComponent.$inject = ["modalManager", "confirmationModalService", "crossFrameEventService", "systemEventService"];
__decorate([
    core.HostListener('document:keyup.escape'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], /* @ngInject */ exports.GenericEditorModalComponent.prototype, "onEscapeDown", null);
/* @ngInject */ exports.GenericEditorModalComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-generic-editor-modal',
        template: `
        <se-message
            class="se-ge-modal--messages"
            *ngIf="showDisclaimer"
            type="info"
            messageId="VisibilityTab.DisplayComponentOffDisclaimer"
        >
            <ng-container se-message-description>
                {{ 'se.cms.editortabset.visibilitytab.disclaimer' | translate }}
            </ng-container>
        </se-message>

        <ng-container *ngIf="data && data.messages">
            <se-message
                class="se-ge-modal--messages"
                *ngFor="let msg of data.messages; let i = index"
                [type]="msg.type"
                messageId="generic-editor-model-message-{{ i }}"
            >
                <ng-container se-message-description> {{ msg.message }} </ng-container>
            </se-message>
        </ng-container>

        <se-generic-editor
            *ngIf="isSetupCompleted"
            [id]="genericEditorId"
            [smarteditComponentId]="data.componentUuid"
            [smarteditComponentType]="data.componentType"
            [structure]="structure"
            [structureApi]="structureApi"
            [content]="data.content"
            [contentApi]="contentApi"
            [(submit)]="controls.submit"
            [(reset)]="controls.reset"
            [(isDirty)]="controls.isDirty"
            [editorStackId]="editorStackId"
            (getApi)="getApi($event)"
        >
        </se-generic-editor>
    `
    }),
    __metadata("design:paramtypes", [smarteditcommons.ModalManagerService,
        smarteditcommons.IConfirmationModalService,
        smarteditcommons.CrossFrameEventService,
        smarteditcommons.SystemEventService])
], /* @ngInject */ exports.GenericEditorModalComponent);

/**
 * @ngdoc service
 * @name CatalogVersionRestService
 * @description
 *
 * Provides REST services for the CMS catalog version endpoint
 */
let /* @ngInject */ CatalogVersionRestService = class /* @ngInject */ CatalogVersionRestService {
    constructor(restServiceFactory) {
        this.restServiceFactory = restServiceFactory;
        this.URI = `/cmswebservices/v1/sites/:${smarteditcommons.CONTEXT_SITE_ID}/catalogs/:${smarteditcommons.CONTEXT_CATALOG}/versions/:${smarteditcommons.CONTEXT_CATALOG_VERSION}/targets?mode=cloneableTo`;
    }
    /**
     * @ngdoc method
     * @name CatalogVersionRestService#getCloneableTargets
     * @methodOf CatalogVersionRestService
     *
     * @description
     * Fetches all cloneable target catalog versions for a given site+catalog+catalogversion
     *
     * @param {Object} uriContext A {@link resourceLocationsModule.object:UriContext UriContext}
     *
     * @returns {Object} A JSON object with a single field 'versions' containing a list of catalog versions, or an empty list.
     */
    getCloneableTargets(uriContext) {
        const rest = this.restServiceFactory.get(this.URI);
        return rest.get(uriContext);
    }
};
CatalogVersionRestService.$inject = ["restServiceFactory"];
/* @ngInject */ CatalogVersionRestService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.RestServiceFactory])
], /* @ngInject */ CatalogVersionRestService);

let /* @ngInject */ PageRestrictionsRestService = class /* @ngInject */ PageRestrictionsRestService {
    constructor(restServiceFactory) {
        this.restServiceFactory = restServiceFactory;
        this.contextualPageRestrictionsRestService = this.restServiceFactory.get(cmscommons.CONTEXTUAL_PAGES_RESTRICTIONS_RESOURCE_URI);
        this.pageRestrictionsRestService = this.restServiceFactory.get(cmscommons.PAGES_RESTRICTIONS_RESOURCE_URI);
    }
    getPagesRestrictionsForPageId(pageId) {
        return this.contextualPageRestrictionsRestService.get({
            pageId
        });
    }
    getPagesRestrictionsForCatalogVersion(siteUID, catalogId, catalogVersion) {
        return this.pageRestrictionsRestService.get({
            siteUID,
            catalogId,
            catalogVersion
        });
    }
};
PageRestrictionsRestService.$inject = ["restServiceFactory"];
/* @ngInject */ PageRestrictionsRestService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.RestServiceFactory])
], /* @ngInject */ PageRestrictionsRestService);

let /* @ngInject */ PageTypesRestrictionTypesRestService = class /* @ngInject */ PageTypesRestrictionTypesRestService {
    constructor(restServiceFactory) {
        this.restServiceFactory = restServiceFactory;
        this.restService = this.restServiceFactory.get(cmscommons.PAGE_TYPES_RESTRICTION_TYPES_URI);
    }
    getPageTypesRestrictionTypes() {
        return this.restService.get();
    }
};
PageTypesRestrictionTypesRestService.$inject = ["restServiceFactory"];
/* @ngInject */ PageTypesRestrictionTypesRestService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.RestServiceFactory])
], /* @ngInject */ PageTypesRestrictionTypesRestService);

let /* @ngInject */ PageContentSlotsComponentsRestService = class /* @ngInject */ PageContentSlotsComponentsRestService extends cmscommons.IPageContentSlotsComponentsRestService {
    constructor() {
        super();
    }
};
/* @ngInject */ PageContentSlotsComponentsRestService = __decorate([
    smarteditcommons.GatewayProxied('clearCache', 'getSlotsToComponentsMapForPageUid'),
    smarteditcommons.SeDowngradeService(cmscommons.IPageContentSlotsComponentsRestService),
    __metadata("design:paramtypes", [])
], /* @ngInject */ PageContentSlotsComponentsRestService);

/**
 * Provides REST API for the CMS fallbacks endpoint.
 *
 * Used to fetch Primary Pages IDs for Variation Pages.
 */
let /* @ngInject */ PagesFallbacksRestService = class /* @ngInject */ PagesFallbacksRestService {
    constructor(restServiceFactory) {
        this.restServiceFactory = restServiceFactory;
        this.fallbacksForPageIdResource = restServiceFactory.get(this.getUri());
    }
    getFallbacksForPageId(pageId) {
        return this.fallbacksForPageIdResource.get({ pageId }).then((response) => response.uids);
    }
    getFallbacksForPageIdAndContext(pageId, uriContext) {
        const uri = this.getUri(uriContext[smarteditcommons.CONTEXT_SITE_ID], uriContext[smarteditcommons.CONTEXT_CATALOG], uriContext[smarteditcommons.CONTEXT_CATALOG_VERSION]);
        const resource = this.restServiceFactory.get(uri);
        return resource.get({ pageId }).then((response) => response.uids);
    }
    getUri(siteId = smarteditcommons.PAGE_CONTEXT_SITE_ID, catalogId = smarteditcommons.PAGE_CONTEXT_CATALOG, catalogVersionId = smarteditcommons.PAGE_CONTEXT_CATALOG_VERSION) {
        return `/cmswebservices/v1/sites/${siteId}/catalogs/${catalogId}/versions/${catalogVersionId}/pages/:pageId/fallbacks`;
    }
};
PagesFallbacksRestService.$inject = ["restServiceFactory"];
/* @ngInject */ PagesFallbacksRestService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.RestServiceFactory])
], /* @ngInject */ PagesFallbacksRestService);

/** Provides REST services for the CMS pages rest endpoint. */
let /* @ngInject */ PagesRestService = class /* @ngInject */ PagesRestService {
    constructor(restServiceFactory) {
        this.restServiceFactory = restServiceFactory;
        this.URI = `/cmswebservices/v1/sites/${smarteditcommons.PAGE_CONTEXT_SITE_ID}/catalogs/${smarteditcommons.PAGE_CONTEXT_CATALOG}/versions/${smarteditcommons.PAGE_CONTEXT_CATALOG_VERSION}/pages/:pageUid`;
    }
    /**
     * Fetches a list of pages for a given array of UIDs.
     * It uses the current site, catalog and catalog version from the session.
     *
     * @returns A promise resolving to a list of pages, or an empty list.
     */
    get(uids) {
        return this.restServiceFactory
            .get(this.URI, 'pageUid')
            .get({ uids })
            .then((response) => response.pages);
    }
    /**
     * Fetches a page for a given UID.
     * It uses the current site, catalog and catalog version from the session.
     *
     * @param pageUid A page UID of the page to fetch
     */
    getById(pageUid) {
        return this.restServiceFactory.get(this.URI, 'pageUid').get({ pageUid });
    }
    /**
     * Updates a page for a given site, catalog, and catalog version.
     * It uses the current site, catalog and catalog version from the session.
     *
     * @param pageUid The page UID of the page to update.
     * @param payload The page object to be applied to the page resource as it exists on the backend.
     *
     * @returns A promise that resolves to a JSON object representing the updated page.
     */
    update(pageUid, payload) {
        const uri = new smarteditcommons.URIBuilder(this.URI).replaceParams(payload).build();
        const extendedParams = lodash.assign({
            pageUid
        }, payload);
        return this.restServiceFactory.get(uri, 'pageUid').update(extendedParams);
    }
};
PagesRestService.$inject = ["restServiceFactory"];
/* @ngInject */ PagesRestService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.RestServiceFactory])
], /* @ngInject */ PagesRestService);

/**
 * Provides REST API for the CMS variations endpoint.
 *
 * Used on: "Pages" page.
 */
let /* @ngInject */ PagesVariationsRestService = class /* @ngInject */ PagesVariationsRestService {
    constructor(restServiceFactory) {
        this.URI = `/cmswebservices/v1/sites/${smarteditcommons.PAGE_CONTEXT_SITE_ID}/catalogs/${smarteditcommons.PAGE_CONTEXT_CATALOG}/versions/${smarteditcommons.PAGE_CONTEXT_CATALOG_VERSION}/pages/:pageId/variations`;
        this.resource = restServiceFactory.get(this.URI);
    }
    /**
     * @returns A promise resolving to a list of variation page IDs.
     */
    getVariationsForPrimaryPageId(pageId) {
        return this.resource.get({ pageId }).then((response) => response.uids);
    }
};
PagesVariationsRestService.$inject = ["restServiceFactory"];
/* @ngInject */ PagesVariationsRestService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.RestServiceFactory])
], /* @ngInject */ PagesVariationsRestService);

/**
 * A service used to retrive all supported page types configured on the platform, and caches them for the duration of the session.
 */
let /* @ngInject */ PageTypeService = class /* @ngInject */ PageTypeService {
    constructor(restServiceFactory) {
        this.pageTypeRestService = restServiceFactory.get(cmscommons.PAGE_TYPES_URI);
    }
    /**
     * Returns a list of page type descriptor objects.
     */
    getPageTypes() {
        this.pageTypesResponse = this.pageTypesResponse || this.pageTypeRestService.get();
        return this.pageTypesResponse.then((response) => response.pageTypes);
    }
};
PageTypeService.$inject = ["restServiceFactory"];
/* @ngInject */ PageTypeService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.RestServiceFactory])
], /* @ngInject */ PageTypeService);

let /* @ngInject */ RestrictionTypesRestService = class /* @ngInject */ RestrictionTypesRestService {
    constructor(restServiceFactory) {
        this.restServiceFactory = restServiceFactory;
        this.restrictionTypesRestService = this.restServiceFactory.get(cmscommons.RESTRICTION_TYPES_URI);
    }
    getRestrictionTypes() {
        return this.restrictionTypesRestService.get();
    }
};
RestrictionTypesRestService.$inject = ["restServiceFactory"];
/* @ngInject */ RestrictionTypesRestService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.RestServiceFactory])
], /* @ngInject */ RestrictionTypesRestService);

class ModeManager {
    constructor(modes) {
        this.modes = modes;
    }
    validateMode(mode) {
        if (!this.modes.includes(mode)) {
            throw new Error(`ModeManager.validateMode() - mode [${mode}] not in list of supported modes: ${this.modes}`);
        }
        return true;
    }
}
let /* @ngInject */ StructureModeManagerFactory = class /* @ngInject */ StructureModeManagerFactory {
    createModeManager(modes) {
        return new ModeManager(modes);
    }
};
/* @ngInject */ StructureModeManagerFactory = __decorate([
    smarteditcommons.SeDowngradeService()
], /* @ngInject */ StructureModeManagerFactory);

let /* @ngInject */ StructuresRestService = class /* @ngInject */ StructuresRestService {
    constructor(operationContextService) {
        this.TYPE_PLACEHOLDER = ':smarteditComponentType';
        this.URI = `${smarteditcommons.TYPES_RESOURCE_URI}/`;
        operationContextService.register(this.URI, smarteditcommons.OPERATION_CONTEXT.CMS);
    }
    /**
     * Returns Types resource URI for given mode. If no type is given, it will use a placeholder for Item Type Code.
     *
     * E.g.
     * cmswebservices/v1/types?code=CMSCategoryRestriction&mode=ADD
     */
    getUriForContext(mode, type) {
        const typePlaceholder = type || this.TYPE_PLACEHOLDER;
        const uri = `${smarteditcommons.TYPES_RESOURCE_URI}?code=${typePlaceholder}&mode=${mode.toUpperCase()}`;
        return uri;
    }
};
StructuresRestService.$inject = ["operationContextService"];
/* @ngInject */ StructuresRestService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.OperationContextService])
], /* @ngInject */ StructuresRestService);

/**
 * Used for fetching CMS Item Structures.
 */
let /* @ngInject */ TypeStructureRestService = class /* @ngInject */ TypeStructureRestService {
    constructor(restServiceFactory) {
        this.structureRestService = restServiceFactory.get(smarteditcommons.TYPES_RESOURCE_URI);
    }
    /**
     * Fetches the type structure (fields) for CMS pages for a given Page Type.
     */
    getStructureByType(typeCode) {
        return this.structureRestService
            .getById(typeCode)
            .then((structure) => structure.attributes);
    }
    /**
     * Fetches the type structure (fields) for CMS pages for a given Page Type and mode.
     */
    getStructureByTypeAndMode(typeCode, mode, getWholeStructure = false) {
        return this.structureRestService
            .get({
            code: typeCode,
            mode
        })
            .then((result) => {
            const structure = result.componentTypes[0];
            return !structure || getWholeStructure ? structure : structure.attributes;
        });
    }
    /**
     * Fetches structures supported in the given category.
     */
    getStructuresByCategory(category) {
        return this.structureRestService
            .get({
            category
        })
            .then((result) => result.componentTypes);
    }
};
TypeStructureRestService.$inject = ["restServiceFactory"];
/* @ngInject */ TypeStructureRestService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.RestServiceFactory])
], /* @ngInject */ TypeStructureRestService);

/**
 * Service that concerns business logic tasks related to CMS restrictions for CMS pages.
 */
/* @ngInject */ exports.PageRestrictionsService = class /* @ngInject */ PageRestrictionsService {
    constructor(pageRestrictionsRestService) {
        this.pageRestrictionsRestService = pageRestrictionsRestService;
    }
    /**
     * @returns The number of restrictions applied to the page for the given page UID.
     */
    getPageRestrictionsCountForPageUID(pageUID) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.pageRestrictionsRestService.getPagesRestrictionsForPageId(pageUID);
            return response.pageRestrictionList.length;
        });
    }
};
exports.PageRestrictionsService.$inject = ["pageRestrictionsRestService"];
/* @ngInject */ exports.PageRestrictionsService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [PageRestrictionsRestService])
], /* @ngInject */ exports.PageRestrictionsService);

let /* @ngInject */ DisplayConditionsFacade = class /* @ngInject */ DisplayConditionsFacade {
    constructor(pageService, pageRestrictionsService, logService) {
        this.pageService = pageService;
        this.pageRestrictionsService = pageRestrictionsService;
        this.logService = logService;
    }
    getPageInfoForPageUid(pageId) {
        return __awaiter(this, void 0, void 0, function* () {
            const pagePromise = this.pageService.getPageById(pageId);
            const displayConditionsPromise = this.pageService.isPagePrimary(pageId);
            const [page, isPrimary] = yield Promise.all([pagePromise, displayConditionsPromise]);
            return {
                pageName: page.name,
                pageType: page.typeCode,
                isPrimary
            };
        });
    }
    getVariationsForPageUid(primaryPageId) {
        return __awaiter(this, void 0, void 0, function* () {
            const variationPages = yield this.pageService.getVariationPages(primaryPageId);
            if (variationPages.length === 0) {
                return [];
            }
            const restrictionCounts = yield Promise.all(variationPages.map((variationPage) => this.pageRestrictionsService.getPageRestrictionsCountForPageUID(variationPage.uid)));
            return variationPages.map((variationPage, index) => ({
                pageName: variationPage.name,
                creationDate: variationPage.creationtime,
                restrictions: restrictionCounts[index]
            }));
        });
    }
    updatePage(pageId, pageData) {
        return this.pageService.updatePageById(pageId, pageData);
    }
    isPagePrimary(pageId) {
        return this.pageService.isPagePrimary(pageId);
    }
    getPrimaryPageForVariationPage(variationPageId) {
        return this.pageService.getPrimaryPage(variationPageId).then((primaryPage) => ({
            uid: primaryPage.uid,
            name: primaryPage.name,
            label: primaryPage.label
        }));
    }
    getPrimaryPagesForPageType(pageTypeCode, uriParams, fetchPageParams) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const page = yield this.pageService.getPaginatedPrimaryPagesForPageType(pageTypeCode, uriParams, fetchPageParams);
                return {
                    pagination: page.pagination,
                    results: page.response.map((rawPage) => ({
                        id: rawPage.uid,
                        label: rawPage.name || rawPage.label
                    }))
                };
            }
            catch (error) {
                this.logService.warn(`[getPrimaryPagesForPageType] - Cannot retrieve list of primary pages. ${error}`);
            }
        });
    }
};
DisplayConditionsFacade.$inject = ["pageService", "pageRestrictionsService", "logService"];
/* @ngInject */ DisplayConditionsFacade = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.IPageService,
        exports.PageRestrictionsService,
        smarteditcommons.LogService])
], /* @ngInject */ DisplayConditionsFacade);

/**
 * Initializes a Page data such as type, name for Primary or Variation Page.
 * Used as a local instance of DisplayConditionsEditor.
 */
/* @ngInject */ exports.DisplayConditionsEditorModel = class /* @ngInject */ DisplayConditionsEditorModel {
    constructor(displayConditionsFacade) {
        this.displayConditionsFacade = displayConditionsFacade;
        this.variations = [];
    }
    initModel(pageUid) {
        return __awaiter(this, void 0, void 0, function* () {
            this.pageUid = pageUid;
            const page = yield this.displayConditionsFacade.getPageInfoForPageUid(pageUid);
            ({ pageName: this.pageName, pageType: this.pageType, isPrimary: this.isPrimary } = page);
            if (this.isPrimary) {
                return this.initModelForPrimary(pageUid);
            }
            return this.initModelForVariation(pageUid);
        });
    }
    initModelForPrimary(pageUid) {
        return __awaiter(this, void 0, void 0, function* () {
            this.variations = yield this.displayConditionsFacade.getVariationsForPageUid(pageUid);
        });
    }
    initModelForVariation(pageUid) {
        return __awaiter(this, void 0, void 0, function* () {
            this.isAssociatedPrimaryReadOnly = this.pageType !== 'ContentPage';
            const associatedPrimaryPage = yield this.displayConditionsFacade.getPrimaryPageForVariationPage(pageUid);
            this.associatedPrimaryPage = associatedPrimaryPage;
            this.originalPrimaryPage = associatedPrimaryPage;
        });
    }
};
exports.DisplayConditionsEditorModel.$inject = ["displayConditionsFacade"];
/* @ngInject */ exports.DisplayConditionsEditorModel = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [DisplayConditionsFacade])
], /* @ngInject */ exports.DisplayConditionsEditorModel);

/**
 * Expose through angular the event for sendEventShowReplaceParentHomePageInfo()
 */
const CMS_EVENT_SHOW_REPLACE_PARENT_HOMEPAGE_INFO = 'CMS_EVENT_SHOW_REPLACE_PARENT_HOMEPAGE_INFO';
/** @internal */
/**
 * Expose through angular the event for sendEventHideReplaceParentHomePageInfo()
 */
const CMS_EVENT_HIDE_REPLACE_PARENT_HOMEPAGE_INFO = 'CMS_EVENT_HIDE_REPLACE_PARENT_HOMEPAGE_INFO';
(function (CatalogHomepageDetailsStatus) {
    // Status is being calculated
    CatalogHomepageDetailsStatus["PENDING"] = "PENDING";
    // No current homepage for the given catalog version
    CatalogHomepageDetailsStatus["NO_HOMEPAGE"] = "NO_HOMEPAGE";
    // There is a homepage is in the given catalog version (not inherited)
    CatalogHomepageDetailsStatus["LOCAL"] = "LOCAL";
    // The old homepage is in the given catalog version
    CatalogHomepageDetailsStatus["OLD"] = "OLD";
    // There is a homepage, but it is inherited from a parent catalog
    CatalogHomepageDetailsStatus["PARENT"] = "PARENT";
})(exports.CatalogHomepageDetailsStatus || (exports.CatalogHomepageDetailsStatus = {}));
(function (HomepageType) {
    /**
     * An enum value of type HomepageType describing if a cms page was previously a homepage.
     */
    HomepageType["OLD"] = "old";
    /**
     * An enum value of type HomepageType describing if a cms page is a current homepage.
     */
    HomepageType["CURRENT"] = "current";
    /**
     * An enum value of type HomepageType describing if a cms page is a fallback homepage.
     */
    HomepageType["FALLBACK"] = "fallback";
})(exports.HomepageType || (exports.HomepageType = {}));
/**
 * This service is used to determine if a cms page is a current, a previous homepage, or neither.
 */
/* @ngInject */ exports.HomepageService = class /* @ngInject */ HomepageService {
    constructor(catalogService, systemEventService) {
        this.catalogService = catalogService;
        this.systemEventService = systemEventService;
    }
    /**
     * Send an event to show info to the user about replacing a homepage from a parent catalog.
     */
    sendEventHideReplaceParentHomePageInfo(data) {
        this.systemEventService.publish(CMS_EVENT_HIDE_REPLACE_PARENT_HOMEPAGE_INFO, data);
    }
    /**
     * Send an event to hide the info to the user about replacing a homepage from a parent catalog.
     */
    sendEventShowReplaceParentHomePageInfo(data) {
        this.systemEventService.publish(CMS_EVENT_SHOW_REPLACE_PARENT_HOMEPAGE_INFO, data);
    }
    /**
     * getHomepageDetailsForContext is a mashup of logic needed for the frontend
     * Both the pageDisplayConditions and newPageDisplayConditions components use it for various
     * ui related things, like enable/disable of the homepage checkbox, or show messages on the UI
     *
     * Given a uriContext, basically there are 3 mains return types, mashed into 1 typescript type
     *
     * 1) CatalogHomepageDetailsStatus.NO_HOMEPAGE
     * This means that the given uriContext has no homepage whatsoever. This probably indicates an issue with the data.
     *
     * 2) CatalogHomepageDetailsStatus.PARENT
     * This means that the current homepage for the given uriContext is inherited from a parent catalog.
     * In this case, the returned ICatalogHomepageDetails contains the parentCatalogName, parentCatalogVersion,
     * targetCatalogName, and targetCatalogVersion,
     *
     * 3) CatalogHomepageDetailsStatus.LOCAL
     * This means that the current homepage for the given uriContext belongs to the catalog of that uriContext.
     * In this case, the returned ICatalogHomepageDetails contains the currentHomepageName, currentHomepageUid,
     * and oldHomepageUid
     *
     * @param uriContext A IUriContext object
     *
     * @returns ICatalogHomepageDetails with one of the 3 options as indicated above
     */
    getHomepageDetailsForContext(uriContext) {
        return __awaiter(this, void 0, void 0, function* () {
            const catalogVersion = yield this.catalogService.getContentCatalogVersion(uriContext);
            const homepageForCurrentCatalog = catalogVersion.homepage
                ? catalogVersion.homepage.current
                : null;
            return this.buildHomepageDetailsForContext(homepageForCurrentCatalog, uriContext);
        });
    }
    /**
     * This method checks if the cms page is a current homepage.
     *
     * @param cmsPage The cms page.
     * @param uriContext The uriContext.
     *
     * @returns A promise resolved with a boolean indicating whether the cms page is the current homepage.
     */
    isCurrentHomepage(cmsPage, uriContext) {
        return this.isHomepageType(cmsPage, uriContext, exports.HomepageType.CURRENT);
    }
    /**
     * This method checks if the cms page is a current homepage.
     *
     * @param cmsPage The cms page.
     * @param uriContext The uriContext.
     *
     * @returns A promise resolved with a boolean indicating whether the cms page is a previous homepage.
     */
    isOldHomepage(cmsPage, uriContext) {
        return this.isHomepageType(cmsPage, uriContext, exports.HomepageType.OLD);
    }
    /**
     * This method returns the homepage type of a cms page.
     *
     * @param cmsPage The cms page.
     * @param uriContext The uriContext.
     *
     * @returns A promise resolved with a enum type indicating whether the cms page is a current, previous homepage or null if neither.
     */
    getHomepageType(cmsPage, uriContext) {
        return __awaiter(this, void 0, void 0, function* () {
            const catalog = yield this.catalogService.getContentCatalogVersion(uriContext);
            if (!catalog || !catalog.homepage) {
                return null;
            }
            if (catalog.homepage.current &&
                catalog.homepage.current.uid === cmsPage.uid &&
                catalog.homepage.current.catalogVersionUuid === cmsPage.catalogVersion) {
                return exports.HomepageType.CURRENT;
            }
            else if (catalog.homepage.old && catalog.homepage.old.uid === cmsPage.uid) {
                return this.compareCatalogVersions(catalog.homepage.old.catalogVersionUuid, cmsPage.catalogVersion, (oldHomepageCatalog, pageCatalog) => oldHomepageCatalog.catalogId === pageCatalog.catalogId ? exports.HomepageType.OLD : null);
            }
            else if (catalog.homepage.fallback && catalog.homepage.fallback.uid === cmsPage.uid) {
                return this.compareCatalogVersions(catalog.homepage.fallback.catalogVersionUuid, cmsPage.catalogVersion, (fallbackCatalog, pageCatalog) => fallbackCatalog.uuid === pageCatalog.uuid ? exports.HomepageType.FALLBACK : null);
            }
            return null;
        });
    }
    /**
     * @param uriContext The uriContext.
     *
     * @returns A promise resolved to true when the catalog has a fallback homepage.
     */
    hasFallbackHomePage(uriContext) {
        return __awaiter(this, void 0, void 0, function* () {
            const catalog = yield this.catalogService.getContentCatalogVersion(uriContext);
            if (!catalog || !catalog.homepage) {
                throw Error(`HomepageService.hasFallbackHomePage - Catalog does not have homepage fallback property`);
            }
            return !!catalog.homepage.fallback;
        });
    }
    /**
     * @param cmsPage The cms page.
     * @param uriContext The uriContext.
     *
     * @returns A promise resolved to true when the page can be synced.
     */
    canSyncHomepage(cmsPage, uriContext) {
        return __awaiter(this, void 0, void 0, function* () {
            const isOld = yield this.isOldHomepage(cmsPage, uriContext);
            if (!isOld) {
                return true;
            }
            const catalog = yield this.catalogService.getContentCatalogVersion(uriContext);
            return this.compareCatalogVersions(catalog.homepage.current.catalogVersionUuid, cmsPage.catalogVersion, (currentCatalog, pageCatalog) => cmsPage.uid !== catalog.homepage.current.uid &&
                currentCatalog.catalogId !== pageCatalog.catalogId);
        });
    }
    compareCatalogVersions(catalogAUuid, catalogBUuid, compare) {
        return __awaiter(this, void 0, void 0, function* () {
            const [catalogVersionA, catalogVersionB] = yield Promise.all([
                this.catalogService.getCatalogVersionByUuid(catalogAUuid),
                this.catalogService.getCatalogVersionByUuid(catalogBUuid)
            ]);
            return compare(catalogVersionA, catalogVersionB);
        });
    }
    isHomepageType(cmsPage, uriContext, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const homepageType = yield this.getHomepageType(cmsPage, uriContext);
            return homepageType === type;
        });
    }
    buildHomepageDetailsForContext(homepageForCurrentCatalog, uriContext) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!homepageForCurrentCatalog) {
                return {
                    status: exports.CatalogHomepageDetailsStatus.NO_HOMEPAGE
                };
            }
            const homepageCatalogVersion = yield this.catalogService.getCatalogVersionByUuid(homepageForCurrentCatalog.catalogVersionUuid);
            const homepageComesFromParent = homepageCatalogVersion.catalogId !== uriContext[cmscommons.CONTEXT_CATALOG];
            const currentCatalogVersion = yield this.catalogService.getContentCatalogVersion(uriContext);
            if (homepageComesFromParent) {
                return {
                    status: exports.CatalogHomepageDetailsStatus.PARENT,
                    parentCatalogName: homepageCatalogVersion.catalogName,
                    parentCatalogVersion: homepageCatalogVersion.version,
                    targetCatalogName: currentCatalogVersion.catalogName,
                    targetCatalogVersion: currentCatalogVersion.version
                };
            }
            return {
                status: exports.CatalogHomepageDetailsStatus.LOCAL,
                currentHomepageName: homepageForCurrentCatalog.name,
                currentHomepageUid: homepageForCurrentCatalog.uid,
                oldHomepageUid: homepageCatalogVersion.homepage
                    ? homepageCatalogVersion.homepage.old
                        ? homepageCatalogVersion.homepage.old.uid
                        : null
                    : null
            };
        });
    }
};
exports.HomepageService.$inject = ["catalogService", "systemEventService"];
/* @ngInject */ exports.HomepageService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.ICatalogService,
        smarteditcommons.SystemEventService])
], /* @ngInject */ exports.HomepageService);

/**
 * The pageDisplayConditionsService provides an abstraction layer for the business logic of
 * primary/variant display conditions of a page
 */
/* @ngInject */ exports.PageDisplayConditionsService = class /* @ngInject */ PageDisplayConditionsService {
    /**
     * An object representing a page display condition<br/>
     * Structure:<br/>
     * ```
     * {
     *      label: [string] key to be localized to render this condition on a webpage
     *      description: [string] key to be localized to render this condition description on a webpage
     *      isPrimary: [boolean]
     * }
     * ```
     */
    constructor(catalogService) {
        this.catalogService = catalogService;
    }
    /**
     * @returns An array of page conditions that are the
     * possible conditions if you wish to create a new page of the given page type that has the given possible primary
     * pages
     */
    getNewPageConditions(pageTypeCode, uriContext) {
        return this.getPageDisplayConditionsByPageType(pageTypeCode, uriContext);
    }
    fetchDisplayConditionsForPageType(pageType, uriContext) {
        return this.catalogService
            .getContentCatalogVersion(uriContext)
            .then((catalogVersion) => catalogVersion.pageDisplayConditions.find((condition) => condition.typecode === pageType));
    }
    getPageDisplayConditionsByPageType(pageType, uriContext) {
        return this.fetchDisplayConditionsForPageType(pageType, uriContext).then((obj) => {
            if (!obj || !obj.options) {
                return [];
            }
            return obj.options.map((option) => ({
                label: option.label,
                description: option.label + '.description',
                isPrimary: option.id === 'PRIMARY'
            }));
        });
    }
};
exports.PageDisplayConditionsService.$inject = ["catalogService"];
/* @ngInject */ exports.PageDisplayConditionsService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.ICatalogService])
], /* @ngInject */ exports.PageDisplayConditionsService);

/**
 * The Generic Editor Modal Service is used to open an editor modal window that contains a tabset.
 */
/* @ngInject */ exports.GenericEditorModalService = class /* @ngInject */ GenericEditorModalService {
    constructor(modalService) {
        this.modalService = modalService;
    }
    /**
     * Function that opens an editor modal. For this method, you must specify an object to contain the edited information, and a save
     * callback that will be triggered once the Save button is clicked.
     */
    open(data, saveCallback, errorCallback, config) {
        const modalConfig = config ? Object.assign({}, config) : {};
        modalConfig.modalPanelClass = `modal-lg ${modalConfig.modalPanelClass || ''}`.trimRight();
        modalConfig.escKeyCloseable = false;
        modalConfig.focusTrapped = false;
        modalConfig.backdropClickCloseable = false;
        const ref = this.modalService.open({
            component: exports.GenericEditorModalComponent,
            data: {
                data,
                saveCallback,
                errorCallback
            },
            config: modalConfig,
            templateConfig: {
                title: data.title,
                isDismissButtonVisible: true,
                titleSuffix: 'se.cms.editor.title.suffix'
            }
        });
        return new Promise((resolve, reject) => ref.afterClosed.subscribe(resolve, reject));
    }
};
exports.GenericEditorModalService.$inject = ["modalService"];
/* @ngInject */ exports.GenericEditorModalService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.IModalService])
], /* @ngInject */ exports.GenericEditorModalService);

/* @ngInject */ exports.EditorModalService = class /* @ngInject */ EditorModalService extends smarteditcommons.IEditorModalService {
    constructor(genericEditorModalService, componentService, renderService, contextAwareEditableItemService, cmsitemsRestService, translateService, genericEditorStackService) {
        super();
        this.genericEditorModalService = genericEditorModalService;
        this.componentService = componentService;
        this.renderService = renderService;
        this.contextAwareEditableItemService = contextAwareEditableItemService;
        this.cmsitemsRestService = cmsitemsRestService;
        this.translateService = translateService;
        this.genericEditorStackService = genericEditorStackService;
    }
    openAndRerenderSlot(componentType, componentUuid, targetedQualifier, saveCallback, editorStackId) {
        return __awaiter(this, void 0, void 0, function* () {
            const componentAttributes = {
                smarteditComponentType: componentType,
                smarteditComponentUuid: componentUuid
            };
            const attributes = yield this.preloadContent(componentUuid, componentAttributes);
            const componentData = this.createComponentData(attributes, {
                targetedQualifier
            }, editorStackId || smarteditcommons.stringUtils.generateIdentifier());
            return this.markAndOpenGenericEditor(componentData, saveCallback);
        });
    }
    open(componentAttributes, targetSlotId, position, targetedQualifier, saveCallback, editorStackId, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const attributes = yield this.preloadContent(componentAttributes.smarteditComponentUuid, componentAttributes);
            const componentData = this.createComponentData(attributes, {
                slotId: targetSlotId,
                position,
                targetedQualifier
            }, editorStackId || smarteditcommons.stringUtils.generateIdentifier());
            return this.markAndOpenGenericEditor(componentData, saveCallback, config);
        });
    }
    openGenericEditor(data, saveCallback, errorCallback, config) {
        return this.genericEditorModalService.open(data, saveCallback, errorCallback, config);
    }
    /**
     * Loads content of the item by uuid and populates the content attribute of componentAttributes object only if it's not already provided.
     */
    preloadContent(uuid, componentAttributes) {
        return __awaiter(this, void 0, void 0, function* () {
            const component = yield this.getContentByUuid(uuid);
            if (component !== null && lodash.isNil(componentAttributes.content)) {
                componentAttributes.content = component;
            }
            return componentAttributes;
        });
    }
    /**
     * Opens generic editor.
     *
     * @param componentData Object that contains all parameters for generic editor.
     * Note: if the componentUuid is not provided the generic editor will be opened for creation.
     *
     * @param saveCallback the save callback that is triggered after submit.
     */
    markAndOpenGenericEditor(componentData, saveCallback, config) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.markComponentAsShared(componentData.content, componentData);
            return this.genericEditorModalService.open(componentData, (item) => {
                if (saveCallback) {
                    saveCallback(item);
                }
                if (componentData.editorStackId) {
                    const [topEditor] = this.genericEditorStackService.getEditorsStack(componentData.editorStackId);
                    const { component: { uuid } } = topEditor;
                    this.componentService
                        .getSlotsForComponent(uuid)
                        .then((slotIds) => {
                        this.renderService.renderSlots(slotIds);
                    });
                }
            }, null, config);
        });
    }
    /**
     * Retrieves a content object by its uuid. If the uuid is undefined, null is returned.
     */
    getContentByUuid(uuid) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!lodash.isNil(uuid)) {
                return this.cmsitemsRestService.getById(uuid);
            }
            return null;
        });
    }
    /**
     * Verifies whether the component is shared in workflow context. If yes, then makes the component readonly and adds a message that the component
     * is used in different workflow. If no, checks whether the component is shared in page context and adds a message about it.
     */
    markComponentAsShared(componentContent, modelServiceParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(componentContent === null || componentContent === void 0 ? void 0 : componentContent.uid)) {
                return;
            }
            const componentIsEditable = yield this.contextAwareEditableItemService.isItemEditable(componentContent.uid);
            modelServiceParameters.readOnlyMode = !componentIsEditable;
            if (modelServiceParameters.readOnlyMode && this.componentIsShared(componentContent)) {
                this.addComponentInfoMessage('se.cms.component.workflow.shared.component', modelServiceParameters);
            }
            else if (this.componentIsShared(componentContent) &&
                !modelServiceParameters.readOnlyMode) {
                this.addComponentInfoMessage('se.cms.component.shared.component', modelServiceParameters);
            }
            else if (!this.componentIsShared(componentContent) &&
                modelServiceParameters.readOnlyMode) {
                this.addComponentInfoMessage('se.cms.component.workflow.component', modelServiceParameters);
            }
        });
    }
    /**
     * Verifies whether the component is shared or not by checking the slots attribute of the component payload.
     */
    componentIsShared(componentContent) {
        var _a;
        return ((_a = componentContent.slots) === null || _a === void 0 ? void 0 : _a.length) > 1;
    }
    /**
     * Adds a message to a messages attribute of IGenericEditorModalServiceComponent. If the attribute is undefined then the new one is created.
     */
    addComponentInfoMessage(message, modelServiceParameters) {
        modelServiceParameters.messages = modelServiceParameters.messages || [];
        modelServiceParameters.messages.push({
            type: 'info',
            message: this.translateService.instant(message)
        });
    }
    prepareContentForCreate(content, componentType, catalogVersionUuid, slotId, position) {
        const preparedContent = content ? Object.assign({}, content) : {};
        preparedContent.position = !smarteditcommons.stringUtils.isBlank(preparedContent.position)
            ? preparedContent.position
            : position;
        preparedContent.slotId = preparedContent.slotId || slotId;
        preparedContent.typeCode = preparedContent.typeCode || componentType;
        preparedContent.itemtype = preparedContent.itemtype || componentType;
        preparedContent.catalogVersion = preparedContent.catalogVersion || catalogVersionUuid;
        preparedContent.visible = !smarteditcommons.stringUtils.isBlank(preparedContent.visible)
            ? preparedContent.visible
            : true;
        return preparedContent;
    }
    createComponentData(componentAttributes, params, editorStackId) {
        let type;
        try {
            type = componentAttributes.smarteditComponentType.toLowerCase();
        }
        catch (error) {
            throw new Error(`editorModalService.createComponentData - invalid component type in componentAttributes. ${error}`);
        }
        const isCreateOperation = lodash.isNil(componentAttributes.smarteditComponentUuid);
        let content;
        if (isCreateOperation) {
            content = this.prepareContentForCreate(componentAttributes.content, componentAttributes.smarteditComponentType, componentAttributes.catalogVersionUuid, params.slotId, params.position);
        }
        else {
            content = componentAttributes.content;
        }
        return {
            componentUuid: componentAttributes.smarteditComponentUuid,
            componentType: componentAttributes.smarteditComponentType,
            title: `type.${type}.name`,
            targetedQualifier: params.targetedQualifier,
            initialDirty: componentAttributes.initialDirty,
            content,
            editorStackId
        };
    }
};
exports.EditorModalService.$inject = ["genericEditorModalService", "componentService", "renderService", "contextAwareEditableItemService", "cmsitemsRestService", "translateService", "genericEditorStackService"];
/* @ngInject */ exports.EditorModalService = __decorate([
    smarteditcommons.SeDowngradeService(smarteditcommons.IEditorModalService),
    smarteditcommons.GatewayProxied('open', 'openAndRerenderSlot', 'openGenericEditor'),
    __metadata("design:paramtypes", [exports.GenericEditorModalService,
        cmscommons.ComponentService,
        smarteditcommons.IRenderService,
        cmscommons.IContextAwareEditableItemService,
        smarteditcommons.CmsitemsRestService,
        core$1.TranslateService,
        smarteditcommons.GenericEditorStackService])
], /* @ngInject */ exports.EditorModalService);

/* @ngInject */ exports.EditorEnablerService = class /* @ngInject */ EditorEnablerService extends cmscommons.IEditorEnablerService {
};
/* @ngInject */ exports.EditorEnablerService = __decorate([
    smarteditcommons.SeDowngradeService(cmscommons.IEditorEnablerService),
    smarteditcommons.GatewayProxied('onClickEditButton', 'isSlotEditableForNonExternalComponent')
], /* @ngInject */ exports.EditorEnablerService);

const PAGE_STRUCTURE_PRE_ORDER = [
    'typeCode',
    'template',
    'name',
    'description',
    'label',
    'uid',
    'title',
    'fromName',
    'fromEmail'
];
const PAGE_STRUCTURE_POST_ORDER = ['creationtime', 'modifiedtime'];
/* @ngInject */ exports.ContextAwarePageStructureService = class /* @ngInject */ ContextAwarePageStructureService {
    constructor(typeStructureRestService, pageService) {
        this.typeStructureRestService = typeStructureRestService;
        this.pageService = pageService;
    }
    /**
     * Return the CMS page structure with some modifications for the context of creating a new page.
     * The field order is modified, the created/modified time fields are removed, and the label field for variation content pages is disabled.
     *
     * @param pageTypeCode The page type of the new page to be created
     * @param isPrimary Flag indicating if the new page will be a primary or variation page
     *
     * @returns A modified page structure
     */
    getPageStructureForNewPage(pageTypeCode, isPrimary) {
        return __awaiter(this, void 0, void 0, function* () {
            const fields = yield this.getFields(pageTypeCode);
            if (pageTypeCode === 'ContentPage') {
                this.setLabelEditability(fields, isPrimary);
            }
            this.removeField(fields, 'creationtime');
            this.removeField(fields, 'modifiedtime');
            this.removeField(fields, 'displayCondition');
            this.removeField(fields, 'restrictions');
            return {
                attributes: this.getOrderedFields(fields),
                category: cmscommons.StructureTypeCategory.PAGE
            };
        });
    }
    /**
     * Return the CMS page structure with some modifications for the context of editing the info of an existing page.
     * The field order is modified, and the label field for variation content pages is disabled.
     *
     * @param pageTypeCode The page type of the page to be edited
     * @param pageId The ID of the existing page to be modified
     *
     * @returns A modified page structure
     */
    getPageStructureForPageEditing(pageTypeCode, pageId) {
        return __awaiter(this, void 0, void 0, function* () {
            const fields = yield this.getFields(pageTypeCode);
            const readOnlyFieldNames = ['uid', 'creationtime', 'modifiedtime'];
            fields
                .filter((field) => readOnlyFieldNames.indexOf(field.qualifier) >= 0)
                .forEach((field) => {
                field.editable = false;
            });
            if (pageTypeCode === 'ContentPage') {
                const isPrimary = yield this.pageService.isPagePrimary(pageId);
                this.setLabelEditability(fields, isPrimary);
                return {
                    attributes: this.getOrderedFields(fields),
                    category: cmscommons.StructureTypeCategory.PAGE
                };
            }
            return {
                attributes: this.getOrderedFields(fields),
                category: cmscommons.StructureTypeCategory.PAGE
            };
        });
    }
    /**
     * Return the CMS page structure with some modifications for the context of viewing the info of an existing page.
     * The field order is modified, and the label field for variation content pages is disabled.
     *
     * @param pageTypeCode The page type of the existing page
     *
     * @returns A modified page structure
     */
    getPageStructureForViewing(pageTypeCode) {
        return __awaiter(this, void 0, void 0, function* () {
            const fields = yield this.getFields(pageTypeCode);
            fields.forEach((field) => {
                field.editable = false;
            });
            this.removeField(fields, 'typeCode');
            this.removeField(fields, 'template');
            this.removeField(fields, 'displayCondition');
            this.removeField(fields, 'restrictions');
            return {
                attributes: this.getOrderedFields(fields),
                category: cmscommons.StructureTypeCategory.PAGE
            };
        });
    }
    moveElement(array, oldPosition, newPosition) {
        if (oldPosition < 0 ||
            oldPosition >= array.length ||
            newPosition < 0 ||
            newPosition >= array.length) {
            return array;
        }
        array.splice(newPosition, 0, array.splice(oldPosition, 1)[0]);
        return array;
    }
    getOrderedFields(unorderedFields) {
        let index;
        for (let i = PAGE_STRUCTURE_PRE_ORDER.length - 1; i >= 0; i--) {
            index = unorderedFields.findIndex((field) => field.qualifier === PAGE_STRUCTURE_PRE_ORDER[i]);
            this.moveElement(unorderedFields, index, 0);
        }
        for (let i = 0; i < PAGE_STRUCTURE_POST_ORDER.length; i++) {
            index = unorderedFields.findIndex((field) => field.qualifier === PAGE_STRUCTURE_POST_ORDER[i]);
            this.moveElement(unorderedFields, index, unorderedFields.length - 1);
        }
        return unorderedFields;
    }
    setLabelEditability(fields, isPrimary) {
        const labelFieldIndex = fields.findIndex((field) => field.qualifier === 'label');
        // Leave the attribute uneditable if user does not have "change" attribute permission
        // NOTE: editable field might be undefined, undefined !== false => true
        if (labelFieldIndex !== -1 && fields[labelFieldIndex].editable !== false) {
            fields[labelFieldIndex].editable = isPrimary;
        }
    }
    getFields(pageTypeCode) {
        return __awaiter(this, void 0, void 0, function* () {
            const structure = yield this.typeStructureRestService.getStructureByType(pageTypeCode);
            structure.push({
                cmsStructureType: 'DisplayConditionEditor',
                i18nKey: 'type.abstractpage.displayCondition.name',
                qualifier: 'displayCondition',
                editable: false
            }, {
                cmsStructureType: 'ShortString',
                i18nKey: 'se.cms.pageinfo.page.type',
                qualifier: 'typeCode',
                editable: false
            });
            return structure;
        });
    }
    removeField(fields, fieldQualifier) {
        const index = fields.findIndex((field) => field.qualifier === fieldQualifier);
        if (index !== -1) {
            fields.splice(index, 1);
        }
    }
};
exports.ContextAwarePageStructureService.$inject = ["typeStructureRestService", "pageService"];
/* @ngInject */ exports.ContextAwarePageStructureService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [TypeStructureRestService,
        smarteditcommons.IPageService])
], /* @ngInject */ exports.ContextAwarePageStructureService);

var /* @ngInject */ CmsDragAndDropService_1;
const ENABLE_CLONE_ON_DROP = 'enableCloneComponentOnDrop';
/* @ngInject */ exports.CmsDragAndDropService = /* @ngInject */ CmsDragAndDropService_1 = class /* @ngInject */ CmsDragAndDropService {
    constructor(dragAndDropService, gatewayFactory, sharedDataService, systemEventService, yjQuery) {
        this.dragAndDropService = dragAndDropService;
        this.gatewayFactory = gatewayFactory;
        this.sharedDataService = sharedDataService;
        this.systemEventService = systemEventService;
        this.yjQuery = yjQuery;
        this.gateway = this.gatewayFactory.createGateway('cmsDragAndDrop');
    }
    register() {
        this.dragAndDropService.register({
            id: /* @ngInject */ CmsDragAndDropService_1.CMS_DRAG_AND_DROP_ID,
            sourceSelector: /* @ngInject */ CmsDragAndDropService_1.SOURCE_SELECTOR,
            targetSelector: /* @ngInject */ CmsDragAndDropService_1.TARGET_SELECTOR,
            startCallback: (event) => this.onStart(event),
            stopCallback: () => this.onStop(),
            enableScrolling: false
        });
    }
    unregister() {
        this.dragAndDropService.unregister([/* @ngInject */ CmsDragAndDropService_1.CMS_DRAG_AND_DROP_ID]);
    }
    apply() {
        this.dragAndDropService.apply(null);
    }
    update() {
        this.dragAndDropService.update(/* @ngInject */ CmsDragAndDropService_1.CMS_DRAG_AND_DROP_ID);
    }
    onStart(event) {
        return __awaiter(this, void 0, void 0, function* () {
            const cloneOnDrop = yield this.sharedDataService.get(ENABLE_CLONE_ON_DROP);
            const component = this.getSelector(event.target).closest(/* @ngInject */ CmsDragAndDropService_1.COMPONENT_SELECTOR);
            const dragInfo = {
                componentId: component.attr(smarteditcommons.ID_ATTRIBUTE),
                componentUuid: component.attr(smarteditcommons.UUID_ATTRIBUTE),
                componentType: component.attr(smarteditcommons.TYPE_ATTRIBUTE),
                slotUuid: null,
                slotId: null,
                cloneOnDrop
            };
            this.gateway.publish(cmscommons.DRAG_AND_DROP_EVENTS.DRAG_STARTED, dragInfo);
            this.systemEventService.publishAsync(cmscommons.DRAG_AND_DROP_EVENTS.DRAG_STARTED);
        });
    }
    onStop() {
        this.gateway.publish(cmscommons.DRAG_AND_DROP_EVENTS.DRAG_STOPPED, null);
    }
    getSelector(selector) {
        return this.yjQuery(selector);
    }
};
/* @ngInject */ exports.CmsDragAndDropService.CMS_DRAG_AND_DROP_ID = 'se.cms.dragAndDrop';
/* @ngInject */ exports.CmsDragAndDropService.TARGET_SELECTOR = '';
/* @ngInject */ exports.CmsDragAndDropService.SOURCE_SELECTOR = ".smartEditComponent[data-smartedit-component-type!='ContentSlot']";
/* @ngInject */ exports.CmsDragAndDropService.COMPONENT_SELECTOR = '.smartEditComponent';
/* @ngInject */ exports.CmsDragAndDropService = /* @ngInject */ CmsDragAndDropService_1 = __decorate([
    smarteditcommons.SeDowngradeService(),
    __param(4, core.Inject(smarteditcommons.YJQUERY_TOKEN)),
    __metadata("design:paramtypes", [smarteditcommons.DragAndDropService,
        smarteditcommons.GatewayFactory,
        smarteditcommons.ISharedDataService,
        smarteditcommons.SystemEventService, Function])
], /* @ngInject */ exports.CmsDragAndDropService);

const PRODUCT_CATEGORY_RESOURCE_BASE_URI = '/cmssmarteditwebservices/v1/sites/:siteUID/categories';
const PRODUCT_CATEGORY_RESOURCE_URI = `${PRODUCT_CATEGORY_RESOURCE_BASE_URI}/:categoryUID`;
const PRODUCT_CATEGORY_SEARCH_RESOURCE_URI = '/cmssmarteditwebservices/v1/productcatalogs/:catalogId/versions/:catalogVersion/categories';
/* @ngInject */ exports.ProductCategoryService = class /* @ngInject */ ProductCategoryService {
    constructor(restServiceFactory, languageService) {
        this.languageService = languageService;
        this.productCategoryService = restServiceFactory.get(PRODUCT_CATEGORY_RESOURCE_URI);
        this.productCategorySearchService = restServiceFactory.get(PRODUCT_CATEGORY_SEARCH_RESOURCE_URI);
    }
    getCategoryById(siteUID, categoryUID) {
        return this.productCategoryService.get({
            siteUID,
            categoryUID
        });
    }
    getCategories(payload) {
        this._validateProductCatalogInfo(payload);
        return this.languageService.getResolveLocale().then((langIsoCode) => this.productCategorySearchService.page({
            catalogId: payload.catalogId,
            catalogVersion: payload.catalogVersion,
            text: payload.mask,
            pageSize: payload.pageSize,
            currentPage: payload.currentPage,
            langIsoCode
        }));
    }
    _validateProductCatalogInfo(productCatalogInfo) {
        if (!productCatalogInfo.siteUID) {
            throw Error('[productService] - site UID missing.');
        }
        if (!productCatalogInfo.catalogId) {
            throw Error('[productService] - catalog ID missing.');
        }
        if (!productCatalogInfo.catalogVersion) {
            throw Error('[productService] - catalog version  missing.');
        }
    }
};
exports.ProductCategoryService.$inject = ["restServiceFactory", "languageService"];
/* @ngInject */ exports.ProductCategoryService = __decorate([
    smarteditcommons.SeDowngradeService(),
    core.Injectable(),
    __metadata("design:paramtypes", [smarteditcommons.RestServiceFactory, smarteditcommons.LanguageService])
], /* @ngInject */ exports.ProductCategoryService);

/** Used to determine an URI for fetching the data for Dropdown Populators. */
/* @ngInject */ exports.ContextAwareCatalogService = class /* @ngInject */ ContextAwareCatalogService {
    constructor(catalogService, sharedDataService) {
        this.catalogService = catalogService;
        this.sharedDataService = sharedDataService;
    }
    getProductCategorySearchUri(productCatalogId) {
        return this.getSearchUriByProductCatalogIdAndUriConstant(productCatalogId, PRODUCT_CATEGORY_SEARCH_RESOURCE_URI);
    }
    getProductCategoryItemUri() {
        return this.getItemUriByUriConstant(PRODUCT_CATEGORY_RESOURCE_BASE_URI);
    }
    getProductSearchUri(productCatalogId) {
        return this.getSearchUriByProductCatalogIdAndUriConstant(productCatalogId, smarteditcommons.PRODUCT_LIST_RESOURCE_API);
    }
    getProductItemUri() {
        return __awaiter(this, void 0, void 0, function* () {
            const uri = yield this.getItemUriByUriConstant(smarteditcommons.PRODUCT_RESOURCE_API);
            return uri.replace('/:productUID', '');
        });
    }
    getContentPageSearchUri() {
        return __awaiter(this, void 0, void 0, function* () {
            const uri = yield this.getContentPageUri();
            return `${uri}?typeCode=ContentPage`;
        });
    }
    getContentPageItemUri() {
        return this.getContentPageUri();
    }
    getSearchUriByProductCatalogIdAndUriConstant(productCatalogId, uriConstant) {
        return __awaiter(this, void 0, void 0, function* () {
            const catalogVersion = yield this.catalogService.getActiveProductCatalogVersionByCatalogId(productCatalogId);
            return uriConstant
                .replace(/:catalogId/gi, productCatalogId)
                .replace(/:catalogVersion/gi, catalogVersion);
        });
    }
    getItemUriByUriConstant(uriConstant) {
        return Promise.resolve(uriConstant.replace(/:siteUID/gi, 'CURRENT_CONTEXT_SITE_ID'));
    }
    getContentPageUri() {
        return __awaiter(this, void 0, void 0, function* () {
            const { catalogDescriptor: { catalogId } } = (yield this.sharedDataService.get(smarteditcommons.EXPERIENCE_STORAGE_KEY));
            const catalogVersion = yield this.catalogService.getActiveContentCatalogVersionByCatalogId(catalogId);
            return cmscommons.PAGES_LIST_RESOURCE_URI.replace(/CURRENT_CONTEXT_CATALOG/gi, catalogId).replace(/CURRENT_CONTEXT_CATALOG_VERSION/gi, catalogVersion);
        });
    }
};
exports.ContextAwareCatalogService.$inject = ["catalogService", "sharedDataService"];
/* @ngInject */ exports.ContextAwareCatalogService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.ICatalogService,
        smarteditcommons.ISharedDataService])
], /* @ngInject */ exports.ContextAwareCatalogService);

/* @ngInject */ exports.RulesAndPermissionsRegistrationService = class /* @ngInject */ RulesAndPermissionsRegistrationService {
    constructor(attributePermissionsRestService, catalogService, catalogVersionPermissionService, catalogVersionRestService, cMSModesService, experienceService, pageService, permissionService, sharedDataService, typePermissionsRestService, workflowService) {
        this.attributePermissionsRestService = attributePermissionsRestService;
        this.catalogService = catalogService;
        this.catalogVersionPermissionService = catalogVersionPermissionService;
        this.catalogVersionRestService = catalogVersionRestService;
        this.cMSModesService = cMSModesService;
        this.experienceService = experienceService;
        this.pageService = pageService;
        this.permissionService = permissionService;
        this.sharedDataService = sharedDataService;
        this.typePermissionsRestService = typePermissionsRestService;
        this.workflowService = workflowService;
    }
    register() {
        this.registerRules();
        this.registerRulesForTypeCodeFromContext();
        this.registerRulesForCurrentPage();
        this.registerRulesForTypeCode();
        this.registerRulesForTypeAndQualifier();
        this.registerPermissions();
    }
    onSuccess(results) {
        return results.every((isValid) => isValid);
    }
    onError() {
        return false;
    }
    getCurrentPageActiveWorkflow() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!smarteditcommons.windowUtils.getGatewayTargetFrame()) {
                return null;
            }
            const { uuid } = yield this.pageService.getCurrentPageInfo();
            return this.workflowService.getActiveWorkflowForPageUuid(uuid);
        });
    }
    registerRules() {
        this.permissionService.registerRule({
            names: [
                RULE_PERMISSION_WRITE_PAGE,
                RULE_PERMISSION_WRITE_SLOT,
                RULE_PERMISSION_WRITE_COMPONENT,
                RULE_PERMISSION_WRITE_TO_CURRENT_CATALOG_VERSION
            ],
            verify: (permissionNameObjs) => {
                const promises = permissionNameObjs.map((permissionNameObject) => {
                    if (permissionNameObject.context) {
                        return this.catalogVersionPermissionService.hasWritePermission(permissionNameObject.context.catalogId, permissionNameObject.context.catalogVersion);
                    }
                    else {
                        return this.catalogVersionPermissionService.hasWritePermissionOnCurrent();
                    }
                });
                return Promise.all(promises).then(this.onSuccess, this.onError);
            }
        });
        /**
         * This rule returns true if the page is in a workflow and current user is participant of this workflow
         * or there is no workflow.
         * Otherwise, it returns false;
         */
        this.permissionService.registerRule({
            names: [RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_PAGE_IN_WORKFLOW],
            verify: (permissionNameObjs) => {
                const isAvailableForCurrentPrincipal = (workflow) => workflow === null ? true : workflow.isAvailableForCurrentPrincipal;
                const promises = permissionNameObjs.map((permissionNameObject) => {
                    if (permissionNameObject.context) {
                        return this.workflowService
                            .getActiveWorkflowForPageUuid(permissionNameObject.context.pageInfo.uuid)
                            .then((workflow) => isAvailableForCurrentPrincipal(workflow));
                    }
                    else {
                        return this.getCurrentPageActiveWorkflow().then((workflow) => isAvailableForCurrentPrincipal(workflow), () => true);
                    }
                });
                return Promise.all(promises).then(this.onSuccess, this.onError);
            }
        });
        /**
         * This rule returns true if the current user is a participant of currently active step of a workflow
         * or there is no workflow.
         * Otherwise, it returns false;
         */
        this.permissionService.registerRule({
            names: [RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_WORKFLOW_CURRENT_ACTION],
            verify: (permissionNameObjs) => {
                const isUserParticipant = (workflow) => __awaiter(this, void 0, void 0, function* () {
                    return workflow === null
                        ? true
                        : this.workflowService.isUserParticipanInActiveAction(workflow.workflowCode);
                });
                const promises = permissionNameObjs.map((permissionNameObject) => {
                    if (permissionNameObject.context) {
                        return this.workflowService
                            .getActiveWorkflowForPageUuid(permissionNameObject.context.pageInfo.uuid)
                            .then((workflow) => isUserParticipant(workflow));
                    }
                    else {
                        return this.getCurrentPageActiveWorkflow().then((workflow) => isUserParticipant(workflow), () => true);
                    }
                });
                return Promise.all(promises).then(this.onSuccess, this.onError);
            }
        });
        this.permissionService.registerRule({
            names: [RULE_PERMISSION_SYNC_CATALOG],
            verify: (permissionNameObjs) => {
                const promises = permissionNameObjs.map((permissionNameObject) => {
                    if (permissionNameObject.context) {
                        return this.catalogVersionPermissionService.hasSyncPermission(permissionNameObject.context.catalogId, permissionNameObject.context.catalogVersion, permissionNameObject.context.targetCatalogVersion);
                    }
                    else {
                        return this.catalogVersionPermissionService.hasSyncPermissionFromCurrentToActiveCatalogVersion();
                    }
                });
                return Promise.all(promises).then(this.onSuccess, this.onError);
            }
        });
        this.permissionService.registerRule({
            names: ['se.approval.status.page'],
            verify: () => __awaiter(this, void 0, void 0, function* () {
                const { approvalStatus } = yield this.pageService.getCurrentPageInfo();
                return approvalStatus === 'APPROVED';
            })
        });
        this.permissionService.registerRule({
            names: [
                RULE_PERMISSION_READ_PAGE,
                RULE_PERMISSION_READ_SLOT,
                RULE_PERMISSION_READ_COMPONENT,
                RULE_PERMISSION_READ_CURRENT_CATALOG_VERSION
            ],
            verify: () => this.catalogVersionPermissionService.hasReadPermissionOnCurrent()
        });
        this.permissionService.registerRule({
            names: [RULE_PERMISSION_PAGE_BELONGS_TO_EXPERIENCE],
            verify: () => __awaiter(this, void 0, void 0, function* () {
                const experience = (yield this.sharedDataService.get(smarteditcommons.EXPERIENCE_STORAGE_KEY));
                return (experience.pageContext &&
                    experience.pageContext.catalogVersionUuid ===
                        experience.catalogDescriptor.catalogVersionUuid);
            })
        });
        /**
         * Show the clone icon:
         * - If a page belonging to an active catalog version, whose copyToCatalogsDisabled flag is set to false and has at-least one clonable target.
         * - If a page belonging to a non active catalog version has at-least one clonable target.
         *
         * !NOTE: Logic here is very similar to logic used in ManagePageService#isPageCloneable, so if any changes are done here it should be considered to add those changes in mentioned service as well
         */
        this.permissionService.registerRule({
            names: ['se.cloneable.page'],
            verify: () => __awaiter(this, void 0, void 0, function* () {
                const experience = (yield this.sharedDataService.get(smarteditcommons.EXPERIENCE_STORAGE_KEY));
                if (!experience.pageContext) {
                    return false;
                }
                const pageUriContext = {
                    CURRENT_CONTEXT_SITE_ID: experience.pageContext.siteId,
                    CURRENT_CONTEXT_CATALOG: experience.pageContext.catalogId,
                    CURRENT_CONTEXT_CATALOG_VERSION: experience.pageContext.catalogVersion
                };
                const pageInfo = yield this.pageService.getCurrentPageInfo();
                const targets = yield this.catalogVersionRestService.getCloneableTargets(pageUriContext);
                if (experience.pageContext.active) {
                    return targets.versions.length > 0 && !pageInfo.copyToCatalogsDisabled;
                }
                return targets.versions.length > 0;
            })
        });
        this.permissionService.registerRule({
            names: [RULE_PERMISSION_CATALOG_NON_ACTIVE],
            verify: () => this.catalogService.isContentCatalogVersionNonActive()
        });
        this.permissionService.registerRule({
            names: [RULE_PERMISSION_NOT_VERSIONING_PERSPECTIVE],
            verify: () => __awaiter(this, void 0, void 0, function* () {
                const isActive = yield this.cMSModesService.isVersioningPerspectiveActive();
                return !isActive;
            })
        });
        this.permissionService.registerRule({
            names: [RULE_PERMISSION_VERSION_PAGE_SELECTED],
            verify: () => __awaiter(this, void 0, void 0, function* () {
                const experience = yield this.experienceService.getCurrentExperience();
                return !!experience.versionId;
            })
        });
        this.permissionService.registerRule({
            names: ['se.version.page.not.selected'],
            verify: () => __awaiter(this, void 0, void 0, function* () {
                const experience = yield this.experienceService.getCurrentExperience();
                return !experience.versionId;
            })
        });
        this.permissionService.registerRule({
            names: ['se.catalogversion.has.workflows.enabled'],
            verify: () => this.workflowService.areWorkflowsEnabledOnCurrentCatalogVersion()
        });
        this.permissionService.registerRule({
            names: [RULE_PERMISSION_CURRENT_PAGE_HAS_ACTIVE_WORKFLOW],
            verify: () => __awaiter(this, void 0, void 0, function* () {
                const workflow = yield this.getCurrentPageActiveWorkflow();
                return workflow !== null;
            })
        });
        this.permissionService.registerRule({
            names: ['se.current.page.has.no.active.workflow'],
            verify: () => __awaiter(this, void 0, void 0, function* () {
                const workflow = yield this.getCurrentPageActiveWorkflow();
                return workflow === null;
            })
        });
        // Attribute Permissions
        this.permissionService.registerRule({
            names: ['se.has.change.permission.on.page.approval.status'],
            verify: () => __awaiter(this, void 0, void 0, function* () {
                const attributeName = 'approvalStatus';
                const pageInfo = yield this.pageService.getCurrentPageInfo();
                const result = yield this.attributePermissionsRestService.hasChangePermissionOnAttributesInType(pageInfo.typeCode, [attributeName]);
                return result[attributeName];
            })
        });
    }
    registerRulesForTypeCodeFromContext() {
        const registerTypePermissionRuleForTypeCodeFromContext = (ruleName, verifyRule) => {
            this.permissionService.registerRule({
                names: [ruleName],
                verify: (permissionNameObjs) => {
                    const promises = permissionNameObjs.map((permissionNameObject) => verifyRule([permissionNameObject.context.typeCode]).then((updatePermission) => updatePermission[permissionNameObject.context.typeCode]));
                    return Promise.all(promises).then(this.onSuccess, this.onError);
                }
            });
        };
        // check if the current user has change permission on the type provided part of the permission object
        registerTypePermissionRuleForTypeCodeFromContext('se.has.change.permissions.on.type', (types) => this.typePermissionsRestService.hasUpdatePermissionForTypes(types));
        // check if the current user has create permission on the type provided part of the permission object
        registerTypePermissionRuleForTypeCodeFromContext('se.has.create.permissions.on.type', (types) => this.typePermissionsRestService.hasCreatePermissionForTypes(types));
        // check if the current user has remove permission on the type provided part of the permission object
        registerTypePermissionRuleForTypeCodeFromContext('se.has.remove.permissions.on.type', (types) => this.typePermissionsRestService.hasDeletePermissionForTypes(types));
    }
    registerRulesForCurrentPage() {
        const registerTypePermissionRuleOnCurrentPage = (ruleName, verifyRule) => {
            this.permissionService.registerRule({
                names: [ruleName],
                verify: () => __awaiter(this, void 0, void 0, function* () {
                    const pageInfo = yield this.pageService.getCurrentPageInfo();
                    const permissionObject = yield verifyRule([pageInfo.typeCode]);
                    return permissionObject[pageInfo.typeCode];
                })
            });
        };
        // check if the current user has change permission on the page currently loaded
        registerTypePermissionRuleOnCurrentPage(RULE_PERMISSION_HAS_CHANGE_TYPE_PERMISSION_ON_CURRENT_PAGE, (types) => this.typePermissionsRestService.hasUpdatePermissionForTypes(types));
        // check if the current user has create permission on the page currently loaded
        registerTypePermissionRuleOnCurrentPage('se.has.create.type.permissions.on.current.page', (types) => this.typePermissionsRestService.hasCreatePermissionForTypes(types));
        // check if the current user has read permission on the page currently loaded
        registerTypePermissionRuleOnCurrentPage(RULE_PERMISSION_HAS_READ_TYPE_PERMISSION_ON_CURRENT_PAGE, (types) => this.typePermissionsRestService.hasReadPermissionForTypes(types));
    }
    registerRulesForTypeCode() {
        const registerTypePermissionRuleForTypeCode = (ruleName, itemType, verifyRule) => {
            this.permissionService.registerRule({
                names: [ruleName],
                verify: () => __awaiter(this, void 0, void 0, function* () {
                    const UpdatePermission = yield verifyRule([itemType]);
                    return UpdatePermission[itemType];
                })
            });
        };
        // check if the current user has read/create/remove/change permission on the CMSVersion type
        registerTypePermissionRuleForTypeCode(RULE_PERMISSION_HAS_READ_PERMISSION_ON_VERSION_TYPE, 'CMSVersion', (types) => this.typePermissionsRestService.hasReadPermissionForTypes(types));
        registerTypePermissionRuleForTypeCode(RULE_PERMISSION_HAS_CREATE_PERMISSION_ON_VERSION_TYPE, 'CMSVersion', (types) => this.typePermissionsRestService.hasCreatePermissionForTypes(types));
        registerTypePermissionRuleForTypeCode('se.has.remove.permission.on.version.type', 'CMSVersion', (types) => this.typePermissionsRestService.hasDeletePermissionForTypes(types));
        registerTypePermissionRuleForTypeCode('se.has.change.permission.on.version.type', 'CMSVersion', (types) => this.typePermissionsRestService.hasUpdatePermissionForTypes(types));
        registerTypePermissionRuleForTypeCode('se.has.create.permission.on.abstractcomponent.type', 'AbstractCMSComponent', (types) => this.typePermissionsRestService.hasCreatePermissionForTypes(types));
        registerTypePermissionRuleForTypeCode('se.has.change.permission.on.contentslotforpage.type', 'ContentSlotForPage', (types) => this.typePermissionsRestService.hasUpdatePermissionForTypes(types));
        // check if current user has create/change permission on the Workflow type
        registerTypePermissionRuleForTypeCode('se.has.create.permission.on.workflow.type', 'Workflow', (types) => this.typePermissionsRestService.hasCreatePermissionForTypes(types));
        registerTypePermissionRuleForTypeCode(RULE_PERMISSION_HAS_CHANGE_PERMISSION_ON_WORKFLOW_TYPE, 'Workflow', (types) => this.typePermissionsRestService.hasUpdatePermissionForTypes(types));
        registerTypePermissionRuleForTypeCode('se.has.read.permission.on.workflow.type', 'Workflow', (types) => this.typePermissionsRestService.hasReadPermissionForTypes(types));
        registerTypePermissionRuleForTypeCode('se.has.create.permission.on.contentslot.type', 'ContentSlot', (types) => this.typePermissionsRestService.hasCreatePermissionForTypes(types));
        registerTypePermissionRuleForTypeCode('se.has.delete.permission.on.contentslot.type', 'ContentSlot', (types) => this.typePermissionsRestService.hasDeletePermissionForTypes(types));
    }
    registerRulesForTypeAndQualifier() {
        const registerAttributePermissionRuleForTypeAndQualifier = (ruleName, itemType, qualifier, verifyRule) => {
            this.permissionService.registerRule({
                names: [ruleName],
                verify: () => __awaiter(this, void 0, void 0, function* () {
                    const data = yield verifyRule(itemType, [qualifier]);
                    return data[qualifier];
                })
            });
        };
        registerAttributePermissionRuleForTypeAndQualifier('se.has.change.permission.on.workflow.status', 'Workflow', 'status', (type, attributeNames) => this.attributePermissionsRestService.hasChangePermissionOnAttributesInType(type, attributeNames));
        registerAttributePermissionRuleForTypeAndQualifier('se.has.change.permission.on.workflow.description', 'Workflow', 'description', (type, attributeNames) => this.attributePermissionsRestService.hasChangePermissionOnAttributesInType(type, attributeNames));
    }
    registerPermissions() {
        this.permissionService.registerPermission({
            aliases: ['se.add.component'],
            rules: [
                RULE_PERMISSION_WRITE_SLOT,
                RULE_PERMISSION_WRITE_COMPONENT,
                RULE_PERMISSION_PAGE_BELONGS_TO_EXPERIENCE,
                RULE_PERMISSION_HAS_CHANGE_TYPE_PERMISSION_ON_CURRENT_PAGE,
                RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_PAGE_IN_WORKFLOW,
                RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_WORKFLOW_CURRENT_ACTION,
                'se.has.create.permission.on.abstractcomponent.type'
            ]
        });
        this.permissionService.registerPermission({
            aliases: [RULE_PERMISSION_READ_PAGE],
            rules: [RULE_PERMISSION_READ_PAGE]
        });
        this.permissionService.registerPermission({
            aliases: ['se.edit.page'],
            rules: [
                RULE_PERMISSION_WRITE_PAGE,
                RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_PAGE_IN_WORKFLOW
            ]
        });
        this.permissionService.registerPermission({
            aliases: [RULE_PERMISSION_SYNC_CATALOG],
            rules: [RULE_PERMISSION_SYNC_CATALOG]
        });
        this.permissionService.registerPermission({
            aliases: ['se.sync.slot.context.menu', 'se.sync.slot.indicator'],
            rules: [
                RULE_PERMISSION_SYNC_CATALOG,
                RULE_PERMISSION_PAGE_BELONGS_TO_EXPERIENCE,
                RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_PAGE_IN_WORKFLOW
            ]
        });
        this.permissionService.registerPermission({
            aliases: ['se.sync.page'],
            rules: [
                RULE_PERMISSION_PAGE_BELONGS_TO_EXPERIENCE,
                RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_PAGE_IN_WORKFLOW
            ]
        });
        this.permissionService.registerPermission({
            aliases: ['se.edit.navigation'],
            rules: [RULE_PERMISSION_WRITE_COMPONENT]
        });
        this.permissionService.registerPermission({
            aliases: ['se.context.menu.remove.component'],
            rules: [
                RULE_PERMISSION_WRITE_SLOT,
                RULE_PERMISSION_PAGE_BELONGS_TO_EXPERIENCE,
                RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_PAGE_IN_WORKFLOW,
                RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_WORKFLOW_CURRENT_ACTION
            ]
        });
        this.permissionService.registerPermission({
            aliases: ['se.slot.context.menu.shared.icon', 'se.slot.context.menu.unshared.icon'],
            rules: [
                'se.read.slot',
                RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_PAGE_IN_WORKFLOW,
                RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_WORKFLOW_CURRENT_ACTION
            ]
        });
        this.permissionService.registerPermission({
            aliases: ['se.slot.context.menu.visibility'],
            rules: [RULE_PERMISSION_PAGE_BELONGS_TO_EXPERIENCE]
        });
        this.permissionService.registerPermission({
            aliases: ['se.clone.page'],
            rules: ['se.cloneable.page', 'se.has.create.type.permissions.on.current.page']
        });
        this.permissionService.registerPermission({
            aliases: ['se.context.menu.edit.component'],
            rules: [
                RULE_PERMISSION_WRITE_COMPONENT,
                RULE_PERMISSION_PAGE_BELONGS_TO_EXPERIENCE,
                RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_PAGE_IN_WORKFLOW
            ]
        });
        this.permissionService.registerPermission({
            aliases: ['se.context.menu.drag.and.drop.component'],
            rules: [
                RULE_PERMISSION_WRITE_SLOT,
                RULE_PERMISSION_WRITE_COMPONENT,
                RULE_PERMISSION_PAGE_BELONGS_TO_EXPERIENCE,
                RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_PAGE_IN_WORKFLOW,
                RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_WORKFLOW_CURRENT_ACTION,
                'se.has.change.permission.on.contentslotforpage.type'
            ]
        });
        this.permissionService.registerPermission({
            aliases: ['se.edit.page.link', 'se.delete.page.menu'],
            rules: [
                RULE_PERMISSION_WRITE_PAGE,
                RULE_PERMISSION_PAGE_BELONGS_TO_EXPERIENCE,
                RULE_PERMISSION_NOT_VERSIONING_PERSPECTIVE,
                RULE_PERMISSION_HAS_CHANGE_TYPE_PERMISSION_ON_CURRENT_PAGE,
                RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_PAGE_IN_WORKFLOW
            ]
        });
        this.permissionService.registerPermission({
            aliases: ['se.shared.slot.override.options'],
            rules: [
                RULE_PERMISSION_WRITE_PAGE,
                RULE_PERMISSION_PAGE_BELONGS_TO_EXPERIENCE,
                RULE_PERMISSION_NOT_VERSIONING_PERSPECTIVE,
                RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_PAGE_IN_WORKFLOW,
                'se.has.create.permission.on.contentslot.type'
            ]
        });
        this.permissionService.registerPermission({
            aliases: ['se.revert.to.global.or.shared.slot.link'],
            rules: [
                RULE_PERMISSION_WRITE_PAGE,
                RULE_PERMISSION_PAGE_BELONGS_TO_EXPERIENCE,
                RULE_PERMISSION_NOT_VERSIONING_PERSPECTIVE,
                RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_PAGE_IN_WORKFLOW,
                'se.has.delete.permission.on.contentslot.type'
            ]
        });
        this.permissionService.registerPermission({
            aliases: ['se.clone.component'],
            rules: [
                RULE_PERMISSION_WRITE_COMPONENT,
                RULE_PERMISSION_PAGE_BELONGS_TO_EXPERIENCE,
                RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_PAGE_IN_WORKFLOW,
                RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_WORKFLOW_CURRENT_ACTION
            ]
        });
        this.permissionService.registerPermission({
            aliases: ['se.edit.page.type', 'se.delete.page.type', 'se.restore.page.type'],
            rules: ['se.has.change.permissions.on.type']
        });
        this.permissionService.registerPermission({
            aliases: ['se.clone.page.type'],
            rules: ['se.has.create.permissions.on.type']
        });
        this.permissionService.registerPermission({
            aliases: ['se.permanently.delete.page.type'],
            rules: ['se.has.remove.permissions.on.type']
        });
        // Version
        this.permissionService.registerPermission({
            aliases: ['se.version.page'],
            rules: [
                RULE_PERMISSION_WRITE_PAGE,
                RULE_PERMISSION_PAGE_BELONGS_TO_EXPERIENCE,
                RULE_PERMISSION_CATALOG_NON_ACTIVE,
                RULE_PERMISSION_HAS_READ_PERMISSION_ON_VERSION_TYPE,
                RULE_PERMISSION_HAS_READ_TYPE_PERMISSION_ON_CURRENT_PAGE
            ]
        });
        this.permissionService.registerPermission({
            aliases: ['se.edit.version.page'],
            rules: [
                'se.write.to.current.catalog.version',
                'se.has.change.permission.on.version.type',
                RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_PAGE_IN_WORKFLOW
            ]
        });
        this.permissionService.registerPermission({
            aliases: ['se.create.version.page'],
            rules: [
                'se.version.page.not.selected',
                RULE_PERMISSION_PAGE_BELONGS_TO_EXPERIENCE,
                RULE_PERMISSION_HAS_CREATE_PERMISSION_ON_VERSION_TYPE,
                RULE_PERMISSION_HAS_READ_TYPE_PERMISSION_ON_CURRENT_PAGE
            ]
        });
        const rulesForVersionRollback = [
            RULE_PERMISSION_VERSION_PAGE_SELECTED,
            RULE_PERMISSION_PAGE_BELONGS_TO_EXPERIENCE,
            RULE_PERMISSION_HAS_READ_PERMISSION_ON_VERSION_TYPE,
            RULE_PERMISSION_HAS_CREATE_PERMISSION_ON_VERSION_TYPE,
            RULE_PERMISSION_HAS_CHANGE_TYPE_PERMISSION_ON_CURRENT_PAGE
        ];
        this.permissionService.registerPermission({
            aliases: ['se.rollback.version.page'],
            rules: rulesForVersionRollback
        });
        this.permissionService.registerPermission({
            // the page versions menu button should be visible even if a version is not selected
            aliases: ['se.rollback.version.page.versions.menu'],
            rules: rulesForVersionRollback.filter((rule) => rule !== RULE_PERMISSION_VERSION_PAGE_SELECTED)
        });
        this.permissionService.registerPermission({
            aliases: ['se.delete.version.page'],
            rules: ['se.has.remove.permission.on.version.type']
        });
        // Workflow
        this.permissionService.registerPermission({
            aliases: ['se.start.page.workflow'],
            rules: [
                'se.has.create.permission.on.workflow.type',
                'se.catalogversion.has.workflows.enabled',
                'se.current.page.has.no.active.workflow'
            ]
        });
        this.permissionService.registerPermission({
            aliases: ['se.view.page.workflowMenu'],
            rules: [
                'se.has.read.permission.on.workflow.type',
                RULE_PERMISSION_CURRENT_PAGE_HAS_ACTIVE_WORKFLOW
            ]
        });
        this.permissionService.registerPermission({
            aliases: ['se.cancel.page.workflowMenu'],
            rules: [
                RULE_PERMISSION_HAS_CHANGE_PERMISSION_ON_WORKFLOW_TYPE,
                RULE_PERMISSION_CURRENT_PAGE_HAS_ACTIVE_WORKFLOW,
                'se.has.change.permission.on.workflow.status'
            ]
        });
        this.permissionService.registerPermission({
            aliases: ['se.edit.workflow.workflowMenu'],
            rules: [
                RULE_PERMISSION_HAS_CHANGE_PERMISSION_ON_WORKFLOW_TYPE,
                RULE_PERMISSION_CURRENT_PAGE_HAS_ACTIVE_WORKFLOW,
                'se.has.change.permission.on.workflow.description'
            ]
        });
        this.permissionService.registerPermission({
            aliases: ['se.force.page.approval'],
            rules: [
                RULE_PERMISSION_SYNC_CATALOG,
                'se.has.change.permission.on.page.approval.status',
                RULE_PERMISSION_PAGE_BELONGS_TO_EXPERIENCE
            ]
        });
        this.permissionService.registerPermission({
            aliases: ['se.show.page.status'],
            rules: [RULE_PERMISSION_CATALOG_NON_ACTIVE, RULE_PERMISSION_PAGE_BELONGS_TO_EXPERIENCE]
        });
        this.permissionService.registerPermission({
            aliases: ['se.act.on.page.in.workflow'],
            rules: [RULE_PERMISSION_CURRENT_USER_CAN_ACT_ON_PAGE_IN_WORKFLOW]
        });
    }
};
exports.RulesAndPermissionsRegistrationService.$inject = ["attributePermissionsRestService", "catalogService", "catalogVersionPermissionService", "catalogVersionRestService", "cMSModesService", "experienceService", "pageService", "permissionService", "sharedDataService", "typePermissionsRestService", "workflowService"];
/* @ngInject */ exports.RulesAndPermissionsRegistrationService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [cmscommons.AttributePermissionsRestService,
        smarteditcommons.ICatalogService,
        smarteditcommons.ICatalogVersionPermissionService,
        CatalogVersionRestService,
        smarteditcommons.CMSModesService,
        smarteditcommons.IExperienceService,
        smarteditcommons.IPageService,
        smarteditcommons.IPermissionService,
        smarteditcommons.ISharedDataService,
        cmscommons.TypePermissionsRestService,
        smarteditcommons.WorkflowService])
], /* @ngInject */ exports.RulesAndPermissionsRegistrationService);

/* @ngInject */ exports.ContextAwareEditableItemService = class /* @ngInject */ ContextAwareEditableItemService extends cmscommons.IContextAwareEditableItemService {
    constructor(workflowService, pageService) {
        super();
        this.workflowService = workflowService;
        this.pageService = pageService;
    }
    isItemEditable(itemUid) {
        return __awaiter(this, void 0, void 0, function* () {
            const workflowEditableItems = yield this.workflowService.getWorkflowEditableItems([
                itemUid
            ]);
            const item = workflowEditableItems.find((data) => data.uid === itemUid);
            if (item.editableInWorkflow) {
                const editable = yield this.editableInCurrentPageContext(item.editableInWorkflow);
                return item.editableByUser && editable;
            }
            return item.editableByUser;
        });
    }
    /**
     * Verifies whether the item's active workflow equals to the workflow of page currently in preview.
     */
    editableInCurrentPageContext(editableInWorkflow) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const pageInfo = yield this.pageService.getCurrentPageInfo();
                const activeWorkflow = yield this.workflowService.getActiveWorkflowForPageUuid(pageInfo.uid);
                return activeWorkflow !== null && activeWorkflow.workflowCode === editableInWorkflow;
            }
            catch (_a) {
                return true;
            }
        });
    }
};
exports.ContextAwareEditableItemService.$inject = ["workflowService", "pageService"];
/* @ngInject */ exports.ContextAwareEditableItemService = __decorate([
    smarteditcommons.SeDowngradeService(cmscommons.IContextAwareEditableItemService),
    smarteditcommons.GatewayProxied(),
    __metadata("design:paramtypes", [smarteditcommons.WorkflowService, smarteditcommons.IPageService])
], /* @ngInject */ exports.ContextAwareEditableItemService);

/**
 * Guard that prevents unauthorized user from navigating to Storefront Page.
 *
 * @internal
 * @ignore
 */
/* @ngInject */ exports.ExperienceGuard = class /* @ngInject */ ExperienceGuard {
    constructor(catalogAwareRouteResolverHelper, routing) {
        this.catalogAwareRouteResolverHelper = catalogAwareRouteResolverHelper;
        this.routing = routing;
    }
    /**
     * It will redirect current user to the Landing Page if the user doesn't have a read permission to the current catalog version.
     */
    canActivate(route) {
        return this.catalogAwareRouteResolverHelper
            .experienceFromPathResolve(route.params)
            .catch(() => {
            this.routing.go(smarteditcommons.NG_ROUTE_PREFIX);
            return false;
        });
    }
};
exports.ExperienceGuard.$inject = ["catalogAwareRouteResolverHelper", "routing"];
/* @ngInject */ exports.ExperienceGuard = __decorate([
    core.Injectable(),
    __metadata("design:paramtypes", [smarteditcontainer.CatalogAwareRouteResolverHelper,
        smarteditcommons.SmarteditRoutingService])
], /* @ngInject */ exports.ExperienceGuard);

/**
 * A service for working with restriction criteria.
 */
/* @ngInject */ exports.PageRestrictionsCriteriaService = class /* @ngInject */ PageRestrictionsCriteriaService {
    constructor() {
        this.ALL = {};
        this.ANY = {};
        this.restrictionCriteriaOptions = [this.ALL, this.ANY];
        this.setupCriteria(this.ALL, 'all', false);
        this.setupCriteria(this.ANY, 'any', true);
    }
    /**
     * @param onlyOneRestrictionMustApply A boolean to determine whether one restriction should be applied.
     * @returns The i18n key of the restriction criteria.
     */
    getMatchCriteriaLabel(onlyOneRestrictionMustApply) {
        if (onlyOneRestrictionMustApply) {
            return this.ANY.label;
        }
        return this.ALL.label;
    }
    /**
     * @returns An array of criteria options.
     */
    getRestrictionCriteriaOptions() {
        return this.restrictionCriteriaOptions;
    }
    /**
     * @returns An object of the restriction criteria for the given page.
     */
    getRestrictionCriteriaOptionFromPage(page) {
        if (page && typeof page.onlyOneRestrictionMustApply === 'boolean') {
            if (page.onlyOneRestrictionMustApply) {
                return this.ANY;
            }
        }
        return this.ALL;
    }
    setupCriteria(criteria, id, boolValue) {
        Object.defineProperty(criteria, 'id', {
            writable: false,
            value: id
        });
        Object.defineProperty(criteria, 'label', {
            writable: false,
            value: 'se.cms.restrictions.criteria.' + id
        });
        Object.defineProperty(criteria, 'editLabel', {
            writable: false,
            value: 'se.cms.restrictions.criteria.select.' + id
        });
        Object.defineProperty(criteria, 'value', {
            writable: false,
            value: boolValue
        });
    }
};
/* @ngInject */ exports.PageRestrictionsCriteriaService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [])
], /* @ngInject */ exports.PageRestrictionsCriteriaService);

/* @ngInject */ exports.PageTypesRestrictionTypesService = class /* @ngInject */ PageTypesRestrictionTypesService {
    constructor(pageTypesRestrictionTypesRestService) {
        this.pageTypesRestrictionTypesRestService = pageTypesRestrictionTypesRestService;
    }
    getRestrictionTypeCodesForPageType(pageType) {
        return __awaiter(this, void 0, void 0, function* () {
            const pageTypesRestrictionTypes = yield this.getPageTypesRestrictionTypes();
            return pageTypesRestrictionTypes
                .filter((pageTypeRestrictionType) => pageTypeRestrictionType.pageType === pageType)
                .map((pageTypeRestrictionType) => pageTypeRestrictionType.restrictionType);
        });
    }
    getPageTypesRestrictionTypes() {
        if (this.cache) {
            return this.cache;
        }
        else {
            this.cache = this.pageTypesRestrictionTypesRestService
                .getPageTypesRestrictionTypes()
                .then((response) => response.pageTypeRestrictionTypeList);
        }
        return this.cache;
    }
};
exports.PageTypesRestrictionTypesService.$inject = ["pageTypesRestrictionTypesRestService"];
/* @ngInject */ exports.PageTypesRestrictionTypesService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [PageTypesRestrictionTypesRestService])
], /* @ngInject */ exports.PageTypesRestrictionTypesService);

/* @ngInject */ exports.RestrictionTypesService = class /* @ngInject */ RestrictionTypesService {
    constructor(pageTypesRestrictionTypesService, restrictionTypesRestService) {
        this.pageTypesRestrictionTypesService = pageTypesRestrictionTypesService;
        this.restrictionTypesRestService = restrictionTypesRestService;
    }
    getRestrictionTypesByPageType(pageType) {
        return __awaiter(this, void 0, void 0, function* () {
            const restrictionTypes = yield this.getRestrictionTypes();
            const restrictionTypeCodes = yield this.pageTypesRestrictionTypesService.getRestrictionTypeCodesForPageType(pageType);
            return restrictionTypes.filter((restrictionType) => restrictionTypeCodes.indexOf(restrictionType.code) >= 0);
        });
    }
    getRestrictionTypeForTypeCode(typeCode) {
        return __awaiter(this, void 0, void 0, function* () {
            const restrictionTypes = yield this.getRestrictionTypes();
            return restrictionTypes.find((restrictionType) => restrictionType.code === typeCode);
        });
    }
    getRestrictionTypes() {
        if (this.cache) {
            return this.cache;
        }
        else {
            this.cache = this.restrictionTypesRestService
                .getRestrictionTypes()
                .then((response) => response.restrictionTypes);
        }
        return this.cache;
    }
};
exports.RestrictionTypesService.$inject = ["pageTypesRestrictionTypesService", "restrictionTypesRestService"];
/* @ngInject */ exports.RestrictionTypesService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [exports.PageTypesRestrictionTypesService,
        RestrictionTypesRestService])
], /* @ngInject */ exports.RestrictionTypesService);

const ACTIONABLE_ERRORS = [
    {
        subject: 'name',
        errorCode: 'field.already.exist',
        structure: {
            cmsStructureType: 'ShortString',
            collection: false,
            editable: true,
            i18nKey: 'type.cmsitem.name.name',
            localized: false,
            paged: false,
            qualifier: 'name',
            required: true
        }
    },
    {
        subject: 'label',
        errorCode: 'default.page.label.already.exist',
        structure: {
            cmsStructureType: 'DuplicatePrimaryContentPage',
            collection: false,
            editable: true,
            i18nKey: 'se.cms.page.restore.content.duplicate.primaryforvariation.label',
            localized: false,
            paged: false,
            qualifier: 'label',
            required: true
        }
    },
    {
        subject: 'label',
        errorCode: 'default.page.does.not.exist',
        structure: {
            cmsStructureType: 'MissingPrimaryContentPage',
            collection: false,
            editable: true,
            i18nKey: 'se.cms.page.restore.content.noprimaryforvariation.label',
            localized: false,
            paged: false,
            qualifier: 'label',
            required: true
        }
    },
    {
        subject: 'typeCode',
        errorCode: 'default.page.already.exist',
        structure: {
            cmsStructureType: 'DuplicatePrimaryNonContentPageMessage',
            collection: false,
            editable: true,
            i18nKey: 'type.cmsitem.label.name',
            localized: false,
            paged: false,
            qualifier: 'replace',
            required: true
        }
    }
];
const NON_ACTIONABLE_ERRORS = [
    {
        subject: 'typeCode',
        errorCode: 'default.page.does.not.exist',
        messageKey: 'se.cms.page.restore.noprimaryforvariation.error'
    }
];

/* @ngInject */ exports.PageRestoreModalService = class /* @ngInject */ PageRestoreModalService {
    constructor(alertService, confirmationModalService, genericEditorModalService, crossFrameEventService, pageRestoredAlertService, translate) {
        this.alertService = alertService;
        this.confirmationModalService = confirmationModalService;
        this.genericEditorModalService = genericEditorModalService;
        this.crossFrameEventService = crossFrameEventService;
        this.pageRestoredAlertService = pageRestoredAlertService;
        this.translate = translate;
    }
    /**
     * Handles validation errors depending of their type - show error alert for unsupported errors,
     * show confirmation message for non actionable errors, otherwise show modal with detailed errors
     */
    handleRestoreValidationErrors(pageInfo, errors) {
        const actionableErrors = this.getActionableErrors(errors);
        const nonActionableErrors = this.getNonActionableError(errors);
        const unsupportedErrors = lodash.difference(errors, actionableErrors, nonActionableErrors);
        if (unsupportedErrors.length > 0) {
            this.showErrorAlert(unsupportedErrors);
        }
        else if (nonActionableErrors.length > 0) {
            this.showConfirmationMessage(nonActionableErrors);
        }
        else {
            this.showRestoreEditor(pageInfo, actionableErrors).then(() => {
                this.crossFrameEventService.publish(smarteditcommons.EVENT_CONTENT_CATALOG_UPDATE);
            });
        }
    }
    showRestoreEditor(pageInfo, errors) {
        let structureFields = this.getRestoreEditorStructureFields(errors);
        const editorData = {
            content: pageInfo,
            title: 'se.cms.page.restore.page.title',
            componentId: pageInfo.uid,
            componentUuid: pageInfo.uuid,
            componentType: pageInfo.typeCode,
            structure: this.buildStructure(structureFields)
        };
        this.forceErrorsDisplayInEditor(pageInfo.componentUuid, errors);
        return this.genericEditorModalService.open(editorData, () => {
            this.pageRestoredAlertService.displayPageRestoredSuccessAlert(pageInfo);
            this.crossFrameEventService.publish(smarteditcommons.EVENTS.PAGE_RESTORED);
        }, (newErrors, ge) => {
            const actionableErrors = this.getActionableErrors(newErrors);
            const unsupportedErrors = lodash.difference(newErrors, actionableErrors);
            if (unsupportedErrors.length > 0) {
                this.showErrorAlert(unsupportedErrors);
            }
            else {
                structureFields = lodash.concat(structureFields, this.getRestoreEditorStructureFields(newErrors));
                ge.structure = this.buildStructure(structureFields);
                this.forceErrorsDisplayInEditor(pageInfo.componentUuid, newErrors);
            }
        }, {
            modalPanelClass: 'modal-stretched'
        });
    }
    forceErrorsDisplayInEditor(editorId, errors) {
        setTimeout(() => {
            this.crossFrameEventService.publish(smarteditcommons.GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT, {
                messages: errors,
                targetGenericEditorId: editorId
            });
        }, 0);
    }
    buildStructure(structureFields) {
        return {
            attributes: structureFields,
            category: 'PAGE'
        };
    }
    getRestoreEditorStructureFields(errors) {
        return errors.reduce((accumulator, currentError) => {
            const errorMapping = ACTIONABLE_ERRORS.find((actionableErrorMapping) => this.isSupportedError(currentError) &&
                this.isEqualTo(currentError, actionableErrorMapping));
            accumulator.push(errorMapping.structure);
            return accumulator;
        }, []);
    }
    showConfirmationMessage(errors) {
        const message = errors.reduce((accumulator, currentError) => {
            const errorMapping = NON_ACTIONABLE_ERRORS.find((nonActionableErrorMapping) => this.isSupportedError(currentError) &&
                this.isEqualTo(currentError, nonActionableErrorMapping));
            return accumulator + this.translate.instant(errorMapping.messageKey) + ' ';
        }, '');
        const modalConfig = {
            description: message.trim(),
            showOkButtonOnly: true,
            title: 'se.cms.page.restore.error.confirmationmodal.title'
        };
        this.confirmationModalService.confirm(modalConfig);
    }
    showErrorAlert(errors) {
        const errorMessage = errors.reduce((accumulator, currentError) => accumulator + currentError.message + ' ', '');
        this.alertService.showDanger(errorMessage.trim());
    }
    getActionableErrors(errors) {
        return errors.filter((error) => ACTIONABLE_ERRORS.some((actionableErrorMapping) => this.isSupportedError(error) && this.isEqualTo(error, actionableErrorMapping)));
    }
    getNonActionableError(errors) {
        return errors.filter((error) => NON_ACTIONABLE_ERRORS.some((nonActionableErrorMapping) => this.isSupportedError(error) && this.isEqualTo(error, nonActionableErrorMapping)));
    }
    isSupportedError(error) {
        return error.type === 'ValidationError';
    }
    isEqualTo(error1, error2) {
        return error1.subject === error2.subject && error1.errorCode === error2.errorCode;
    }
};
exports.PageRestoreModalService.$inject = ["alertService", "confirmationModalService", "genericEditorModalService", "crossFrameEventService", "pageRestoredAlertService", "translate"];
/* @ngInject */ exports.PageRestoreModalService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.IAlertService,
        smarteditcommons.IConfirmationModalService,
        exports.GenericEditorModalService,
        smarteditcommons.CrossFrameEventService,
        exports.PageRestoredAlertService,
        core$1.TranslateService])
], /* @ngInject */ exports.PageRestoreModalService);

/* @ngInject */ exports.PageService = class /* @ngInject */ PageService extends smarteditcommons.IPageService {
    constructor(pagesRestService, pagesFallbacksRestService, pagesVariationsRestService, pageInfoService, cmsitemsRestService, experienceService, urlService) {
        super();
        this.pagesRestService = pagesRestService;
        this.pagesFallbacksRestService = pagesFallbacksRestService;
        this.pagesVariationsRestService = pagesVariationsRestService;
        this.pageInfoService = pageInfoService;
        this.cmsitemsRestService = cmsitemsRestService;
        this.experienceService = experienceService;
        this.urlService = urlService;
    }
    getPageByUuid(pageUuid) {
        return this.cmsitemsRestService.getById(pageUuid);
    }
    getCurrentPageInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const pageUUID = yield this.pageInfoService.getPageUUID();
            return this.cmsitemsRestService.getById(pageUUID);
        });
    }
    getPageById(pageUid) {
        return this.pagesRestService.getById(pageUid);
    }
    getCurrentPageInfoByVersion(versionId) {
        return __awaiter(this, void 0, void 0, function* () {
            const pageUUID = yield this.pageInfoService.getPageUUID();
            return this.cmsitemsRestService.getByIdAndVersion(pageUUID, versionId);
        });
    }
    primaryPageForPageTypeExists(pageTypeCode, uriParams) {
        return __awaiter(this, void 0, void 0, function* () {
            const page = yield this.getPaginatedPrimaryPagesForPageType(pageTypeCode, uriParams, {
                search: null,
                pageSize: 1,
                currentPage: 0
            });
            return page.response.length > 0;
        });
    }
    getPaginatedPrimaryPagesForPageType(pageTypeCode, uriParams, fetchPageParams) {
        const itemSearchParams = 'defaultPage:true,pageStatus:ACTIVE';
        const extendedParams = lodash.assign({}, uriParams || {}, fetchPageParams || {}, {
            typeCode: pageTypeCode,
            itemSearchParams
        });
        if (extendedParams.search) {
            extendedParams.mask = extendedParams.search;
            delete extendedParams.search;
        }
        if (!lodash.isNumber(extendedParams.pageSize)) {
            extendedParams.pageSize = 10;
        }
        if (!lodash.isNumber(extendedParams.currentPage)) {
            extendedParams.currentPage = 0;
        }
        return this.cmsitemsRestService.get(extendedParams);
    }
    isPagePrimary(pageUid) {
        return __awaiter(this, void 0, void 0, function* () {
            const fallbacks = yield this.pagesFallbacksRestService.getFallbacksForPageId(pageUid);
            return fallbacks.length === 0;
        });
    }
    isPagePrimaryWithContext(pageUid, uriContext) {
        return __awaiter(this, void 0, void 0, function* () {
            const fallbacks = yield this.pagesFallbacksRestService.getFallbacksForPageIdAndContext(pageUid, uriContext);
            return fallbacks.length === 0;
        });
    }
    getPrimaryPage(variationPageId) {
        return __awaiter(this, void 0, void 0, function* () {
            const fallbacks = yield this.pagesFallbacksRestService.getFallbacksForPageId(variationPageId);
            return fallbacks[0]
                ? this.pagesRestService.getById(fallbacks[0])
                : Promise.resolve(null);
        });
    }
    getVariationPages(primaryPageId) {
        return __awaiter(this, void 0, void 0, function* () {
            const variationPageIds = yield this.pagesVariationsRestService.getVariationsForPrimaryPageId(primaryPageId);
            return variationPageIds.length > 0
                ? this.pagesRestService.get(variationPageIds)
                : Promise.resolve([]);
        });
    }
    updatePageById(pageUid, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const originalPage = yield this.pagesRestService.getById(pageUid);
            // This call is done to ensure that default promise properties are removed from the payload.
            const originalPagePayload = smarteditcommons.objectUtils.copy(originalPage);
            payload = Object.assign(Object.assign({}, originalPagePayload), payload);
            return this.pagesRestService.update(pageUid, payload);
        });
    }
    forcePageApprovalStatus(newPageStatus) {
        return __awaiter(this, void 0, void 0, function* () {
            const pageInfo = yield this.getCurrentPageInfo();
            const clonePageInfo = Object.assign({}, pageInfo);
            clonePageInfo.approvalStatus = newPageStatus;
            clonePageInfo.identifier = pageInfo.uuid;
            return this.cmsitemsRestService.update(clonePageInfo);
        });
    }
    isPageApproved(pageParam) {
        return __awaiter(this, void 0, void 0, function* () {
            let page;
            if (typeof pageParam === 'string') {
                page = yield this.getPageByUuid(pageParam);
            }
            else {
                page = pageParam;
            }
            return page.approvalStatus === smarteditcommons.CmsApprovalStatus.APPROVED;
        });
    }
    buildUriContextForCurrentPage(siteId, catalogId, catalogVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            let uriContext = {};
            if (siteId && catalogId && catalogVersion) {
                uriContext = this.urlService.buildUriContext(siteId, catalogId, catalogVersion);
            }
            if (!lodash.isEmpty(uriContext)) {
                return uriContext;
            }
            const experience = yield this.experienceService.getCurrentExperience();
            return this.urlService.buildUriContext(experience.pageContext.siteId, experience.pageContext.catalogId, experience.pageContext.catalogVersion);
        });
    }
};
exports.PageService.$inject = ["pagesRestService", "pagesFallbacksRestService", "pagesVariationsRestService", "pageInfoService", "cmsitemsRestService", "experienceService", "urlService"];
__decorate([
    smarteditcommons.Cached({ actions: [smarteditcommons.rarelyChangingContent], tags: [smarteditcommons.pageEvictionTag] }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], /* @ngInject */ exports.PageService.prototype, "getPageByUuid", null);
__decorate([
    smarteditcommons.Cached({ actions: [smarteditcommons.rarelyChangingContent], tags: [smarteditcommons.pageEvictionTag, smarteditcommons.pageChangeEvictionTag] }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], /* @ngInject */ exports.PageService.prototype, "getCurrentPageInfo", null);
/* @ngInject */ exports.PageService = __decorate([
    smarteditcommons.SeDowngradeService(smarteditcommons.IPageService),
    smarteditcommons.GatewayProxied(),
    __metadata("design:paramtypes", [PagesRestService,
        PagesFallbacksRestService,
        PagesVariationsRestService,
        smarteditcommons.IPageInfoService,
        smarteditcommons.CmsitemsRestService,
        smarteditcommons.IExperienceService,
        smarteditcommons.IUrlService])
], /* @ngInject */ exports.PageService);

let /* @ngInject */ PageFacade = class /* @ngInject */ PageFacade {
    constructor(cmsitemsRestService, crossFrameEventService, sharedDataService, urlService, catalogService) {
        this.cmsitemsRestService = cmsitemsRestService;
        this.crossFrameEventService = crossFrameEventService;
        this.sharedDataService = sharedDataService;
        this.urlService = urlService;
        this.catalogService = catalogService;
    }
    /**
     * Determines if a ContentPage with a given label exists in the given catalog and catalog version
     *
     * @param label The label to search for
     * @param catalogId The catalog ID to search in for the ContentPage
     * @param catalogVersion The catalog version to search in for the ContentPage
     * @return Promise resolving to a boolean determining if the ContentPage exists
     */
    contentPageWithLabelExists(label, catalogId, catalogVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestParams = {
                pageSize: 10,
                currentPage: 0,
                typeCode: 'ContentPage',
                itemSearchParams: 'label:' + label,
                catalogId,
                catalogVersion
            };
            const result = yield this.cmsitemsRestService.get(requestParams);
            return result && !lodash.isEmpty(result.response);
        });
    }
    /**
     * Retrieves the experience and builds a uri context based on its page context
     *
     * @returns the page uriContext
     */
    retrievePageUriContext() {
        return __awaiter(this, void 0, void 0, function* () {
            const experience = (yield this.sharedDataService.get(smarteditcommons.EXPERIENCE_STORAGE_KEY));
            if (!experience) {
                throw new Error('pageFacade - could not retrieve an experience from sharedDataService');
            }
            if (!experience.pageContext) {
                return null;
            }
            return this.urlService.buildUriContext(experience.pageContext.siteId, experience.pageContext.catalogId, experience.pageContext.catalogVersion);
        });
    }
    /**
     * @param page The object representing the CMS page item to create
     * @returns If request is successful, it returns a promise that resolves with the CMS page item object. If
     * the request fails, it resolves with errors from the backend.
     */
    createPage(page) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!page.catalogVersion) {
                page.catalogVersion = yield this.catalogService.getCatalogVersionUUid();
            }
            if (page.onlyOneRestrictionMustApply === undefined) {
                page.onlyOneRestrictionMustApply = false;
            }
            if (page.restrictions === undefined) {
                page.restrictions = [];
            }
            const newlyCreatedPage = yield this.cmsitemsRestService.create(page);
            this.crossFrameEventService.publish(smarteditcommons.EVENTS.PAGE_CREATED, page);
            return newlyCreatedPage;
        });
    }
    /**
     * Creates a new CMS page item for a given site.
     *
     * @param page The object representing the CMS page item to create
     * @param siteUid The uid of the target site.
     * @returns If request is successful, it returns a promise that resolves with the CMS page item object. If
     * the request fails, it resolves with errors from the backend.
     */
    createPageForSite(page, siteUid) {
        return __awaiter(this, void 0, void 0, function* () {
            const catalogVersionUUid = yield this.catalogService.getCatalogVersionUUid();
            page.catalogVersion = page.catalogVersion || catalogVersionUUid;
            if (page.onlyOneRestrictionMustApply === undefined) {
                page.onlyOneRestrictionMustApply = false;
            }
            page = lodash.cloneDeep(page);
            page[cmscommons.CONTEXT_SITE_ID] = siteUid;
            const newlyCreatedPage = yield this.cmsitemsRestService.create(page);
            this.crossFrameEventService.publish(smarteditcommons.EVENTS.PAGE_CREATED, page);
            return newlyCreatedPage;
        });
    }
};
PageFacade.$inject = ["cmsitemsRestService", "crossFrameEventService", "sharedDataService", "urlService", "catalogService"];
/* @ngInject */ PageFacade = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.CmsitemsRestService,
        smarteditcommons.CrossFrameEventService,
        smarteditcommons.ISharedDataService,
        smarteditcommons.IUrlService,
        smarteditcommons.ICatalogService])
], /* @ngInject */ PageFacade);

class PageBuilder {
    constructor(catalogService, contextAwarePageStructureService, restrictionsStepHandler, uriContext) {
        this.catalogService = catalogService;
        this.contextAwarePageStructureService = contextAwarePageStructureService;
        this.restrictionsStepHandler = restrictionsStepHandler;
        this.uriContext = uriContext;
        this.model = {};
        this.page = {
            restrictions: []
        };
        this.catalogService.getCatalogVersionUUid(this.uriContext).then((catalogVersionUuid) => {
            this.page.catalogVersion = catalogVersionUuid;
        });
    }
    pageTypeSelected(pageTypeObject) {
        this.model.pageType = pageTypeObject;
        this.model.pageTemplate = null;
        return this.updatePageInfoFields();
    }
    pageTemplateSelected(pageTemplateObject) {
        this.model.pageTemplate = pageTemplateObject;
    }
    getPageTypeCode() {
        var _a;
        return ((_a = this.model.pageType) === null || _a === void 0 ? void 0 : _a.code) || null;
    }
    getTemplateUuid() {
        var _a;
        return ((_a = this.model.pageTemplate) === null || _a === void 0 ? void 0 : _a.uuid) || '';
    }
    getPage() {
        var _a, _b;
        this.page.typeCode = this.getPageTypeCode();
        this.page.itemtype = this.page.typeCode;
        this.page.type = ((_a = this.model.pageType) === null || _a === void 0 ? void 0 : _a.type) || null;
        this.page.masterTemplate = this.getTemplateUuid() || null;
        this.page.template = ((_b = this.model.pageTemplate) === null || _b === void 0 ? void 0 : _b.uid) || null;
        return this.page;
    }
    getPageRestrictions() {
        return this.page.restrictions;
    }
    setPageUid(uid) {
        this.page.uid = uid;
    }
    setRestrictions(onlyOneRestrictionMustApply, restrictions) {
        this.page.onlyOneRestrictionMustApply = onlyOneRestrictionMustApply;
        this.page.restrictions = restrictions;
    }
    getPageInfoStructure() {
        return this.model.pageInfoFields;
    }
    displayConditionSelected(displayConditionResult) {
        const isPrimaryPage = displayConditionResult.isPrimary;
        this.page.defaultPage = isPrimaryPage;
        this.page.homepage = displayConditionResult.homepage;
        if (isPrimaryPage) {
            this.page.label = null;
            this.restrictionsStepHandler.hideStep();
        }
        else {
            this.page.label = displayConditionResult.primaryPage
                ? displayConditionResult.primaryPage.label
                : '';
            this.restrictionsStepHandler.showStep();
        }
        return this.updatePageInfoFields();
    }
    updatePageInfoFields() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.page.defaultPage !== undefined) {
                if (this.model.pageType) {
                    const pageInfoFields = yield this.contextAwarePageStructureService.getPageStructureForNewPage(this.model.pageType.code, this.page.defaultPage);
                    this.model.pageInfoFields = pageInfoFields;
                }
                else {
                    this.model.pageInfoFields = {};
                }
            }
        });
    }
}
let /* @ngInject */ PageBuilderFactory = class /* @ngInject */ PageBuilderFactory {
    constructor(catalogService, contextAwarePageStructureService) {
        this.catalogService = catalogService;
        this.contextAwarePageStructureService = contextAwarePageStructureService;
    }
    createPageBuilder(restrictionsStepHandler, uriContext) {
        return new PageBuilder(this.catalogService, this.contextAwarePageStructureService, restrictionsStepHandler, uriContext);
    }
};
PageBuilderFactory.$inject = ["catalogService", "contextAwarePageStructureService"];
/* @ngInject */ PageBuilderFactory = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.ICatalogService,
        exports.ContextAwarePageStructureService])
], /* @ngInject */ PageBuilderFactory);

class RestrictionsStepHandler {
    constructor(wizardManager, restrictionsEditorFunctionBindings, stepProperties) {
        this.wizardManager = wizardManager;
        this.restrictionsEditorFunctionBindings = restrictionsEditorFunctionBindings;
        this.stepDetails = stepProperties;
    }
    hideStep() {
        if (this.isStepOnWizard()) {
            this.wizardManager.removeStepById(this.getStepId());
        }
    }
    showStep() {
        if (!this.isStepOnWizard()) {
            this.wizardManager.addStep(this.stepDetails, this.wizardManager.getStepsCount());
        }
    }
    isStepValid() {
        return (this.restrictionsEditorFunctionBindings.isDirty &&
            this.restrictionsEditorFunctionBindings.isDirty());
    }
    getStepId() {
        return this.stepDetails.id;
    }
    goToStep() {
        this.wizardManager.goToStepWithId(this.getStepId());
    }
    isStepOnWizard() {
        return this.wizardManager.containsStep(this.getStepId());
    }
}
/* @ngInject */ exports.RestrictionsStepHandlerFactory = class /* @ngInject */ RestrictionsStepHandlerFactory {
    createRestrictionsStepHandler(wizardManager, restrictionsEditorFunctionBindings, stepProperties) {
        return new RestrictionsStepHandler(wizardManager, restrictionsEditorFunctionBindings, stepProperties);
    }
};
/* @ngInject */ exports.RestrictionsStepHandlerFactory = __decorate([
    smarteditcommons.SeDowngradeService()
], /* @ngInject */ exports.RestrictionsStepHandlerFactory);

/**
 * Used for fetching supported restrictions.
 */
/* @ngInject */ exports.RestrictionsService = class /* @ngInject */ RestrictionsService {
    constructor(structuresRestService, typeStructureRestService, structureModeManagerFactory) {
        this.structuresRestService = structuresRestService;
        this.typeStructureRestService = typeStructureRestService;
        this.modeManager = structureModeManagerFactory.createModeManager(['add', 'edit', 'create']);
    }
    /**
     * @returns An URI of the structure for a given mode.
     */
    getStructureApiUri(mode) {
        this.modeManager.validateMode(mode);
        return this.structuresRestService.getUriForContext(mode);
    }
    /**
     * @returns An array of restriction TypeCodes that are supported by SmartEdit.
     */
    getSupportedRestrictionTypeCodes() {
        return __awaiter(this, void 0, void 0, function* () {
            const structures = yield this.typeStructureRestService.getStructuresByCategory(cmscommons.StructureTypeCategory.RESTRICTION);
            return structures.map((structure) => structure.code);
        });
    }
};
exports.RestrictionsService.$inject = ["structuresRestService", "typeStructureRestService", "structureModeManagerFactory"];
/* @ngInject */ exports.RestrictionsService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [StructuresRestService,
        TypeStructureRestService,
        StructureModeManagerFactory])
], /* @ngInject */ exports.RestrictionsService);

window.__smartedit__.addDecoratorPayload("Component", "PageTypeStepComponent", {
    selector: 'se-page-type-step',
    template: `
        <se-select-page-type
            [pageTypeCode]="wizardApi.getPageTypeCode()"
            (onTypeSelected)="wizardApi.typeSelected($event)"
        >
        </se-select-page-type>
    `
});
let /* @ngInject */ PageTypeStepComponent = class /* @ngInject */ PageTypeStepComponent {
    constructor(wizardApi) {
        this.wizardApi = wizardApi;
    }
};
PageTypeStepComponent.$inject = ["wizardApi"];
/* @ngInject */ PageTypeStepComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-type-step',
        template: `
        <se-select-page-type
            [pageTypeCode]="wizardApi.getPageTypeCode()"
            (onTypeSelected)="wizardApi.typeSelected($event)"
        >
        </se-select-page-type>
    `
    }),
    __param(0, core.Inject(smarteditcommons.WIZARD_API)),
    __metadata("design:paramtypes", [Object])
], /* @ngInject */ PageTypeStepComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageTemplateStepComponent", {
    selector: 'se-page-template-step',
    template: `
        <se-select-page-template
            [uriContext]="wizardApi.uriContext"
            [pageTypeCode]="wizardApi.getPageTypeCode()"
            (onTemplateSelected)="wizardApi.templateSelected($event)"
        >
        </se-select-page-template>
    `
});
let /* @ngInject */ PageTemplateStepComponent = class /* @ngInject */ PageTemplateStepComponent {
    constructor(wizardApi) {
        this.wizardApi = wizardApi;
    }
};
PageTemplateStepComponent.$inject = ["wizardApi"];
/* @ngInject */ PageTemplateStepComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-template-step',
        template: `
        <se-select-page-template
            [uriContext]="wizardApi.uriContext"
            [pageTypeCode]="wizardApi.getPageTypeCode()"
            (onTemplateSelected)="wizardApi.templateSelected($event)"
        >
        </se-select-page-template>
    `
    }),
    __param(0, core.Inject(smarteditcommons.WIZARD_API)),
    __metadata("design:paramtypes", [Object])
], /* @ngInject */ PageTemplateStepComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageInfoStepComponent", {
    selector: 'se-page-info-step',
    template: `
        <span *ngIf="wizardApi.isPageInfoActive()">
            <se-generic-editor
                [structure]="wizardApi.getPageInfoStructure()"
                [content]="wizardApi.getPageInfo()"
                [(submit)]="wizardApi.callbacks.savePageInfo"
                [(reset)]="wizardApi.callbacks.resetPageInfo"
                [(isDirty)]="wizardApi.callbacks.isDirtyPageInfo"
                [(isValid)]="wizardApi.callbacks.isValidPageInfo"
            >
            </se-generic-editor>
        </span>
    `
});
let /* @ngInject */ PageInfoStepComponent = class /* @ngInject */ PageInfoStepComponent {
    constructor(wizardApi) {
        this.wizardApi = wizardApi;
    }
};
PageInfoStepComponent.$inject = ["wizardApi"];
/* @ngInject */ PageInfoStepComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-info-step',
        template: `
        <span *ngIf="wizardApi.isPageInfoActive()">
            <se-generic-editor
                [structure]="wizardApi.getPageInfoStructure()"
                [content]="wizardApi.getPageInfo()"
                [(submit)]="wizardApi.callbacks.savePageInfo"
                [(reset)]="wizardApi.callbacks.resetPageInfo"
                [(isDirty)]="wizardApi.callbacks.isDirtyPageInfo"
                [(isValid)]="wizardApi.callbacks.isValidPageInfo"
            >
            </se-generic-editor>
        </span>
    `
    }),
    __param(0, core.Inject(smarteditcommons.WIZARD_API)),
    __metadata("design:paramtypes", [Object])
], /* @ngInject */ PageInfoStepComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageDisplayConditionStepComponent", {
    selector: 'se-page-condition-step',
    template: `
        <se-event-message
            class="existing-homepage__ymessage"
            [showEvent]="'CMS_EVENT_SHOW_REPLACE_PARENT_HOMEPAGE_INFO'"
            [hideEvent]="'CMS_EVENT_HIDE_REPLACE_PARENT_HOMEPAGE_INFO'"
        >
        </se-event-message>

        <se-new-page-display-condition
            [pageTypeCode]="wizardApi.getPageTypeCode()"
            [uriContext]="wizardApi.uriContext"
            [resultFn]="wizardApi.variationResult"
        ></se-new-page-display-condition>
    `
});
let /* @ngInject */ PageDisplayConditionStepComponent = class /* @ngInject */ PageDisplayConditionStepComponent {
    constructor(wizardApi) {
        this.wizardApi = wizardApi;
    }
};
PageDisplayConditionStepComponent.$inject = ["wizardApi"];
/* @ngInject */ PageDisplayConditionStepComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-condition-step',
        template: `
        <se-event-message
            class="existing-homepage__ymessage"
            [showEvent]="'CMS_EVENT_SHOW_REPLACE_PARENT_HOMEPAGE_INFO'"
            [hideEvent]="'CMS_EVENT_HIDE_REPLACE_PARENT_HOMEPAGE_INFO'"
        >
        </se-event-message>

        <se-new-page-display-condition
            [pageTypeCode]="wizardApi.getPageTypeCode()"
            [uriContext]="wizardApi.uriContext"
            [resultFn]="wizardApi.variationResult"
        ></se-new-page-display-condition>
    `
    }),
    __param(0, core.Inject(smarteditcommons.WIZARD_API)),
    __metadata("design:paramtypes", [Object])
], /* @ngInject */ PageDisplayConditionStepComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageRestrictionsStepComponent", {
    selector: 'se-page-restrictions-step',
    template: `
        <span *ngIf="wizardApi.isRestrictionsActive()" class="se-create-page-restriction-step">
            <div *ngIf="wizardApi.getPageRestrictions().length > 1">
                <se-page-restrictions-info-message></se-page-restrictions-info-message>
            </div>
            <se-restrictions-editor
                [editable]="true"
                [(resetFn)]="wizardApi.restrictionsEditorFunctionBindings.reset"
                [(cancelFn)]="wizardApi.restrictionsEditorFunctionBindings.cancel"
                [(isDirtyFn)]="wizardApi.restrictionsEditorFunctionBindings.isDirty"
                (onRestrictionsChange)="wizardApi.restrictionsResult($event)"
                [getRestrictionTypes]="wizardApi.getRestrictionTypes"
                [getSupportedRestrictionTypes]="wizardApi.getSupportedRestrictionTypes"
                [item]="wizardApi.getPageInfo()"
                [restrictionUuids]="wizardApi.getPageRestrictions()"
            >
            </se-restrictions-editor>
        </span>
    `
});
let /* @ngInject */ PageRestrictionsStepComponent = class /* @ngInject */ PageRestrictionsStepComponent {
    constructor(wizardApi) {
        this.wizardApi = wizardApi;
    }
};
PageRestrictionsStepComponent.$inject = ["wizardApi"];
/* @ngInject */ PageRestrictionsStepComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-restrictions-step',
        template: `
        <span *ngIf="wizardApi.isRestrictionsActive()" class="se-create-page-restriction-step">
            <div *ngIf="wizardApi.getPageRestrictions().length > 1">
                <se-page-restrictions-info-message></se-page-restrictions-info-message>
            </div>
            <se-restrictions-editor
                [editable]="true"
                [(resetFn)]="wizardApi.restrictionsEditorFunctionBindings.reset"
                [(cancelFn)]="wizardApi.restrictionsEditorFunctionBindings.cancel"
                [(isDirtyFn)]="wizardApi.restrictionsEditorFunctionBindings.isDirty"
                (onRestrictionsChange)="wizardApi.restrictionsResult($event)"
                [getRestrictionTypes]="wizardApi.getRestrictionTypes"
                [getSupportedRestrictionTypes]="wizardApi.getSupportedRestrictionTypes"
                [item]="wizardApi.getPageInfo()"
                [restrictionUuids]="wizardApi.getPageRestrictions()"
            >
            </se-restrictions-editor>
        </span>
    `
    }),
    __param(0, core.Inject(smarteditcommons.WIZARD_API)),
    __metadata("design:paramtypes", [Object])
], /* @ngInject */ PageRestrictionsStepComponent);

window.__smartedit__.addDecoratorPayload("Component", "AddPageWizardComponent", {
    selector: 'se-add-page-wizard',
    template: ''
});
let /* @ngInject */ AddPageWizardComponent = class /* @ngInject */ AddPageWizardComponent {
    constructor(wizardManager, pageBuilderFactory, restrictionsStepHandlerFactory, experienceService, confirmationModalService, systemEventService, restrictionTypesService, restrictionsService, pageFacade) {
        this.wizardManager = wizardManager;
        this.pageBuilderFactory = pageBuilderFactory;
        this.restrictionsStepHandlerFactory = restrictionsStepHandlerFactory;
        this.experienceService = experienceService;
        this.confirmationModalService = confirmationModalService;
        this.systemEventService = systemEventService;
        this.restrictionTypesService = restrictionTypesService;
        this.restrictionsService = restrictionsService;
        this.pageFacade = pageFacade;
        // Enumerable methods
        // This way of defining method creates a public field in class instead of prototype method
        // which allows then to be reassigned/extended in ModalWizardTemplateComponent#assignAngularController
        this.getWizardConfig = () => ({
            isFormValid: (stepId) => this.isFormValid(stepId),
            onNext: () => this.onNext(),
            onDone: () => this.onDone(),
            onCancel: () => this.onCancel(),
            steps: [
                {
                    id: this.ADD_PAGE_WIZARD_STEPS.PAGE_TYPE,
                    name: 'se.cms.addpagewizard.pagetype.tabname',
                    title: 'se.cms.addpagewizard.pagetype.title',
                    component: PageTypeStepComponent
                },
                {
                    id: this.ADD_PAGE_WIZARD_STEPS.PAGE_TEMPLATE,
                    name: 'se.cms.addpagewizard.pagetemplate.tabname',
                    title: 'se.cms.addpagewizard.pagetype.title',
                    component: PageTemplateStepComponent
                },
                {
                    id: this.ADD_PAGE_WIZARD_STEPS.PAGE_DISPLAY_CONDITION,
                    name: 'se.cms.addpagewizard.pageconditions.tabname',
                    title: 'se.cms.addpagewizard.pagetype.title',
                    component: PageDisplayConditionStepComponent
                },
                {
                    id: this.ADD_PAGE_WIZARD_STEPS.PAGE_INFO,
                    name: 'se.cms.addpagewizard.pageinfo.tabname',
                    title: 'se.cms.addpagewizard.pagetype.title',
                    component: PageInfoStepComponent
                }
            ]
        });
        this.getRestrictionTypes = () => this.restrictionTypesService.getRestrictionTypesByPageType(this.getPageTypeCode());
        this.getSupportedRestrictionTypes = () => this.restrictionsService.getSupportedRestrictionTypeCodes();
        this.variationResult = (displayConditionResult) => {
            this.pageBuilder.displayConditionSelected(displayConditionResult);
        };
        const restrictionsEditorFunctionBindingsClosure = {}; // bound in the view for restrictions step
        this.uriContext = this.wizardManager.properties.uriContext;
        this.callbacks = {};
        this.restrictionStepProperties = {
            id: 'restrictionsStepId',
            name: 'se.cms.restrictions.editor.tab',
            title: 'se.cms.addpagewizard.pagetype.title',
            component: PageRestrictionsStepComponent
        };
        this.restrictionsEditorFunctionBindings = restrictionsEditorFunctionBindingsClosure;
        this.restrictionsStepHandler = this.restrictionsStepHandlerFactory.createRestrictionsStepHandler(this.wizardManager, restrictionsEditorFunctionBindingsClosure, this.restrictionStepProperties);
        this.pageBuilder = this.pageBuilderFactory.createPageBuilder(this.restrictionsStepHandler, this.uriContext);
        this.saveInProgress = false;
        this.typeChanged = true;
        this.ADD_PAGE_WIZARD_STEPS = {
            PAGE_TYPE: 'pageType',
            PAGE_TEMPLATE: 'pageTemplate',
            PAGE_DISPLAY_CONDITION: 'pageDisplayCondition',
            PAGE_INFO: 'pageInfo',
            PAGE_RESTRICTIONS: this.restrictionsStepHandler.getStepId()
        };
    }
    // Class methods
    typeSelected(pageType) {
        this.typeChanged = true;
        this.pageBuilder.pageTypeSelected(pageType);
    }
    templateSelected(pageTemplate) {
        this.pageBuilder.pageTemplateSelected(pageTemplate);
    }
    getPageTypeCode() {
        return this.pageBuilder.getPageTypeCode();
    }
    restrictionsResult(data) {
        this.pageBuilder.setRestrictions(data.onlyOneRestrictionMustApply, data.restrictionUuids);
    }
    isRestrictionsActive() {
        if (!this.typeChanged ||
            this.wizardManager.getCurrentStepId() === this.ADD_PAGE_WIZARD_STEPS.PAGE_RESTRICTIONS) {
            this.typeChanged = false;
            return true;
        }
        return false;
    }
    getPageInfo() {
        const page = this.pageBuilder.getPage();
        page.uriContext = this.uriContext;
        return page;
    }
    getPageRestrictions() {
        return this.pageBuilder.getPageRestrictions();
    }
    getPageInfoStructure() {
        return this.pageBuilder.getPageInfoStructure();
    }
    isPageInfoActive() {
        return this.wizardManager.getCurrentStepId() === this.ADD_PAGE_WIZARD_STEPS.PAGE_INFO;
    }
    onNext() {
        return Promise.resolve(true);
    }
    onCancel() {
        return this.confirmationModalService.confirm({
            description: 'se.editor.cancel.confirm'
        });
    }
    isFormValid(stepId) {
        switch (stepId) {
            case this.ADD_PAGE_WIZARD_STEPS.PAGE_TYPE:
                return !!this.pageBuilder.getPageTypeCode();
            case this.ADD_PAGE_WIZARD_STEPS.PAGE_TEMPLATE:
                return !!this.pageBuilder.getTemplateUuid();
            case this.ADD_PAGE_WIZARD_STEPS.PAGE_DISPLAY_CONDITION:
                return true;
            case this.ADD_PAGE_WIZARD_STEPS.PAGE_INFO:
                return (!this.saveInProgress &&
                    !!this.callbacks.isDirtyPageInfo &&
                    this.callbacks.isDirtyPageInfo() &&
                    !!this.callbacks.isValidPageInfo &&
                    this.callbacks.isValidPageInfo());
            case this.ADD_PAGE_WIZARD_STEPS.PAGE_RESTRICTIONS:
                return !this.saveInProgress && this.restrictionsStepHandler.isStepValid();
        }
        return false;
    }
    onDone() {
        return __awaiter(this, void 0, void 0, function* () {
            this.saveInProgress = true;
            const page = yield this.callbacks.savePageInfo();
            lodash.defaultsDeep(page, this.pageBuilder.getPage());
            try {
                const pageCreated = yield this.pageFacade.createPage(page);
                this.pageBuilder.setPageUid(pageCreated.uid);
                if (pageCreated.typeCode === 'EmailPage') {
                    this.systemEventService.publishAsync(smarteditcommons.EVENT_CONTENT_CATALOG_UPDATE, pageCreated);
                    return pageCreated;
                }
                yield this.experienceService.loadExperience({
                    siteId: this.uriContext.CURRENT_CONTEXT_SITE_ID,
                    catalogId: this.uriContext.CURRENT_CONTEXT_CATALOG,
                    catalogVersion: this.uriContext.CURRENT_CONTEXT_CATALOG_VERSION,
                    pageId: this.pageBuilder.getPage().uid
                });
            }
            catch (exception) {
                this.saveInProgress = false;
                this.systemEventService.publishAsync(smarteditcommons.GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT, {
                    messages: exception.error.errors
                });
                const errors = exception.error.errors;
                if (!errors.find((error) => error.subject.indexOf('restrictions') === 0)) {
                    this.wizardManager.goToStepWithId(this.ADD_PAGE_WIZARD_STEPS.PAGE_INFO);
                }
                // Reject is required to prevent modal wizard from closing when there's an error.
                return Promise.reject();
            }
        });
    }
};
AddPageWizardComponent.$inject = ["wizardManager", "pageBuilderFactory", "restrictionsStepHandlerFactory", "experienceService", "confirmationModalService", "systemEventService", "restrictionTypesService", "restrictionsService", "pageFacade"];
/* @ngInject */ AddPageWizardComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-add-page-wizard',
        template: ''
    }),
    __param(0, core.Inject(smarteditcommons.WIZARD_MANAGER)),
    __metadata("design:paramtypes", [smarteditcommons.WizardService,
        PageBuilderFactory,
        exports.RestrictionsStepHandlerFactory,
        smarteditcommons.IExperienceService,
        smarteditcommons.IConfirmationModalService,
        smarteditcommons.SystemEventService,
        exports.RestrictionTypesService,
        exports.RestrictionsService,
        PageFacade])
], /* @ngInject */ AddPageWizardComponent);

/* @ngInject */ exports.AddPageWizardService = class /* @ngInject */ AddPageWizardService {
    constructor(modalWizard, catalogService) {
        this.modalWizard = modalWizard;
        this.catalogService = catalogService;
    }
    openAddPageWizard() {
        return __awaiter(this, void 0, void 0, function* () {
            const uriContext = yield this.catalogService.retrieveUriContext();
            return this.modalWizard.open({
                component: AddPageWizardComponent,
                properties: {
                    uriContext
                }
            });
        });
    }
};
exports.AddPageWizardService.$inject = ["modalWizard", "catalogService"];
/* @ngInject */ exports.AddPageWizardService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.ModalWizard, smarteditcommons.ICatalogService])
], /* @ngInject */ exports.AddPageWizardService);

(function (CMSPageOperation) {
    CMSPageOperation["TRASH_PAGE"] = "TRASH_PAGE";
})(exports.CMSPageOperation || (exports.CMSPageOperation = {}));
/* @ngInject */ exports.ManagePageService = class /* @ngInject */ ManagePageService {
    constructor(logService, smarteditRoutingService, alertService, cmsitemsRestService, systemEventService, crossFrameEventService, pageInfoService, confirmationModalService, pagesVariationsRestService, waitDialogService, pageRestoreModalService, pageRestoredAlertService, homepageService, workflowService, catalogService, restServiceFactory, sharedDataService, catalogVersionRestService) {
        this.logService = logService;
        this.smarteditRoutingService = smarteditRoutingService;
        this.alertService = alertService;
        this.cmsitemsRestService = cmsitemsRestService;
        this.systemEventService = systemEventService;
        this.crossFrameEventService = crossFrameEventService;
        this.pageInfoService = pageInfoService;
        this.confirmationModalService = confirmationModalService;
        this.pagesVariationsRestService = pagesVariationsRestService;
        this.waitDialogService = waitDialogService;
        this.pageRestoreModalService = pageRestoreModalService;
        this.pageRestoredAlertService = pageRestoredAlertService;
        this.homepageService = homepageService;
        this.workflowService = workflowService;
        this.catalogService = catalogService;
        this.restServiceFactory = restServiceFactory;
        this.sharedDataService = sharedDataService;
        this.catalogVersionRestService = catalogVersionRestService;
        this.resourcePageOperationsURI = `/cmssmarteditwebservices/v1/sites/${smarteditcommons.PAGE_CONTEXT_SITE_ID}/catalogs/${cmscommons.PAGE_CONTEXT_CATALOG}/pages/:pageId/operations`;
    }
    /**
     * Get the number of soft deleted pages for the provided context.
     */
    getSoftDeletedPagesCount(uriContext) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestParams = {
                pageSize: 10,
                currentPage: 0,
                typeCode: 'AbstractPage',
                itemSearchParams: 'pageStatus:deleted',
                catalogId: uriContext.CURRENT_CONTEXT_CATALOG,
                catalogVersion: uriContext.CURRENT_CONTEXT_CATALOG_VERSION,
                fields: 'BASIC'
            };
            const result = yield this.cmsitemsRestService.get(requestParams);
            return result.pagination.totalCount;
        });
    }
    /**
     * This method triggers the soft deletion of a CMS page.
     *
     * @param pageInfo The page object containing the uuid and the name of the page to be deleted.
     */
    softDeletePage(pageInfo, uriContext) {
        return __awaiter(this, void 0, void 0, function* () {
            const _pageInfo = lodash.cloneDeep(pageInfo);
            const builtURIContext = {
                catalogId: uriContext.CURRENT_CONTEXT_CATALOG,
                catalogVersion: uriContext.CURRENT_CONTEXT_CATALOG_VERSION,
                siteId: uriContext.CURRENT_CONTEXT_SITE_ID
            };
            const confirmationModalDescription = yield this.getConfirmationModalDescription(_pageInfo, uriContext);
            const operationConfirmed = yield this.confirmSoftDelete(confirmationModalDescription, pageInfo.name);
            if (!operationConfirmed) {
                return;
            }
            try {
                _pageInfo.identifier = pageInfo.uuid;
                _pageInfo.pageStatus = smarteditcommons.CMSPageStatus.DELETED;
                yield this.cmsitemsRestService.update(_pageInfo);
                this.crossFrameEventService.publish(smarteditcommons.EVENTS.PAGE_DELETED);
                this.alertService.showSuccess({
                    message: 'se.cms.actionitem.page.trash.alert.success.description',
                    messagePlaceholders: {
                        pageName: pageInfo.name
                    }
                });
                this.smarteditRoutingService.go('/ng/pages/:siteId/:catalogId/:catalogVersion'
                    .replace(':siteId', builtURIContext.siteId)
                    .replace(':catalogId', builtURIContext.catalogId)
                    .replace(':catalogVersion', builtURIContext.catalogVersion));
            }
            catch (exception) {
                this.logService.warn('Something went wrong when soft deleting page', exception);
            }
        });
    }
    /**
     * This method triggers the permanent deletion of a CMS page.
     */
    hardDeletePage(pageInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            const operationConfirmed = yield this.confirmHardDelete(pageInfo.name);
            if (!operationConfirmed) {
                return;
            }
            yield this.cmsitemsRestService.delete(pageInfo.uuid);
            this.alertService.showSuccess('se.cms.page.permanently.delete.alert.success');
            this.systemEventService.publishAsync(smarteditcommons.EVENT_CONTENT_CATALOG_UPDATE);
            this.crossFrameEventService.publish(smarteditcommons.EVENTS.PAGE_DELETED);
        });
    }
    /**
     *  This method triggers the restoration a CMS page.
     */
    restorePage(pageInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            const _pageInfo = lodash.cloneDeep(pageInfo);
            _pageInfo.pageStatus = smarteditcommons.CMSPageStatus.ACTIVE;
            _pageInfo.identifier = pageInfo.uuid;
            this.waitDialogService.showWaitModal(null);
            try {
                const response = yield this.cmsitemsRestService.update(_pageInfo, {
                    headers: { 'Ignore-Interceptor': 'NonValidationErrorInterceptor' }
                });
                this.waitDialogService.hideWaitModal();
                this.systemEventService.publishAsync(smarteditcommons.EVENT_CONTENT_CATALOG_UPDATE, response);
                this.pageRestoredAlertService.displayPageRestoredSuccessAlert(_pageInfo);
                this.crossFrameEventService.publish(smarteditcommons.EVENTS.PAGE_RESTORED);
            }
            catch (exception) {
                const errors = exception.error.errors;
                this.waitDialogService.hideWaitModal();
                this.pageRestoreModalService.handleRestoreValidationErrors(_pageInfo, errors);
            }
        });
    }
    /**
     * This method indicates whether the given page can be soft deleted.
     * Only the following pages are eligible for soft deletion:
     * 1. the variation pages
     * 2. the primary pages associated with no variation pages
     * 3. the page is not in a workflow
     */
    isPageTrashable(cmsPage, uriContext) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const [hasFallbackHomepageOrIsPrimaryWithoutVariations, isInWorkflow] = yield Promise.all([
                    this.hasFallbackHomepageOrIsPrimaryWithoutVariations(cmsPage, uriContext),
                    this.workflowService.isPageInWorkflow(cmsPage)
                ]);
                return hasFallbackHomepageOrIsPrimaryWithoutVariations && !isInWorkflow;
            }
            catch (_a) {
                return false;
            }
        });
    }
    /**
     * Determines whether page can be cloned or not
     *
     * Checks if there is permission for given page in given catalog version to be cloned
     * This method uses only "outer" parts for that check so there is no need for iframe to be available
     *
     * !NOTE: Logic here is very similar to logic used in RulesAndPermissionsRegistrationService where "se.cloneable.page" rule is registered.
     * So if any changes are done here it should be considered to adjust those changes in mentioned service as well.
     *
     */
    isPageCloneable(pageUuid, catalogVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            const catalogDescriptor = (yield this.sharedDataService.get(smarteditcommons.EXPERIENCE_STORAGE_KEY)).catalogDescriptor;
            const pageUriContext = {
                CURRENT_CONTEXT_SITE_ID: catalogDescriptor.siteId,
                CURRENT_CONTEXT_CATALOG: catalogDescriptor.catalogId,
                CURRENT_CONTEXT_CATALOG_VERSION: catalogDescriptor.catalogVersion
            };
            const [catalogs, pageInfo, targets] = yield Promise.all([
                this.catalogService.getContentCatalogsForSite(catalogDescriptor.siteId),
                this.cmsitemsRestService.getById(pageUuid),
                this.catalogVersionRestService.getCloneableTargets(pageUriContext)
            ]);
            // Inspired by ExperienceServiceOuter#updateExperiencePageContext
            const pageContext = catalogs
                // merge catalog and catalog.parents into one array to simplify searching
                .reduce((acc, catalog) => {
                if (catalog.parents && catalog.parents.length) {
                    acc = acc.concat(catalog.parents);
                }
                return acc;
            }, [...catalogs])
                // flattening versions
                .reduce((acc, catalog) => acc.concat(catalog.versions), [])
                // finding demanded version
                .find((version) => version.uuid === catalogVersion);
            if (pageContext === null || pageContext === void 0 ? void 0 : pageContext.active) {
                return targets.versions.length > 0 && !pageInfo.copyToCatalogsDisabled;
            }
            return targets.versions.length > 0;
        });
    }
    /**
     * Get the disabled trash tooltip message.
     */
    getDisabledTrashTooltipMessage(pageInfo, uriContext) {
        return __awaiter(this, void 0, void 0, function* () {
            let translate = 'se.cms.tooltip.movetotrash';
            const isPageInWorkflow = yield this.workflowService.isPageInWorkflow(pageInfo);
            const homepageType = yield this.homepageService.getHomepageType(pageInfo, uriContext);
            if (homepageType === exports.HomepageType.CURRENT) {
                translate = 'se.cms.tooltip.current.homepage.movetotrash';
            }
            else if (homepageType === exports.HomepageType.OLD) {
                translate = 'se.cms.tooltip.old.homepage.movetotrash';
            }
            else if (isPageInWorkflow) {
                translate = 'se.cms.tooltip.page.in.workflow.movetotrash';
            }
            return translate;
        });
    }
    /**
     * Will trash the given page in the corresponding active catalog version.
     */
    trashPageInActiveCatalogVersion(pageUid) {
        return __awaiter(this, void 0, void 0, function* () {
            const uriContext = yield this.catalogService.retrieveUriContext();
            const activeVersion = yield this.catalogService.getContentCatalogActiveVersion(uriContext);
            const operationConfirmed = yield this.confirmTrashingPageInActiveCatalogVersion(activeVersion);
            if (!operationConfirmed) {
                return;
            }
            try {
                this.pageOperationsRESTService = this.restServiceFactory.get(this.resourcePageOperationsURI.replace(':pageId', pageUid));
                yield this.pageOperationsRESTService.save({
                    operation: 'TRASH_PAGE',
                    sourceCatalogVersion: uriContext.CURRENT_CONTEXT_CATALOG_VERSION,
                    targetCatalogVersion: activeVersion
                });
                this.alertService.showSuccess({
                    message: 'se.cms.sync.page.status.success.alert',
                    messagePlaceholders: {
                        pageId: pageUid,
                        catalogVersion: activeVersion
                    }
                });
            }
            catch (exception) {
                this.logService.warn('trashPageInActiveCatalogVersion - page could not be trashed', exception);
            }
        });
    }
    getConfirmationModalDescription(pageInfo, uriContext) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const pageUUID = yield this.pageInfoService.getPageUUID();
                if (!pageUUID) {
                    this.logService.error('deletePageService::deletePage - pageUUID is undefined');
                    return Promise.reject();
                }
                const homepageType = yield this.homepageService.getHomepageType(pageInfo, uriContext);
                if (homepageType !== null || pageInfo.homepage) {
                    return 'se.cms.actionitem.page.trash.confirmation.description.storefront.homepage';
                }
                return 'se.cms.actionitem.page.trash.confirmation.description.storefront';
            }
            catch (_a) {
                return 'se.cms.actionitem.page.trash.confirmation.description.pagelist';
            }
        });
    }
    confirmSoftDelete(description, pageName) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.confirmationModalService.confirm({
                    description,
                    descriptionPlaceholders: {
                        pageName
                    },
                    title: 'se.cms.actionitem.page.trash.confirmation.title'
                });
                return true;
            }
            catch (_a) {
                return false;
            }
        });
    }
    confirmHardDelete(pageName) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.confirmationModalService.confirm({
                    title: 'se.cms.actionitem.page.permanently.delete.confirmation.title',
                    description: 'se.cms.actionitem.page.permanently.delete.confirmation.description',
                    descriptionPlaceholders: {
                        pageName
                    }
                });
                return true;
            }
            catch (_a) {
                return false;
            }
        });
    }
    confirmTrashingPageInActiveCatalogVersion(activeVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.confirmationModalService.confirm({
                    title: 'se.cms.sync.page.status.confirm.title',
                    description: 'se.cms.sync.page.status.confirm.description',
                    descriptionPlaceholders: {
                        catalogVersion: activeVersion
                    }
                });
                return true;
            }
            catch (_a) {
                return false;
            }
        });
    }
    hasFallbackHomepageOrIsPrimaryWithoutVariations(cmsPage, uriContext) {
        return __awaiter(this, void 0, void 0, function* () {
            const homepageType = yield this.homepageService.getHomepageType(cmsPage, uriContext);
            if (homepageType !== null || cmsPage.homepage) {
                return this.homepageService.hasFallbackHomePage(uriContext);
            }
            const variationPagesUids = yield this.pagesVariationsRestService.getVariationsForPrimaryPageId(cmsPage.uid);
            return variationPagesUids.length === 0;
        });
    }
};
exports.ManagePageService.$inject = ["logService", "smarteditRoutingService", "alertService", "cmsitemsRestService", "systemEventService", "crossFrameEventService", "pageInfoService", "confirmationModalService", "pagesVariationsRestService", "waitDialogService", "pageRestoreModalService", "pageRestoredAlertService", "homepageService", "workflowService", "catalogService", "restServiceFactory", "sharedDataService", "catalogVersionRestService"];
__decorate([
    smarteditcommons.Cached({
        actions: [smarteditcommons.rarelyChangingContent],
        tags: [smarteditcommons.pageDeletionEvictionTag, smarteditcommons.pageRestoredEvictionTag]
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], /* @ngInject */ exports.ManagePageService.prototype, "getSoftDeletedPagesCount", null);
/* @ngInject */ exports.ManagePageService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.LogService,
        smarteditcommons.SmarteditRoutingService,
        smarteditcommons.IAlertService,
        smarteditcommons.CmsitemsRestService,
        smarteditcommons.SystemEventService,
        smarteditcommons.CrossFrameEventService,
        smarteditcommons.IPageInfoService,
        smarteditcommons.IConfirmationModalService,
        PagesVariationsRestService,
        smarteditcommons.IWaitDialogService,
        exports.PageRestoreModalService,
        exports.PageRestoredAlertService,
        exports.HomepageService,
        smarteditcommons.WorkflowService,
        smarteditcommons.ICatalogService,
        smarteditcommons.IRestServiceFactory,
        smarteditcommons.ISharedDataService,
        CatalogVersionRestService])
], /* @ngInject */ exports.ManagePageService);

/* @ngInject */ exports.PageTreeComponentMenuService = class /* @ngInject */ PageTreeComponentMenuService {
    constructor(editorEnablerService, componentMenuConditionAndCallbackService, permissionService) {
        this.editorEnablerService = editorEnablerService;
        this.componentMenuConditionAndCallbackService = componentMenuConditionAndCallbackService;
        this.permissionService = permissionService;
        // Menus are displayed from left to right in the order in array
        this.originalMenus = [
            {
                key: 'externalcomponentbutton',
                i18nKey: 'se.cms.contextmenu.title.externalcomponent',
                displayIconClass: 'sap-icon--globe',
                permissions: [],
                condition: (configuration) => __awaiter(this, void 0, void 0, function* () {
                    if (configuration.isComponentHidden) {
                        return Promise.resolve(false);
                    }
                    else {
                        return this.componentMenuConditionAndCallbackService.externalCondition(configuration);
                    }
                }),
                action: {
                    component: cmscommons.ExternalComponentButtonComponent
                }
            },
            {
                key: 'se.cms.sharedcomponentbutton',
                i18nKey: 'se.cms.contextmenu.title.shared.component',
                displayIconClass: 'sap-icon--chain-link',
                permissions: [],
                condition: (configuration) => __awaiter(this, void 0, void 0, function* () {
                    if (configuration.isComponentHidden) {
                        return Promise.resolve(false);
                    }
                    else {
                        return this.componentMenuConditionAndCallbackService.sharedCondition(configuration);
                    }
                }),
                action: {
                    component: cmscommons.SharedComponentButtonComponent
                }
            },
            {
                key: 'se.cms.edit',
                i18nKey: 'se.cms.contextmenu.title.edit',
                displayIconClass: 'sap-icon--edit',
                permissions: ['se.context.menu.edit.component'],
                action: {
                    callback: this.editorEnablerService.onClickEditButton
                },
                condition: (configuration) => __awaiter(this, void 0, void 0, function* () {
                    if (configuration.isComponentHidden) {
                        return this.componentMenuConditionAndCallbackService.editConditionForHiddenComponent(configuration);
                    }
                    else {
                        return this.editorEnablerService.isSlotEditableForNonExternalComponent(configuration);
                    }
                })
            },
            {
                key: 'se.cms.remove',
                i18nKey: 'se.cms.contextmenu.title.remove',
                displayIconClass: 'sap-icon--decline',
                permissions: ['se.context.menu.remove.component'],
                action: {
                    callback: this.componentMenuConditionAndCallbackService.removeCallback
                },
                condition: this.componentMenuConditionAndCallbackService.removeCondition
            },
            {
                key: 'clonecomponentbutton',
                i18nKey: 'se.cms.contextmenu.title.clone.component',
                displayIconClass: 'sap-icon--duplicate',
                permissions: ['se.clone.component'],
                action: {
                    callback: this.componentMenuConditionAndCallbackService.cloneCallback
                },
                condition: this.componentMenuConditionAndCallbackService.cloneCondition
            }
        ];
    }
    getPageTreeComponentMenus(configuration) {
        return __awaiter(this, void 0, void 0, function* () {
            const menus = yield this.buildMenusByPermission();
            const promises = menus.map((item) => __awaiter(this, void 0, void 0, function* () {
                if (!item.condition) {
                    return item;
                }
                const isItemEnabled = yield item.condition(configuration);
                return isItemEnabled ? item : null;
            }));
            return Promise.all(promises);
        });
    }
    buildMenusByPermission() {
        return __awaiter(this, void 0, void 0, function* () {
            const menus = yield Promise.all(this.originalMenus.map((item) => __awaiter(this, void 0, void 0, function* () {
                if (!item.permissions || item.permissions.length === 0) {
                    return item;
                }
                const allowed = yield this.permissionService.isPermitted([
                    {
                        names: item.permissions
                    }
                ]);
                if (allowed) {
                    return item;
                }
                return null;
            })));
            return menus.filter((menu) => !!menu);
        });
    }
};
exports.PageTreeComponentMenuService.$inject = ["editorEnablerService", "componentMenuConditionAndCallbackService", "permissionService"];
/* @ngInject */ exports.PageTreeComponentMenuService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [cmscommons.IEditorEnablerService,
        cmscommons.IComponentMenuConditionAndCallbackService,
        smarteditcommons.IPermissionService])
], /* @ngInject */ exports.PageTreeComponentMenuService);

const INTERVAL_RETRIES = 20;
const INTERVAL_MILLISEC = 300;
/**
 * Used to build extra information for page tree nodes such as get slot node's hidden components,
 *  get component node's information from backend by uuid
 * */
/* @ngInject */ exports.NodeInfoService = class /* @ngInject */ NodeInfoService {
    constructor(crossFrameEventService, cmsitemsRestService, logService, slotVisibilityService, pageTreeNodeService) {
        this.crossFrameEventService = crossFrameEventService;
        this.cmsitemsRestService = cmsitemsRestService;
        this.logService = logService;
        this.slotVisibilityService = slotVisibilityService;
        this.pageTreeNodeService = pageTreeNodeService;
        this.treeNodes = [];
        this.crossFrameEventService.subscribe(smarteditcommons.EVENT_PAGE_TREE_SLOT_NEED_UPDATE, (_eventId, eventData) => this.updatePartTreeNodesInfoBySlotUuid(eventData));
    }
    buildNodesInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const nodes = yield this.pageTreeNodeService.getSlotNodes();
            this.treeNodes = yield Promise.all(nodes.map((node) => __awaiter(this, void 0, void 0, function* () { return this.addMoreInfoToOneNode(node); })));
            return this.treeNodes;
        });
    }
    updatePartTreeNodesInfo(updatedNodes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.treeNodes = yield Promise.all(this.treeNodes.map((node) => __awaiter(this, void 0, void 0, function* () {
                if (Object.keys(updatedNodes).includes(node.elementUuid)) {
                    node.childrenNode = updatedNodes[node.elementUuid];
                    return this.addMoreInfoToOneNode(node);
                }
                else {
                    return node;
                }
            })));
            return this.treeNodes;
        });
    }
    updatePartTreeNodesInfoBySlotUuid(slotUuid) {
        return __awaiter(this, void 0, void 0, function* () {
            this.treeNodes = yield Promise.all(this.treeNodes.map((node) => __awaiter(this, void 0, void 0, function* () {
                if (node.componentUuid === slotUuid) {
                    return this.addMoreInfoToOneNode(node);
                }
                else {
                    return node;
                }
            })));
            return this.treeNodes;
        });
    }
    publishComponentSelected(component, activeSlot, slotElementUuid) {
        // Should active the slot of this component
        if (activeSlot) {
            this.crossFrameEventService.publish(smarteditcommons.EVENT_PAGE_TREE_SLOT_SELECTED, {
                elementUuid: slotElementUuid,
                active: true
            });
        }
        // Active the component itself
        this.crossFrameEventService.publish(smarteditcommons.EVENT_PAGE_TREE_COMPONENT_SELECTED, {
            elementUuid: component.elementUuid,
            active: component.isExpanded
        });
    }
    publishSlotSelected(slot) {
        // Active the slot itself
        this.crossFrameEventService.publish(smarteditcommons.EVENT_PAGE_TREE_SLOT_SELECTED, {
            elementUuid: slot.elementUuid,
            active: slot.isExpanded
        });
        // To make other active component become inactive
        this.crossFrameEventService.publish(smarteditcommons.EVENT_PAGE_TREE_COMPONENT_SELECTED, {
            elementUuid: slot.elementUuid,
            active: slot.isExpanded
        });
    }
    addMoreInfoToOneNode(node) {
        return __awaiter(this, void 0, void 0, function* () {
            const hiddenComponents = yield this.slotVisibilityService.getHiddenComponents(node.componentId);
            const childUuids = node.childrenNode.map((child) => child.componentUuid);
            const displayComponents = yield this.getComponentsDataByUUIDs(childUuids);
            let componentNodes = displayComponents.map((component) => this.buildDisplayComponentNode(component, node));
            componentNodes = componentNodes.concat(hiddenComponents.map((component) => this.buildHiddenComponentNode(component)));
            return Object.assign(Object.assign({}, node), { componentNodes });
        });
    }
    getComponentsDataByUUIDs(uuids) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.cmsitemsRestService.getByIds(uuids, 'DEFAULT');
                return Promise.resolve((data.response ? data.response : [data]));
            }
            catch (error) {
                this.logService.error('SlotInfoService:: getSlotsDataByUUIDs error:', error.message);
            }
        });
    }
    buildHiddenComponentNode(component) {
        const elementUuid = smarteditcommons.stringUtils.generateIdentifier();
        return Object.assign({ isHidden: true, isExpanded: false, componentNodes: [], elementUuid }, component);
    }
    buildDisplayComponentNode(component, slot) {
        const node = slot.childrenNode.find((child) => child.componentUuid === component.uuid);
        const { componentId, componentUuid, componentTypeFromPage, containerId, containerType, catalogVersionUuid, elementUuid } = node;
        return Object.assign({ isHidden: false, isExpanded: false, componentId,
            componentUuid,
            componentTypeFromPage,
            containerId,
            containerType,
            catalogVersionUuid,
            elementUuid, componentNodes: [] }, component);
    }
};
exports.NodeInfoService.$inject = ["crossFrameEventService", "cmsitemsRestService", "logService", "slotVisibilityService", "pageTreeNodeService"];
/* @ngInject */ exports.NodeInfoService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.CrossFrameEventService,
        smarteditcommons.CmsitemsRestService,
        smarteditcommons.LogService,
        cmscommons.ISlotVisibilityService,
        smarteditcommons.IPageTreeNodeService])
], /* @ngInject */ exports.NodeInfoService);

const NON_SUPPORTED_TEMPLATES = [
    'layout/landingLayout1Page',
    'layout/landingLayout3Page',
    'layout/landingLayout4Page',
    'layout/landingLayout5Page',
    'layout/landingLayout6Page',
    'layout/landingLayoutPage',
    'account/accountRegisterPage',
    'checkout/checkoutRegisterPage'
];
/* @ngInject */ exports.PageTemplateService = class /* @ngInject */ PageTemplateService {
    constructor(restServiceFactory) {
        this.pageTemplateRestService = restServiceFactory.get(cmscommons.PAGE_TEMPLATES_URI);
    }
    getPageTemplatesForType(uriContext, pageType) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = Object.assign({ pageTypeCode: pageType, active: true }, uriContext);
            const pageTemplates = yield this.pageTemplateRestService.get(params);
            return {
                templates: pageTemplates.templates.filter((pageTemplate) => !NON_SUPPORTED_TEMPLATES.includes(pageTemplate.frontEndName))
            };
        });
    }
};
exports.PageTemplateService.$inject = ["restServiceFactory"];
/* @ngInject */ exports.PageTemplateService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.IRestServiceFactory])
], /* @ngInject */ exports.PageTemplateService);

/* @ngInject */ exports.RemoveComponentService = class /* @ngInject */ RemoveComponentService extends cmscommons.IRemoveComponentService {
};
/* @ngInject */ exports.RemoveComponentService = __decorate([
    smarteditcommons.GatewayProxied('removeComponent'),
    smarteditcommons.SeDowngradeService(cmscommons.IRemoveComponentService)
], /* @ngInject */ exports.RemoveComponentService);

/* @ngInject */ exports.SlotRestrictionsService = class /* @ngInject */ SlotRestrictionsService extends smarteditcommons.ISlotRestrictionsService {
};
/* @ngInject */ exports.SlotRestrictionsService = __decorate([
    smarteditcommons.SeDowngradeService(smarteditcommons.ISlotRestrictionsService),
    smarteditcommons.GatewayProxied('getAllComponentTypesSupportedOnPage', 'getSlotRestrictions')
], /* @ngInject */ exports.SlotRestrictionsService);

/* @ngInject */ exports.SyncPollingService = class /* @ngInject */ SyncPollingService extends smarteditcommons.ISyncPollingService {
    constructor(logService, pageInfoService, experienceService, catalogService, synchronizationResourceService, crossFrameEventService, systemEventService, timerService) {
        super();
        this.logService = logService;
        this.pageInfoService = pageInfoService;
        this.experienceService = experienceService;
        this.catalogService = catalogService;
        this.synchronizationResourceService = synchronizationResourceService;
        this.crossFrameEventService = crossFrameEventService;
        this.systemEventService = systemEventService;
        this.timerService = timerService;
        this.SYNC_POLLING_THROTTLE = 500;
        this.syncStatus = {};
        this.triggers = new Set();
        this.syncPollingTimer = null;
        this.refreshInterval = null;
        this.syncPageObservableMap = new Map();
        this.initSyncPolling();
    }
    performSync(array, uriContext) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentPageFromActiveCatalog = yield this.isCurrentPageFromActiveCatalog();
            if (currentPageFromActiveCatalog) {
                return Promise.reject();
            }
            const activeVersion = yield this.catalogService.getContentCatalogActiveVersion(uriContext);
            return this.synchronizationResourceService
                .getPageSynchronizationPostRestService(uriContext)
                .save({
                target: activeVersion,
                items: array
            });
        });
    }
    getSyncStatus(pageUUID, uriContext, forceGetSynchronization) {
        return __awaiter(this, void 0, void 0, function* () {
            if (forceGetSynchronization) {
                this.clearSyncPageObservableMap();
            }
            if (this.syncStatus[pageUUID] &&
                pageUUID === this.syncStatus[pageUUID].itemId &&
                !forceGetSynchronization) {
                return this.syncStatus[pageUUID];
            }
            let _pageUUID;
            try {
                _pageUUID = yield this.getPageUUID(pageUUID);
            }
            catch (_a) {
                this.logService.error('syncPollingService::getSyncStatus - failed call to getPageUUID');
                this.syncPollingTimer.stop();
                return this.fetchSyncStatus(pageUUID, uriContext);
            }
            try {
                const syncStatus = yield this.fetchSyncStatus(_pageUUID, uriContext);
                const syncPollingType = this.getSyncPollingTypeFromInterval(this.refreshInterval);
                this.startSync(syncPollingType);
                return syncStatus;
            }
            catch (_b) {
                this.logService.error('syncPollingService::getSyncStatus - failed call to fetchSyncStatus');
                return Promise.reject();
            }
        });
    }
    fetchSyncStatus(_pageUUID, uriContext) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const pageUUID = yield this.getPageUUID(_pageUUID);
                if (!pageUUID) {
                    return {};
                }
                const currentPageFromActiveCatalog = yield this.isCurrentPageFromActiveCatalog();
                if (currentPageFromActiveCatalog) {
                    return Promise.reject();
                }
                const activeVersion = yield this.catalogService.getContentCatalogActiveVersion(uriContext);
                const uniqueKeyForPage = smarteditcommons.stringUtils.encode(pageUUID);
                const syncPageObservable = this.syncPageObservableMap.get(uniqueKeyForPage);
                // Re-use pre-existing Observable to avoid concurrent HTTP call to the same synchronization url.
                return syncPageObservable
                    ? syncPageObservable.toPromise()
                    : this.fetchPageSynchronization(activeVersion, pageUUID, uriContext).toPromise();
            }
            catch (err) {
                this.stopSync();
                this.logService.warn(err);
            }
        });
    }
    /*
     * This method is used to change the speed (up/down) of the sync polling. EventId could be syncPollingSpeedUp or syncPollingSlowDown.
     * If multiple services are changing the speed of the polling and in order to differentiate between them 'key' must to be used and it should be unique among the services.
     * For example: key could be servicePrefix + pageUuid/itemId
     * If at least one service needs fast polling, refreshInterval will be set to fast polling. If none of them needs fast polling, refreshInterval will be set to slow polling.
     */
    changePollingSpeed(eventId, key) {
        if (eventId === cmscommons.DEFAULT_SYNCHRONIZATION_POLLING.SPEED_UP) {
            this.syncStatus = {};
            if (key && !this.triggers.has(key)) {
                this.triggers.add(key);
            }
            this.refreshInterval = cmscommons.DEFAULT_SYNCHRONIZATION_POLLING.FAST_POLLING_TIME;
        }
        else {
            if (key) {
                this.triggers.delete(key);
            }
            if (this.triggers.size === 0) {
                this.refreshInterval = cmscommons.DEFAULT_SYNCHRONIZATION_POLLING.SLOW_POLLING_TIME;
            }
        }
        this.syncPollingTimer.restart(this.refreshInterval);
    }
    fetchPageSynchronization(activeVersion, pageUUID, uriContext) {
        const syncObservable = rxjs.from(this.getPageSlotSyncStatus(uriContext, pageUUID, activeVersion));
        const uniqueKeyForPage = smarteditcommons.stringUtils.encode(pageUUID);
        this.syncPageObservableMap.set(uniqueKeyForPage, syncObservable);
        return syncObservable.pipe(operators$1.share());
    }
    getPageSlotSyncStatus(uriContext, pageUUID, activeVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            const syncStatus = yield this.synchronizationResourceService
                .getPageSynchronizationGetRestService(uriContext)
                .get({
                pageUid: pageUUID,
                target: activeVersion
            });
            const lastSyncStatus = this.syncStatus[syncStatus.itemId];
            if (JSON.stringify(syncStatus) !== JSON.stringify(lastSyncStatus)) {
                this.crossFrameEventService.publish(cmscommons.DEFAULT_SYNCHRONIZATION_POLLING.FAST_FETCH, syncStatus);
                if (!lastSyncStatus ||
                    syncStatus.lastModifiedDate !== lastSyncStatus.lastModifiedDate ||
                    syncStatus.status !== lastSyncStatus.status) {
                    this.crossFrameEventService.publish(cmscommons.CMSITEMS_UPDATE_EVENT);
                    this.crossFrameEventService.publish(smarteditcommons.EVENTS.PAGE_UPDATED, {
                        uuid: pageUUID
                    });
                }
            }
            this.syncStatus[syncStatus.itemId] = syncStatus;
            this.clearSyncPageObservableMap();
            return syncStatus;
        });
    }
    stopSync() {
        if (this.syncPollingTimer.isActive()) {
            this.syncPollingTimer.stop();
        }
        this.clearSyncStatus();
    }
    startSync(syncPollingType) {
        if (!this.syncPollingTimer.isActive()) {
            this.changePollingSpeed(syncPollingType || cmscommons.DEFAULT_SYNCHRONIZATION_POLLING.SLOW_DOWN);
        }
    }
    initSyncPolling() {
        this.refreshInterval = cmscommons.DEFAULT_SYNCHRONIZATION_POLLING.SLOW_POLLING_TIME;
        /**
         * When multiple items needs sync polling at different paces (either slow or fast),
         * triggers array makes sure to set to fast polling even if any one of them needs fast polling.
         */
        this.triggers.clear();
        this.syncStatus = {};
        const changePolling = this.changePollingSpeed.bind(this);
        this.systemEventService.subscribe(cmscommons.DEFAULT_SYNCHRONIZATION_POLLING.SPEED_UP, changePolling);
        this.systemEventService.subscribe(cmscommons.DEFAULT_SYNCHRONIZATION_POLLING.SLOW_DOWN, changePolling);
        this.crossFrameEventService.subscribe(cmscommons.DEFAULT_SYNCHRONIZATION_POLLING.FETCH_SYNC_STATUS_ONCE, (eventId, pageUUID) => {
            this.fetchSyncStatus(pageUUID);
        });
        this.crossFrameEventService.subscribe(smarteditcommons.OVERLAY_RERENDERED_EVENT, lodash.throttle(() => {
            if (this.syncPollingTimer.isActive()) {
                this.fetchSyncStatus();
            }
        }, this.SYNC_POLLING_THROTTLE));
        this.crossFrameEventService.subscribe(smarteditcommons.EVENTS.PAGE_CHANGE, () => {
            this.clearSyncStatus();
            this.clearSyncPageObservableMap();
        });
        this.crossFrameEventService.subscribe(cmscommons.DEFAULT_SYNCHRONIZATION_EVENT.CATALOG_SYNCHRONIZED, () => {
            this.syncStatus = {};
            this.fetchSyncStatus();
        });
        // fetchSyncStatus callback uses current page uuid by default
        this.syncPollingTimer = this.timerService.createTimer(() => this.fetchSyncStatus(), this.refreshInterval);
        // start sync polling if it is a storefront page
        if (smarteditcommons.windowUtils.getGatewayTargetFrame()) {
            const syncPollingType = this.getSyncPollingTypeFromInterval(this.refreshInterval);
            this.startSync(syncPollingType);
        }
    }
    clearSyncPageObservableMap() {
        this.syncPageObservableMap.clear();
    }
    clearSyncStatus() {
        this.syncStatus = {};
    }
    getPageUUID(_pageUUID) {
        return !smarteditcommons.stringUtils.isBlank(_pageUUID)
            ? Promise.resolve(_pageUUID)
            : this.pageInfoService.getPageUUID();
    }
    isCurrentPageFromActiveCatalog() {
        return __awaiter(this, void 0, void 0, function* () {
            const currentExperience = yield this.experienceService.getCurrentExperience();
            return currentExperience.pageContext
                ? currentExperience.pageContext.active
                : currentExperience.catalogDescriptor.active;
        });
    }
    getSyncPollingTypeFromInterval(interval) {
        return interval === cmscommons.DEFAULT_SYNCHRONIZATION_POLLING.FAST_POLLING_TIME
            ? cmscommons.DEFAULT_SYNCHRONIZATION_POLLING.SPEED_UP
            : cmscommons.DEFAULT_SYNCHRONIZATION_POLLING.SLOW_DOWN;
    }
};
exports.SyncPollingService.$inject = ["logService", "pageInfoService", "experienceService", "catalogService", "synchronizationResourceService", "crossFrameEventService", "systemEventService", "timerService"];
__decorate([
    smarteditcommons.InvalidateCache(smarteditcommons.cmsitemsEvictionTag),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], /* @ngInject */ exports.SyncPollingService.prototype, "performSync", null);
/* @ngInject */ exports.SyncPollingService = __decorate([
    smarteditcommons.SeDowngradeService(smarteditcommons.ISyncPollingService),
    smarteditcommons.GatewayProxied('getSyncStatus', 'fetchSyncStatus', 'changePollingSpeed', 'registerSyncPollingEvents', 'performSync'),
    __metadata("design:paramtypes", [smarteditcommons.LogService,
        smarteditcommons.IPageInfoService,
        smarteditcommons.IExperienceService,
        smarteditcommons.ICatalogService,
        cmscommons.SynchronizationResourceService,
        smarteditcommons.CrossFrameEventService,
        smarteditcommons.SystemEventService,
        smarteditcommons.TimerService])
], /* @ngInject */ exports.SyncPollingService);

/* @ngInject */ exports.SlotVisibilityService = class /* @ngInject */ SlotVisibilityService extends cmscommons.ISlotVisibilityService {
};
/* @ngInject */ exports.SlotVisibilityService = __decorate([
    smarteditcommons.SeDowngradeService(cmscommons.ISlotVisibilityService),
    smarteditcommons.GatewayProxied('getHiddenComponents')
], /* @ngInject */ exports.SlotVisibilityService);

/* @ngInject */ exports.ComponentMenuConditionAndCallbackService = class /* @ngInject */ ComponentMenuConditionAndCallbackService extends cmscommons.IComponentMenuConditionAndCallbackService {
};
/* @ngInject */ exports.ComponentMenuConditionAndCallbackService = __decorate([
    smarteditcommons.SeDowngradeService(cmscommons.IComponentMenuConditionAndCallbackService),
    smarteditcommons.GatewayProxied('externalCondition', 'removeCondition', 'removeCallback', 'cloneCondition', 'cloneCallback', 'sharedCondition', 'editConditionForHiddenComponent')
], /* @ngInject */ exports.ComponentMenuConditionAndCallbackService);

window.__smartedit__.addDecoratorPayload("Component", "ComponentItemComponent", {
    selector: 'se-component-item',
    template: `<div class="se-component-item" [ngClass]="{ 'se-component-item--disabled': isComponentDisabled, 'smartEditComponent': !isComponentDisabled }" [attr.data-smartedit-component-id]="componentInfo.uid" [attr.data-smartedit-component-uuid]="componentInfo.uuid" [attr.data-smartedit-component-type]="componentInfo.typeCode"><se-tooltip *ngIf="isComponentDisabled" class="se-component-item__tooltip" [appendTo]="'body'" [placement]="'bottom'" [triggers]="['mouseenter', 'mouseleave']" [additionalClasses]="['se-component-item__tooltip--for-disabled']"><div se-tooltip-trigger class="se-component-item--disabled-overlay"></div><div se-tooltip-body class="se-popover--inner-content" translate="se.cms.component.non.cloneable.tooltip" [translateParams]="{ componentName: componentInfo.name }"></div></se-tooltip><div class="se-component-item--image"><span class="sap-icon--card"></span><div *ngIf="isSharedComponent"><span class="se-component-item--image-shared--background"></span> <span class="glyphicon glyphicon-link se-component-item--image-shared"></span></div></div><div class="se-component-item--details-container"><div class="se-component-item--details" title="{{ componentInfo.name }} - {{ componentInfo.typeCode }}"><div class="se-component-item--details-name">{{ componentInfo.name }}</div><div class="se-component-item--details-type">{{ componentInfo.typeCode }}</div></div><se-tooltip *ngIf="!componentInfo.visible" [appendTo]="'body'" [triggers]="['mouseenter', 'mouseleave']" [additionalClasses]="['se-component-item--visibility']"><span se-tooltip-trigger class="hyicon hyicon-unpowered"></span><div se-tooltip-body translate="se.cms.component.display.off.tooltip"></div></se-tooltip></div></div>`,
    styles: [`se-component-item .se-component-item--disabled,se-component-item .se-component-item--disabled:active,se-component-item .se-component-item--disabled:hover{border:2px solid transparent}se-component-item .se-component-item--disabled-overlay{cursor:not-allowed;position:absolute;z-index:1;height:100%;width:100%;left:0;top:0;background:#d9d9d9;border-radius:4px;opacity:.5}se-component-item .se-component-item--details-container{display:flex}se-component-item .se-component-item--details-name{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;color:#51555a;width:100%}se-component-item .se-component-item--image-shared--background{position:absolute;top:0;left:0;width:0;height:0;border-style:solid;border-width:13px;border-color:#354a5f transparent transparent #354a5f;border-radius:4px 0 0 0}se-component-item .se-component-item--image-shared{font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;position:absolute;top:2px;left:2px;transform:rotate(3deg)}se-component-item .se-component-item--visibility,se-component-item .se-component-item--visibility .fd-popover__control,se-component-item .se-component-item--visibility>div{width:100%;height:100%}se-component-item .se-component-item__tooltip{display:block;height:100%;width:100%;position:absolute;left:0;top:0}se-component-item .se-component-item__tooltip--for-disabled,se-component-item .se-component-item__tooltip--for-disabled .fd-popover__control,se-component-item .se-component-item__tooltip--for-disabled>div{width:100%;height:100%}`, `.se-component-item{display:flex;flex-direction:row;align-items:center;position:relative;width:270px;padding:8px;margin:4px 8px 0;border:2px solid transparent;cursor:grab}.se-component-item:active,.se-component-item:hover{border:2px dashed #d9d9d9;border-radius:4px}.se-component-item:active{cursor:grabbing}.se-component-item--details-type{color:#51555a;overflow:hidden;text-overflow:ellipsis}.se-component-item--image{display:flex;flex-direction:row;align-items:center;justify-content:center;font-size:1.4285714286rem;line-height:1.4;font-weight:400;height:36px;width:36px;position:relative;background:#2b78c5;margin-right:8px;color:#fff;border-radius:4px}.se-component-item--details,.se-component-item--details-type{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;width:200px}.se-component-item--details-type{color:#6a6d70}`],
    encapsulation: core.ViewEncapsulation.None,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ ComponentItemComponent = class /* @ngInject */ ComponentItemComponent {
    constructor(componentSharedService, cdr) {
        this.componentSharedService = componentSharedService;
        this.cdr = cdr;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.isSharedComponent = yield this.componentSharedService.isComponentShared(this.componentInfo);
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    ngOnChanges(changes) {
        if (changes.cloneOnDrop) {
            this.isComponentDisabled = this.cloneOnDrop && !this.componentInfo.cloneable;
        }
    }
};
ComponentItemComponent.$inject = ["componentSharedService", "cdr"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ ComponentItemComponent.prototype, "componentInfo", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], /* @ngInject */ ComponentItemComponent.prototype, "cloneOnDrop", void 0);
/* @ngInject */ ComponentItemComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-component-item',
        template: `<div class="se-component-item" [ngClass]="{ 'se-component-item--disabled': isComponentDisabled, 'smartEditComponent': !isComponentDisabled }" [attr.data-smartedit-component-id]="componentInfo.uid" [attr.data-smartedit-component-uuid]="componentInfo.uuid" [attr.data-smartedit-component-type]="componentInfo.typeCode"><se-tooltip *ngIf="isComponentDisabled" class="se-component-item__tooltip" [appendTo]="'body'" [placement]="'bottom'" [triggers]="['mouseenter', 'mouseleave']" [additionalClasses]="['se-component-item__tooltip--for-disabled']"><div se-tooltip-trigger class="se-component-item--disabled-overlay"></div><div se-tooltip-body class="se-popover--inner-content" translate="se.cms.component.non.cloneable.tooltip" [translateParams]="{ componentName: componentInfo.name }"></div></se-tooltip><div class="se-component-item--image"><span class="sap-icon--card"></span><div *ngIf="isSharedComponent"><span class="se-component-item--image-shared--background"></span> <span class="glyphicon glyphicon-link se-component-item--image-shared"></span></div></div><div class="se-component-item--details-container"><div class="se-component-item--details" title="{{ componentInfo.name }} - {{ componentInfo.typeCode }}"><div class="se-component-item--details-name">{{ componentInfo.name }}</div><div class="se-component-item--details-type">{{ componentInfo.typeCode }}</div></div><se-tooltip *ngIf="!componentInfo.visible" [appendTo]="'body'" [triggers]="['mouseenter', 'mouseleave']" [additionalClasses]="['se-component-item--visibility']"><span se-tooltip-trigger class="hyicon hyicon-unpowered"></span><div se-tooltip-body translate="se.cms.component.display.off.tooltip"></div></se-tooltip></div></div>`,
        styles: [`se-component-item .se-component-item--disabled,se-component-item .se-component-item--disabled:active,se-component-item .se-component-item--disabled:hover{border:2px solid transparent}se-component-item .se-component-item--disabled-overlay{cursor:not-allowed;position:absolute;z-index:1;height:100%;width:100%;left:0;top:0;background:#d9d9d9;border-radius:4px;opacity:.5}se-component-item .se-component-item--details-container{display:flex}se-component-item .se-component-item--details-name{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;color:#51555a;width:100%}se-component-item .se-component-item--image-shared--background{position:absolute;top:0;left:0;width:0;height:0;border-style:solid;border-width:13px;border-color:#354a5f transparent transparent #354a5f;border-radius:4px 0 0 0}se-component-item .se-component-item--image-shared{font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;position:absolute;top:2px;left:2px;transform:rotate(3deg)}se-component-item .se-component-item--visibility,se-component-item .se-component-item--visibility .fd-popover__control,se-component-item .se-component-item--visibility>div{width:100%;height:100%}se-component-item .se-component-item__tooltip{display:block;height:100%;width:100%;position:absolute;left:0;top:0}se-component-item .se-component-item__tooltip--for-disabled,se-component-item .se-component-item__tooltip--for-disabled .fd-popover__control,se-component-item .se-component-item__tooltip--for-disabled>div{width:100%;height:100%}`, `.se-component-item{display:flex;flex-direction:row;align-items:center;position:relative;width:270px;padding:8px;margin:4px 8px 0;border:2px solid transparent;cursor:grab}.se-component-item:active,.se-component-item:hover{border:2px dashed #d9d9d9;border-radius:4px}.se-component-item:active{cursor:grabbing}.se-component-item--details-type{color:#51555a;overflow:hidden;text-overflow:ellipsis}.se-component-item--image{display:flex;flex-direction:row;align-items:center;justify-content:center;font-size:1.4285714286rem;line-height:1.4;font-weight:400;height:36px;width:36px;position:relative;background:#2b78c5;margin-right:8px;color:#fff;border-radius:4px}.se-component-item--details,.se-component-item--details-type{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;width:200px}.se-component-item--details-type{color:#6a6d70}`],
        encapsulation: core.ViewEncapsulation.None,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [cmscommons.IComponentSharedService,
        core.ChangeDetectorRef])
], /* @ngInject */ ComponentItemComponent);

window.__smartedit__.addDecoratorPayload("Component", "ComponentTypeComponent", {
    selector: 'se-component-type',
    template: `<div class="se-component-item smartEditComponent" [attr.data-smartedit-component-type]="typeInfo.code"><div class="se-component-item--image"><span class="sap-icon--card"></span></div><div class="se-component-item--details-type" [title]="typeInfo.i18nKey | translate">{{ typeInfo.name }}</div></div>`,
    styles: [`.se-component-item{display:flex;flex-direction:row;align-items:center;position:relative;width:270px;padding:8px;margin:4px 8px 0;border:2px solid transparent;cursor:grab}.se-component-item:active,.se-component-item:hover{border:2px dashed #d9d9d9;border-radius:4px}.se-component-item:active{cursor:grabbing}.se-component-item--details-type{color:#51555a;overflow:hidden;text-overflow:ellipsis}.se-component-item--image{display:flex;flex-direction:row;align-items:center;justify-content:center;font-size:1.4285714286rem;line-height:1.4;font-weight:400;height:36px;width:36px;position:relative;background:#2b78c5;margin-right:8px;color:#fff;border-radius:4px}.se-component-item--details,.se-component-item--details-type{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;width:200px}.se-component-item--details-type{color:#6a6d70}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ ComponentTypeComponent = class /* @ngInject */ ComponentTypeComponent {
};
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ ComponentTypeComponent.prototype, "typeInfo", void 0);
/* @ngInject */ ComponentTypeComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-component-type',
        template: `<div class="se-component-item smartEditComponent" [attr.data-smartedit-component-type]="typeInfo.code"><div class="se-component-item--image"><span class="sap-icon--card"></span></div><div class="se-component-item--details-type" [title]="typeInfo.i18nKey | translate">{{ typeInfo.name }}</div></div>`,
        styles: [`.se-component-item{display:flex;flex-direction:row;align-items:center;position:relative;width:270px;padding:8px;margin:4px 8px 0;border:2px solid transparent;cursor:grab}.se-component-item:active,.se-component-item:hover{border:2px dashed #d9d9d9;border-radius:4px}.se-component-item:active{cursor:grabbing}.se-component-item--details-type{color:#51555a;overflow:hidden;text-overflow:ellipsis}.se-component-item--image{display:flex;flex-direction:row;align-items:center;justify-content:center;font-size:1.4285714286rem;line-height:1.4;font-weight:400;height:36px;width:36px;position:relative;background:#2b78c5;margin-right:8px;color:#fff;border-radius:4px}.se-component-item--details,.se-component-item--details-type{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;width:200px}.se-component-item--details-type{color:#6a6d70}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    })
], /* @ngInject */ ComponentTypeComponent);

window.__smartedit__.addDecoratorPayload("Component", "ComponentSearchComponent", {
    selector: 'se-component-search',
    template: `<div class="se-input-group se-component-menu__input-group"><input type="text" class="se-input-group__input-area" name="search-term" [(ngModel)]="searchQuery" (ngModelChange)="onSearchQueryChange($event)" placeholder="{{ placeholderI18nKey | translate }}"/> <span class="sap-icon--search se-input-group__addon"></span><div *ngIf="showResetButton" class="se-input-group__addon se-input-group__clear-btn" (click)="resetSearch($event)"><span class="sap-icon--decline"></span></div></div>`,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ ComponentSearchComponent = class /* @ngInject */ ComponentSearchComponent {
    constructor(systemEventService) {
        this.systemEventService = systemEventService;
        this.onChange = new core.EventEmitter();
        this.searchQuery = '';
        this.showResetButton = false;
        this.searchQuerySubject$ = new rxjs.Subject();
        this.searchQuerySubscription = this.searchQuerySubject$
            .pipe(operators.debounceTime(500), operators.distinctUntilChanged())
            .subscribe((newValue) => {
            this.searchQuery = newValue;
            this.onChange.emit(this.searchQuery);
        });
    }
    ngOnInit() {
        this.resetSearch();
        this.unRegResetComponentMenuEvent = this.systemEventService.subscribe(RESET_COMPONENT_MENU_EVENT, () => this.resetSearch());
    }
    ngOnDestroy() {
        this.unRegResetComponentMenuEvent();
        this.searchQuerySubscription.unsubscribe();
    }
    onSearchQueryChange(newValue) {
        this.searchQuerySubject$.next(newValue);
        this.showResetButton = !!newValue.length;
    }
    resetSearch(event) {
        if (event) {
            event.stopPropagation();
        }
        this.searchQuery = '';
        this.showResetButton = false;
        this.onChange.emit(this.searchQuery);
    }
};
ComponentSearchComponent.$inject = ["systemEventService"];
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ ComponentSearchComponent.prototype, "placeholderI18nKey", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ ComponentSearchComponent.prototype, "onChange", void 0);
/* @ngInject */ ComponentSearchComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-component-search',
        template: `<div class="se-input-group se-component-menu__input-group"><input type="text" class="se-input-group__input-area" name="search-term" [(ngModel)]="searchQuery" (ngModelChange)="onSearchQueryChange($event)" placeholder="{{ placeholderI18nKey | translate }}"/> <span class="sap-icon--search se-input-group__addon"></span><div *ngIf="showResetButton" class="se-input-group__addon se-input-group__clear-btn" (click)="resetSearch($event)"><span class="sap-icon--decline"></span></div></div>`,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [smarteditcommons.SystemEventService])
], /* @ngInject */ ComponentSearchComponent);

window.__smartedit__.addDecoratorPayload("Component", "CatalogVersionItemComponent", {
    selector: 'se-catalog-version-item',
    template: `
        <div class="se-component-menu__select-local">
            <span
                class="hyicon hyicon-globe se-component-menu__select-globe"
                *ngIf="item.isCurrentCatalog"
            ></span>
            <span class="se-component-menu__select-text"
                >{{ item.catalogName | seL10n | async }} - {{ item.catalogVersionId }}</span
            >
        </div>
    `
});
let /* @ngInject */ CatalogVersionItemComponent = class /* @ngInject */ CatalogVersionItemComponent {
    constructor(data) {
        this.item = data.item;
    }
};
CatalogVersionItemComponent.$inject = ["data"];
/* @ngInject */ CatalogVersionItemComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-catalog-version-item',
        template: `
        <div class="se-component-menu__select-local">
            <span
                class="hyicon hyicon-globe se-component-menu__select-globe"
                *ngIf="item.isCurrentCatalog"
            ></span>
            <span class="se-component-menu__select-text"
                >{{ item.catalogName | seL10n | async }} - {{ item.catalogVersionId }}</span
            >
        </div>
    `
    }),
    __param(0, core.Inject(smarteditcommons.ITEM_COMPONENT_DATA_TOKEN)),
    __metadata("design:paramtypes", [Object])
], /* @ngInject */ CatalogVersionItemComponent);

window.__smartedit__.addDecoratorPayload("Component", "ComponentsTabComponent", {
    selector: 'se-components-tab',
    template: `<div class="se-component-menu__tabs-header"><div class="se-component-menu__tabs-header--upper" *ngIf="hasMultipleContentCatalogs()"><se-select id="se-components-tab-catalog-versions" class="se-component-menu__select" [(model)]="selectedCatalogVersionId" (modelChange)="onCatalogVersionChange()" [fetchStrategy]="catalogVersionsFetchStrategy" [searchEnabled]="false" [itemComponent]="itemComponent"></se-select></div><div class="se-component-menu__tabs-header--lower"><se-component-search (onChange)="onSearchTermChanged($event)" [placeholderI18nKey]="'se.cms.componentmenu.search.placeholder'" class="se-component-menu__tabs-search"></se-component-search><fieldset class="fd-form__set"><div class="fd-form__item fd-form__item--check se-component-menu__clone-on-drop"><input type="checkbox" class="fd-form__control se-component-menu__clone-check-box" id="component-clone-checkbox" name="clone-on-drop" [(ngModel)]="cloneOnDrop" (ngModelChange)="onComponentCloneOnDropChange($event)"/> <label class="fd-form__label se-component-menu__clone-label" for="component-clone-checkbox" translate="se.cms.component.clone.on.drop.label"></label></div></fieldset></div></div><div class="se-component-menu__result-container" *ngIf="forceRecompile"><se-infinite-scrolling *ngIf="isActive()" class="se-component-menu__infinite-scroll" [ngClass]="{'se-component-menu__infinite-scroll--short': hasMultipleContentCatalogs() }" [pageSize]="10" [mask]="searchTerm" [fetchPage]="loadComponentItems" [context]="componentsContext"><div class="se-component-menu__result" *ngIf="componentsContext.items.length"><se-component-item class="se-component-menu__item-wrap" *ngFor="let item of componentsContext.items; trackBy: trackById" [componentInfo]="item" [cloneOnDrop]="cloneOnDrop"></se-component-item></div></se-infinite-scrolling></div>`,
    styles: [`se-components-tab .se-component-menu__tabs-header{padding:0 20px 16px;border-bottom:1px solid #d9d9d9}se-components-tab .se-component-menu__tabs-header .fd-form__set{margin:0!important}se-components-tab .se-component-menu__tabs-header--upper{margin-bottom:12px}se-components-tab .se-component-menu__tabs-header--lower{display:flex;flex-direction:row;align-items:center}se-components-tab .se-component-menu__tabs-search{width:78%}se-components-tab .se-component-menu__clone-on-drop.fd-form__item{display:flex;flex-direction:row;align-items:center}se-components-tab .se-component-menu__clone-check-box.fd-form__control{margin:0 4px 0 16px}se-components-tab .se-component-menu__clone-label.fd-form__label{white-space:nowrap;color:#32363a}se-components-tab .se-component-menu__infinite-scroll .se-infinite-scrolling__container{max-height:300px}se-components-tab .se-component-menu__infinite-scroll--short .se-infinite-scrolling__container{max-height:250px}se-components-tab .se-component-menu__result{display:grid;grid-template-columns:repeat(2,1fr)}`],
    encapsulation: core.ViewEncapsulation.None
});
let /* @ngInject */ ComponentsTabComponent = class /* @ngInject */ ComponentsTabComponent {
    constructor(tabData, componentMenuService, componentService, sharedDataService, userTrackingService) {
        this.tabData = tabData;
        this.componentMenuService = componentMenuService;
        this.componentService = componentService;
        this.sharedDataService = sharedDataService;
        this.userTrackingService = userTrackingService;
        this.loadComponentItems = (mask, pageSize, currentPage) => __awaiter(this, void 0, void 0, function* () {
            if (!this.selectedCatalogVersion) {
                return {
                    results: []
                };
            }
            const payload = {
                catalogId: this.selectedCatalogVersion.catalogId,
                catalogVersion: this.selectedCatalogVersion.catalogVersionId,
                mask,
                pageSize,
                page: currentPage
            };
            const loadedPage = yield this.componentService.loadPagedComponentItemsByCatalogVersion(payload);
            return Object.assign(Object.assign({}, loadedPage), { results: loadedPage.response });
        });
        this.catalogVersions = [];
        this.catalogVersionsFetchStrategy = {
            fetchAll: () => this.fetchCatalogVersions()
        };
        this.componentsContext = { items: [] };
        this.forceRecompile = true;
        this.itemComponent = CatalogVersionItemComponent;
        this.selectedCatalogVersionId = null;
        this.selectedCatalogVersion = null;
        this.searchTerm = '';
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.cloneOnDrop = !!(yield this.sharedDataService.get(ENABLE_CLONE_ON_DROP));
            yield this.fetchCatalogVersions();
            if (!this.hasMultipleContentCatalogs()) {
                this.onCatalogVersionChange();
            }
        });
    }
    isActive() {
        return this.tabData.tab.active;
    }
    hasMultipleContentCatalogs() {
        return this.tabData.model.componentsTab.hasMultipleContentCatalogs;
    }
    trackById(item) {
        return item.id;
    }
    onCatalogVersionChange() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.selectedCatalogVersionId) {
                this.selectedCatalogVersion = this.catalogVersions.find((catalogVersion) => catalogVersion.id === this.selectedCatalogVersionId);
                yield this.componentMenuService.persistCatalogVersion(this.selectedCatalogVersionId);
                this.forceRecompile = false;
                setTimeout(() => {
                    this.forceRecompile = true;
                });
            }
        });
    }
    onSearchTermChanged(searchTerm) {
        this.searchTerm = searchTerm;
    }
    onComponentCloneOnDropChange() {
        this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.ADD_COMPONENT, 'Clone on Drop');
        this.sharedDataService.set(ENABLE_CLONE_ON_DROP, this.cloneOnDrop);
    }
    fetchCatalogVersions() {
        return __awaiter(this, void 0, void 0, function* () {
            const catalogVersions = yield this.componentMenuService.getValidContentCatalogVersions();
            this.catalogVersions = catalogVersions;
            const selectedCatalogVersion = yield this.componentMenuService.getInitialCatalogVersion(this.catalogVersions);
            this.selectedCatalogVersion = selectedCatalogVersion;
            this.selectedCatalogVersionId = this.selectedCatalogVersion
                ? this.selectedCatalogVersion.id
                : undefined;
            return this.catalogVersions;
        });
    }
};
ComponentsTabComponent.$inject = ["tabData", "componentMenuService", "componentService", "sharedDataService", "userTrackingService"];
/* @ngInject */ ComponentsTabComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-components-tab',
        template: `<div class="se-component-menu__tabs-header"><div class="se-component-menu__tabs-header--upper" *ngIf="hasMultipleContentCatalogs()"><se-select id="se-components-tab-catalog-versions" class="se-component-menu__select" [(model)]="selectedCatalogVersionId" (modelChange)="onCatalogVersionChange()" [fetchStrategy]="catalogVersionsFetchStrategy" [searchEnabled]="false" [itemComponent]="itemComponent"></se-select></div><div class="se-component-menu__tabs-header--lower"><se-component-search (onChange)="onSearchTermChanged($event)" [placeholderI18nKey]="'se.cms.componentmenu.search.placeholder'" class="se-component-menu__tabs-search"></se-component-search><fieldset class="fd-form__set"><div class="fd-form__item fd-form__item--check se-component-menu__clone-on-drop"><input type="checkbox" class="fd-form__control se-component-menu__clone-check-box" id="component-clone-checkbox" name="clone-on-drop" [(ngModel)]="cloneOnDrop" (ngModelChange)="onComponentCloneOnDropChange($event)"/> <label class="fd-form__label se-component-menu__clone-label" for="component-clone-checkbox" translate="se.cms.component.clone.on.drop.label"></label></div></fieldset></div></div><div class="se-component-menu__result-container" *ngIf="forceRecompile"><se-infinite-scrolling *ngIf="isActive()" class="se-component-menu__infinite-scroll" [ngClass]="{'se-component-menu__infinite-scroll--short': hasMultipleContentCatalogs() }" [pageSize]="10" [mask]="searchTerm" [fetchPage]="loadComponentItems" [context]="componentsContext"><div class="se-component-menu__result" *ngIf="componentsContext.items.length"><se-component-item class="se-component-menu__item-wrap" *ngFor="let item of componentsContext.items; trackBy: trackById" [componentInfo]="item" [cloneOnDrop]="cloneOnDrop"></se-component-item></div></se-infinite-scrolling></div>`,
        styles: [`se-components-tab .se-component-menu__tabs-header{padding:0 20px 16px;border-bottom:1px solid #d9d9d9}se-components-tab .se-component-menu__tabs-header .fd-form__set{margin:0!important}se-components-tab .se-component-menu__tabs-header--upper{margin-bottom:12px}se-components-tab .se-component-menu__tabs-header--lower{display:flex;flex-direction:row;align-items:center}se-components-tab .se-component-menu__tabs-search{width:78%}se-components-tab .se-component-menu__clone-on-drop.fd-form__item{display:flex;flex-direction:row;align-items:center}se-components-tab .se-component-menu__clone-check-box.fd-form__control{margin:0 4px 0 16px}se-components-tab .se-component-menu__clone-label.fd-form__label{white-space:nowrap;color:#32363a}se-components-tab .se-component-menu__infinite-scroll .se-infinite-scrolling__container{max-height:300px}se-components-tab .se-component-menu__infinite-scroll--short .se-infinite-scrolling__container{max-height:250px}se-components-tab .se-component-menu__result{display:grid;grid-template-columns:repeat(2,1fr)}`],
        encapsulation: core.ViewEncapsulation.None
    }),
    __param(0, core.Inject(smarteditcommons.TAB_DATA)),
    __metadata("design:paramtypes", [Object, smarteditcommons.ComponentMenuService,
        cmscommons.ComponentService,
        smarteditcommons.ISharedDataService,
        smarteditcommons.UserTrackingService])
], /* @ngInject */ ComponentsTabComponent);

window.__smartedit__.addDecoratorPayload("Component", "ComponentTypesTabComponent", {
    selector: 'se-component-types-tab',
    template: `<div class="se-component-menu__types-header"><se-component-search (onChange)="onSearchTermChanged($event)" [placeholderI18nKey]="'se.cms.componentmenu.search.type.placeholder'" class="se-component-menu__type-search"></se-component-search></div><div class="se-component-menu__result-container"><se-infinite-scrolling class="se-component-menu__infinite-scroll" *ngIf="isMenuOpen() || isTabActive()" [pageSize]="10" [mask]="searchTerm" [fetchPage]="loadComponentTypes" [context]="componentsContext"><div class="se-component-menu__result se-component-menu__result--types"><div class="se-component-menu__item-wrap" *ngFor="let componentType of componentsContext.items"><se-component-type [typeInfo]="componentType"></se-component-type></div></div></se-infinite-scrolling></div>`,
    styles: [`se-component-types-tab .se-component-menu__type-search{width:100%}se-component-types-tab .se-component-menu__result{display:grid;grid-template-columns:repeat(2,1fr)}se-component-types-tab .se-component-menu__infinite-scroll .se-infinite-scrolling__container{max-height:300px}se-component-types-tab .se-component-menu__types-header{padding:0 20px 16px;border-bottom:1px solid #d9d9d9}se-component-types-tab .se-component-menu__types-header .fd-form__set{margin:0!important}`],
    encapsulation: core.ViewEncapsulation.None
});
let /* @ngInject */ ComponentTypesTabComponent = class /* @ngInject */ ComponentTypesTabComponent {
    constructor(tabData, logService, componentService, pageService, catalogService, crossFrameEventService, languageService) {
        this.tabData = tabData;
        this.logService = logService;
        this.componentService = componentService;
        this.pageService = pageService;
        this.catalogService = catalogService;
        this.crossFrameEventService = crossFrameEventService;
        this.languageService = languageService;
        this.loadComponentTypes = (mask, pageSize, currentPage) => __awaiter(this, void 0, void 0, function* () {
            try {
                const [locale] = yield Promise.all([
                    this.languageService.getResolveLocale(),
                    this.loadPageContext()
                ]);
                const payload = {
                    pageId: this.pageInfo.uid,
                    catalogId: this.uriContext.CURRENT_CONTEXT_CATALOG,
                    catalogVersion: this.uriContext.CURRENT_CONTEXT_CATALOG_VERSION,
                    langIsoCode: locale,
                    mask,
                    pageSize,
                    currentPage
                };
                const components = yield this.componentService.getSupportedComponentTypesForCurrentPage(payload);
                return components;
            }
            catch (error) {
                this.logService.error('ComponentTypesTab - loadComponentTypes - error loading types.', error);
            }
        });
        this.componentsContext = { items: [] };
        this.pageInfo = null;
        this.searchTerm = '';
        this.uriContext = null;
    }
    ngOnInit() {
        this.unRegisterSwitchLanguageEvent = this.crossFrameEventService.subscribe(smarteditcommons.SWITCH_LANGUAGE_EVENT, () => {
            console.log('switch language called before', this.searchTerm);
            this.searchTerm = this.searchTerm !== undefined ? undefined : '';
            console.log('switch language called after', this.searchTerm);
        });
    }
    ngOnDestroy() {
        var _a;
        (_a = this.unRegisterSwitchLanguageEvent) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    onSearchTermChanged(newSearchTerm) {
        this.searchTerm = newSearchTerm;
    }
    isTabActive() {
        return this.tabData.tab.active;
    }
    isMenuOpen() {
        return this.tabData.model.isOpen;
    }
    loadPageContext() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pageInfo) {
                return;
            }
            const [pageInfo, uriContext] = yield Promise.all([
                this.pageService.getCurrentPageInfo(),
                this.catalogService.retrieveUriContext()
            ]);
            this.pageInfo = pageInfo;
            this.uriContext = uriContext;
        });
    }
};
ComponentTypesTabComponent.$inject = ["tabData", "logService", "componentService", "pageService", "catalogService", "crossFrameEventService", "languageService"];
/* @ngInject */ ComponentTypesTabComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-component-types-tab',
        template: `<div class="se-component-menu__types-header"><se-component-search (onChange)="onSearchTermChanged($event)" [placeholderI18nKey]="'se.cms.componentmenu.search.type.placeholder'" class="se-component-menu__type-search"></se-component-search></div><div class="se-component-menu__result-container"><se-infinite-scrolling class="se-component-menu__infinite-scroll" *ngIf="isMenuOpen() || isTabActive()" [pageSize]="10" [mask]="searchTerm" [fetchPage]="loadComponentTypes" [context]="componentsContext"><div class="se-component-menu__result se-component-menu__result--types"><div class="se-component-menu__item-wrap" *ngFor="let componentType of componentsContext.items"><se-component-type [typeInfo]="componentType"></se-component-type></div></div></se-infinite-scrolling></div>`,
        styles: [`se-component-types-tab .se-component-menu__type-search{width:100%}se-component-types-tab .se-component-menu__result{display:grid;grid-template-columns:repeat(2,1fr)}se-component-types-tab .se-component-menu__infinite-scroll .se-infinite-scrolling__container{max-height:300px}se-component-types-tab .se-component-menu__types-header{padding:0 20px 16px;border-bottom:1px solid #d9d9d9}se-component-types-tab .se-component-menu__types-header .fd-form__set{margin:0!important}`],
        encapsulation: core.ViewEncapsulation.None
    }),
    __param(0, core.Inject(smarteditcommons.TAB_DATA)),
    __metadata("design:paramtypes", [Object, smarteditcommons.LogService,
        cmscommons.ComponentService,
        smarteditcommons.IPageService,
        smarteditcommons.ICatalogService,
        smarteditcommons.CrossFrameEventService,
        smarteditcommons.LanguageService])
], /* @ngInject */ ComponentTypesTabComponent);

const TAB_IDS = {
    COMPONENT_TYPES_TAB_ID: 'componentTypesTab',
    COMPONENTS_TAB_ID: 'componentsTab'
};
window.__smartedit__.addDecoratorPayload("Component", "ComponentMenuComponent", {
    selector: 'se-component-menu',
    template: `<div class="se-component-menu" [ngClass]="{ 'se-component-menu__localized': hasMultipleContentCatalogs }"><div translate="se.cms.componentmenu.dropdown.header" class="se-component-menu__title"></div><div class="se-component-menu__tip" translate="se.cms.componentmenu.label.draganddrop"></div><se-tabs *ngIf="toolbarItem.isOpen" class="se-component-menu__tabs" [tabsList]="tabsList" [model]="model" [numTabsDisplayed]="2"></se-tabs></div>`,
    styles: [`se-component-menu .se-component-menu{width:640px;height:485px}se-component-menu .se-component-menu__tabs .se-tabset{margin:0 20px 20px}se-component-menu .se-component-menu__tip{font-size:1rem;line-height:1.4285714286;font-weight:400;margin-bottom:16px;color:#51555a;padding:0 20px}se-component-menu .se-component-menu__title{color:#32363a;font-size:1.1428571429rem;line-height:1.25;font-weight:400;padding:14px 20px 4px}`],
    encapsulation: core.ViewEncapsulation.None
});
/* @ngInject */ exports.ComponentMenuComponent = class /* @ngInject */ ComponentMenuComponent {
    constructor(toolbarItem, crossFrameEventService, componentMenuService) {
        this.toolbarItem = toolbarItem;
        this.crossFrameEventService = crossFrameEventService;
        this.componentMenuService = componentMenuService;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.initializeComponentMenu();
            this.unregisterPageChangeEvent = this.crossFrameEventService.subscribe(smarteditcommons.EVENTS.PAGE_CHANGE, () => this.initializeComponentMenu());
            this.unregisterOpenComponentEvent = this.crossFrameEventService.subscribe(OPEN_COMPONENT_EVENT, () => {
                this.resetComponentMenu(true);
            });
            this.unregisterOverlapEvent = this.crossFrameEventService.subscribe(smarteditcommons.OVERLAY_DISABLED_EVENT, () => this.closeMenu());
            this.unregisterDragStartEvent = this.crossFrameEventService.subscribe(smarteditcommons.SMARTEDIT_DRAG_AND_DROP_EVENTS.DRAG_DROP_START, () => {
                this.isDragging = true;
                this.closeMenu();
            });
            this.unregisterDragEndEvent = this.crossFrameEventService.subscribe(smarteditcommons.SMARTEDIT_DRAG_AND_DROP_EVENTS.DRAG_DROP_END, () => {
                this.isDragging = false;
                this.crossFrameEventService.publish(smarteditcommons.DRAG_AND_DROP_CROSS_ORIGIN_BEFORE_TIME.END);
            });
        });
    }
    ngDoCheck() {
        if (this.isOpenPreviousValue !== this.toolbarItem.isOpen) {
            this.isOpenPreviousValue = this.toolbarItem.isOpen;
            if (this.toolbarItem.isOpen) {
                this.crossFrameEventService.publish(smarteditcommons.DRAG_AND_DROP_CROSS_ORIGIN_BEFORE_TIME.START);
            }
            else if (!this.toolbarItem.isOpen && !this.isDragging) {
                this.crossFrameEventService.publish(smarteditcommons.DRAG_AND_DROP_CROSS_ORIGIN_BEFORE_TIME.END);
            }
        }
    }
    ngOnDestroy() {
        this.unregisterPageChangeEvent();
        this.unregisterOpenComponentEvent();
        this.unregisterDragStartEvent();
        this.unregisterOverlapEvent();
        this.unregisterDragEndEvent();
    }
    initializeComponentMenu() {
        return __awaiter(this, void 0, void 0, function* () {
            this.tabsList = null;
            this.hasMultipleContentCatalogs = yield this.componentMenuService.hasMultipleContentCatalogs();
            this.tabsList = [
                {
                    id: TAB_IDS.COMPONENT_TYPES_TAB_ID,
                    title: 'se.cms.compomentmenu.tabs.componenttypes',
                    component: ComponentTypesTabComponent,
                    hasErrors: false
                },
                {
                    id: TAB_IDS.COMPONENTS_TAB_ID,
                    title: 'se.cms.compomentmenu.tabs.customizedcomp',
                    component: ComponentsTabComponent,
                    hasErrors: false
                }
            ];
            this.model = {
                componentsTab: {
                    hasMultipleContentCatalogs: this.hasMultipleContentCatalogs
                },
                isOpen: this.toolbarItem.isOpen
            };
            this.resetComponentMenu(this.toolbarItem.isOpen);
        });
    }
    resetComponentMenu(isToolbarOpened) {
        if (this.tabsList) {
            if (!this.toolbarItem.isOpen) {
                this.tabsList = this.tabsList.map((tab) => (Object.assign(Object.assign({}, tab), { active: tab.id === TAB_IDS.COMPONENT_TYPES_TAB_ID })));
            }
            this.model = Object.assign(Object.assign({}, this.model), { isOpen: isToolbarOpened });
            this.crossFrameEventService.publish(RESET_COMPONENT_MENU_EVENT);
        }
    }
    closeMenu() {
        if (this.toolbarItem) {
            this.toolbarItem.isOpen = false;
        }
    }
};
exports.ComponentMenuComponent.$inject = ["toolbarItem", "crossFrameEventService", "componentMenuService"];
/* @ngInject */ exports.ComponentMenuComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-component-menu',
        template: `<div class="se-component-menu" [ngClass]="{ 'se-component-menu__localized': hasMultipleContentCatalogs }"><div translate="se.cms.componentmenu.dropdown.header" class="se-component-menu__title"></div><div class="se-component-menu__tip" translate="se.cms.componentmenu.label.draganddrop"></div><se-tabs *ngIf="toolbarItem.isOpen" class="se-component-menu__tabs" [tabsList]="tabsList" [model]="model" [numTabsDisplayed]="2"></se-tabs></div>`,
        styles: [`se-component-menu .se-component-menu{width:640px;height:485px}se-component-menu .se-component-menu__tabs .se-tabset{margin:0 20px 20px}se-component-menu .se-component-menu__tip{font-size:1rem;line-height:1.4285714286;font-weight:400;margin-bottom:16px;color:#51555a;padding:0 20px}se-component-menu .se-component-menu__title{color:#32363a;font-size:1.1428571429rem;line-height:1.25;font-weight:400;padding:14px 20px 4px}`],
        encapsulation: core.ViewEncapsulation.None
    }),
    __param(0, core.Inject(smarteditcommons.TOOLBAR_ITEM)),
    __metadata("design:paramtypes", [Object, smarteditcommons.CrossFrameEventService,
        smarteditcommons.ComponentMenuService])
], /* @ngInject */ exports.ComponentMenuComponent);

exports.ComponentMenuModule = class ComponentMenuModule {
};
exports.ComponentMenuModule = __decorate([
    core.NgModule({
        imports: [
            common.CommonModule,
            smarteditcommons.TooltipModule,
            smarteditcommons.TranslationModule.forChild(),
            forms.FormsModule,
            smarteditcommons.SelectModule,
            smarteditcommons.InfiniteScrollingModule,
            smarteditcommons.L10nPipeModule,
            smarteditcommons.TabsModule
        ],
        providers: [smarteditcommons.ComponentMenuService],
        declarations: [
            ComponentItemComponent,
            ComponentTypeComponent,
            ComponentSearchComponent,
            CatalogVersionItemComponent,
            ComponentsTabComponent,
            ComponentTypesTabComponent,
            exports.ComponentMenuComponent
        ],
        entryComponents: [
            ComponentItemComponent,
            ComponentTypeComponent,
            ComponentSearchComponent,
            CatalogVersionItemComponent,
            ComponentsTabComponent,
            ComponentTypesTabComponent,
            exports.ComponentMenuComponent
        ]
    })
], exports.ComponentMenuModule);

window.__smartedit__.addDecoratorPayload("Component", "ComponentRestrictionsEditorComponent", {
    selector: 'se-component-restrictions-editor',
    template: `<se-restrictions-editor [editable]="isEditable" [getRestrictionTypes]="getRestrictionTypes" [getSupportedRestrictionTypes]="getSupportedRestrictionTypes" [item]="model" [restrictionUuids]="model.restrictions" (onRestrictionsChange)="onRestrictionsChange($event)"></se-restrictions-editor>`,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
/* @ngInject */ exports.ComponentRestrictionsEditorComponent = class /* @ngInject */ ComponentRestrictionsEditorComponent {
    constructor(data, restrictionsService, restrictionTypesService) {
        this.data = data;
        this.restrictionsService = restrictionsService;
        this.restrictionTypesService = restrictionTypesService;
        ({ editor: this.editor, field: this.field, model: this.model } = data);
        this.isEditable = !data.isFieldDisabled();
    }
    ngOnInit() {
        this.initGetRestrictionTypes();
        this.initGetSupportedRestrictionTypes();
        if (this.model.restrictions === undefined) {
            this.editor.form.pristine.restrictions = [];
            this.editor.form.pristine.onlyOneRestrictionMustApply = false;
        }
    }
    onRestrictionsChange({ onlyOneRestrictionMustApply, restrictionUuids, alwaysEnableSubmit }) {
        this.model.onlyOneRestrictionMustApply = onlyOneRestrictionMustApply;
        this.model.restrictions = restrictionUuids;
        this.editor.api.setAlwaysEnableSubmit(alwaysEnableSubmit);
    }
    initGetRestrictionTypes() {
        this.getRestrictionTypes = () => this.restrictionTypesService.getRestrictionTypes();
    }
    initGetSupportedRestrictionTypes() {
        this.getSupportedRestrictionTypes = () => this.restrictionsService.getSupportedRestrictionTypeCodes();
    }
};
exports.ComponentRestrictionsEditorComponent.$inject = ["data", "restrictionsService", "restrictionTypesService"];
/* @ngInject */ exports.ComponentRestrictionsEditorComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-component-restrictions-editor',
        template: `<se-restrictions-editor [editable]="isEditable" [getRestrictionTypes]="getRestrictionTypes" [getSupportedRestrictionTypes]="getSupportedRestrictionTypes" [item]="model" [restrictionUuids]="model.restrictions" (onRestrictionsChange)="onRestrictionsChange($event)"></se-restrictions-editor>`,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(0, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [Object, exports.RestrictionsService,
        exports.RestrictionTypesService])
], /* @ngInject */ exports.ComponentRestrictionsEditorComponent);

window.__smartedit__.addDecoratorPayload("Component", "ItemManagementComponent", {
    selector: 'se-item-manager',
    template: `<div><se-generic-editor [id]="editorId" [smarteditComponentId]="itemId" [smarteditComponentType]="componentType" [structureApi]="structureApi" [content]="item" [contentApi]="contentApi" [(isDirty)]="isDirtyInternal" [(submit)]="submit" [uriContext]="uriContext" [reset]="reset"></se-generic-editor></div>`
});
let /* @ngInject */ ItemManagementComponent = class /* @ngInject */ ItemManagementComponent {
    constructor() {
        this.supportedModes = ['add', 'edit', 'create'];
        this.editorId = 'se-item-management-editor';
        this.isDirtyChange = new core.EventEmitter();
        this.submitFunctionChange = new core.EventEmitter();
        this.reset = true;
    }
    ngOnInit() {
        this.validateMode();
        this.submitFunctionChange.emit(() => this.submitInternal());
        this.isDirtyChange.emit(() => this.isDirtyLocal());
        if (!this.componentType && this.item) {
            this.componentType = this.item.typeCode;
        }
        if (!this.item) {
            this.itemId = null;
        }
        if (this.item && this.item.uuid) {
            this.itemId = this.item.uuid;
        }
        else if (this.item && this.item.uid) {
            this.itemId = this.item.uid;
        }
    }
    ngOnChanges(changes) {
        const itemChange = changes.item;
        if (itemChange) {
            this.itemId = null;
            if (this.item && this.item.uuid) {
                this.itemId = this.item.uuid;
            }
            else if (this.item && this.item.uid) {
                this.itemId = this.item.uid;
            }
        }
    }
    validateMode() {
        if (!this.supportedModes.includes(this.mode)) {
            throw 'ItemManagementComponent.ngOnInit() - Mode not supported: ' + this.mode;
        }
    }
    submitInternal() {
        switch (this.mode.toLowerCase()) {
            case 'add':
                return Promise.resolve(this.item);
            case 'edit':
                return this.submit();
            case 'create':
                return this.submit().then((itemResponse) => itemResponse);
            default:
                throw `ItemManagementController - The given mode [${this.mode}] has not been implemented for this component`;
        }
    }
    isDirtyLocal() {
        if (this.isDirtyInternal) {
            return this.isDirtyInternal();
        }
        return false;
    }
};
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ ItemManagementComponent.prototype, "item", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ ItemManagementComponent.prototype, "uriContext", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ ItemManagementComponent.prototype, "mode", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ ItemManagementComponent.prototype, "contentApi", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ ItemManagementComponent.prototype, "structureApi", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ ItemManagementComponent.prototype, "componentType", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ ItemManagementComponent.prototype, "isDirty", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ ItemManagementComponent.prototype, "submitFunction", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ ItemManagementComponent.prototype, "isDirtyChange", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ ItemManagementComponent.prototype, "submitFunctionChange", void 0);
/* @ngInject */ ItemManagementComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-item-manager',
        template: `<div><se-generic-editor [id]="editorId" [smarteditComponentId]="itemId" [smarteditComponentType]="componentType" [structureApi]="structureApi" [content]="item" [contentApi]="contentApi" [(isDirty)]="isDirtyInternal" [(submit)]="submit" [uriContext]="uriContext" [reset]="reset"></se-generic-editor></div>`
    }),
    __metadata("design:paramtypes", [])
], /* @ngInject */ ItemManagementComponent);

class RestrictionManagementSelectModel {
    constructor(cmsitemsRestService, catalogService, fetchRestrictionTypes, getSupportedRestrictionTypes) {
        this.cmsitemsRestService = cmsitemsRestService;
        this.catalogService = catalogService;
        this.fetchRestrictionTypes = fetchRestrictionTypes;
        this.getSupportedRestrictionTypes = getSupportedRestrictionTypes;
        this.selectedIds = {};
        this.model = {
            restrictionTypes: [],
            selectedRestrictionType: null
        };
        this.restrictions = [];
        this.supportedRestrictionTypes = [];
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            const restrictionTypesResponse = yield this.fetchRestrictionTypes();
            this.model.restrictionTypes = restrictionTypesResponse.map((type, index) => (Object.assign(Object.assign({}, type), { id: index })));
            if (typeof this.getSupportedRestrictionTypes === 'function') {
                this.supportedRestrictionTypes = yield this.getSupportedRestrictionTypes();
            }
            else {
                this.supportedRestrictionTypes = this.model.restrictionTypes.map((type) => type.code);
            }
        });
    }
    getRestrictionsPaged(mask, pageSize, currentPage) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestParams = {
                pageSize,
                currentPage,
                typeCode: this.model.selectedRestrictionType.code,
                mask,
                itemSearchParams: ''
            };
            if (currentPage === 0) {
                this.restrictions = [];
            }
            const restrictionsResponse = yield this.cmsitemsRestService.get(requestParams);
            const restrictionResult = restrictionsResponse.response.map((restriction) => (Object.assign(Object.assign({}, restriction), { id: restriction.uid })));
            this.restrictions = this.restrictions.concat(restrictionResult);
            return {
                pagination: restrictionsResponse.pagination,
                results: restrictionResult
            };
        });
    }
    getRestrictionFromBackend() {
        return Promise.resolve({});
    }
    getRestrictionTypes() {
        return Promise.resolve(this.model.restrictionTypes);
    }
    restrictionSelected() {
        if (this.selectedIds.restriction) {
            this.selectedRestriction = this.restrictions.find((restriction) => restriction.id === this.selectedIds.restriction);
            return true;
        }
        return false;
    }
    restrictionTypeSelected() {
        this.selectedIds.restriction = null;
        this.model.selectedRestrictionType =
            (this.model.restrictionTypes || []).find((restrictionType) => restrictionType.id === this.selectedIds.restrictionType) || null;
        if (this.model.selectedRestrictionType) {
            this.selectedRestriction = {
                typeCode: this.model.selectedRestrictionType.code
            };
            return true;
        }
        return false;
    }
    createRestrictionSelected(name, uriContext) {
        return __awaiter(this, void 0, void 0, function* () {
            this.selectedRestriction = {
                itemtype: this.model.selectedRestrictionType.code,
                name
            };
            const catalogVersionUuid = yield this.catalogService.getCatalogVersionUUid(uriContext);
            this.selectedRestriction.catalogVersion = catalogVersionUuid;
        });
    }
    getRestrictionTypeCode() {
        var _a;
        return (_a = this.model.selectedRestrictionType) === null || _a === void 0 ? void 0 : _a.code;
    }
    getRestriction() {
        return this.selectedRestriction;
    }
    isTypeSupported() {
        if (this.getRestrictionTypeCode()) {
            return this.supportedRestrictionTypes.includes(this.model.selectedRestrictionType.code);
        }
        return false;
    }
}
let /* @ngInject */ RestrictionManagementSelectModelFactory = class /* @ngInject */ RestrictionManagementSelectModelFactory {
    constructor(cmsitemsRestService, catalogService) {
        this.cmsitemsRestService = cmsitemsRestService;
        this.catalogService = catalogService;
    }
    createRestrictionManagementSelectModel(fetchRestrictionTypes, getSupportedRestrictionTypes) {
        const instance = new RestrictionManagementSelectModel(this.cmsitemsRestService, this.catalogService, fetchRestrictionTypes, getSupportedRestrictionTypes);
        instance.initialize();
        return instance;
    }
};
RestrictionManagementSelectModelFactory.$inject = ["cmsitemsRestService", "catalogService"];
/* @ngInject */ RestrictionManagementSelectModelFactory = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.CmsitemsRestService,
        smarteditcommons.ICatalogService])
], /* @ngInject */ RestrictionManagementSelectModelFactory);

let /* @ngInject */ RestrictionPickerConfigService = class /* @ngInject */ RestrictionPickerConfigService {
    constructor() {
        this.MODE_EDITING = 'editing';
        this.MODE_SELECT = 'select';
    }
    getConfigForEditing(existingRestriction, getSupportedRestrictionTypesFn) {
        return {
            mode: this.MODE_EDITING,
            restriction: existingRestriction,
            getSupportedRestrictionTypesFn
        };
    }
    getConfigForSelecting(existingRestrictions, getRestrictionTypesFn, getSupportedRestrictionTypesFn) {
        return {
            mode: this.MODE_SELECT,
            getRestrictionTypesFn,
            getSupportedRestrictionTypesFn,
            existingRestrictions
        };
    }
    isEditingMode(config) {
        return config.mode === this.MODE_EDITING;
    }
    isSelectMode(config) {
        return config.mode === this.MODE_SELECT;
    }
    isValidConfig(config) {
        switch (config.mode) {
            case this.MODE_EDITING:
                return lodash.isObject(config.restriction);
            case this.MODE_SELECT:
                if (config.getSupportedRestrictionTypesFn) {
                    return (lodash.isFunction(config.getRestrictionTypesFn) &&
                        lodash.isFunction(config.getSupportedRestrictionTypesFn));
                }
                return lodash.isFunction(config.getRestrictionTypesFn);
            default:
                return false;
        }
    }
};
/* @ngInject */ RestrictionPickerConfigService = __decorate([
    smarteditcommons.SeDowngradeService()
], /* @ngInject */ RestrictionPickerConfigService);

window.__smartedit__.addDecoratorPayload("Component", "RestrictionManagementComponent", {
    selector: 'se-restriction-management',
    template: `<div *ngIf="isReady"><div *ngIf="isEditMode"><se-restriction-management-edit [restriction]="config?.restriction" [getSupportedRestrictionTypes]="config?.getSupportedRestrictionTypesFn" [uriContext]="uriContext" [(isDirtyFn)]="isDirtyInternal" [(submitFn)]="submitInternal"></se-restriction-management-edit></div><div *ngIf="!isEditMode"><se-restriction-management-select [existingRestrictions]="config?.existingRestrictions" [fetchRestrictionTypes]="config?.getRestrictionTypesFn" [getSupportedRestrictionTypes]="config?.getSupportedRestrictionTypesFn" [uriContext]="uriContext" [(isDirtyFn)]="isDirtyInternal" [(submitFn)]="submitInternal"></se-restriction-management-select></div></div>`
});
let /* @ngInject */ RestrictionManagementComponent = class /* @ngInject */ RestrictionManagementComponent {
    constructor(restrictionPickerConfigService) {
        this.restrictionPickerConfigService = restrictionPickerConfigService;
        this.submitFnChange = new core.EventEmitter();
        this.isDirtyFnChange = new core.EventEmitter();
        this.isReady = false;
        this.isEditMode = false;
    }
    ngOnInit() {
        setTimeout(() => {
            this.submitFnChange.emit(() => this.submitInternal().then((value) => value));
            this.isDirtyFnChange.emit(() => this.isDirtyInternal && this.isDirtyInternal());
        });
    }
    ngOnChanges() {
        if (!this.config) {
            return;
        }
        if (this.restrictionPickerConfigService.isValidConfig(this.config)) {
            this.isReady = true;
            this.isEditMode = this.restrictionPickerConfigService.isEditingMode(this.config);
        }
        else {
            throw 'RestrictionManagementComponent - invalid restrictionPickerConfig';
        }
    }
};
RestrictionManagementComponent.$inject = ["restrictionPickerConfigService"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ RestrictionManagementComponent.prototype, "config", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ RestrictionManagementComponent.prototype, "uriContext", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ RestrictionManagementComponent.prototype, "submitFn", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ RestrictionManagementComponent.prototype, "isDirtyFn", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ RestrictionManagementComponent.prototype, "submitFnChange", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ RestrictionManagementComponent.prototype, "isDirtyFnChange", void 0);
/* @ngInject */ RestrictionManagementComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-restriction-management',
        template: `<div *ngIf="isReady"><div *ngIf="isEditMode"><se-restriction-management-edit [restriction]="config?.restriction" [getSupportedRestrictionTypes]="config?.getSupportedRestrictionTypesFn" [uriContext]="uriContext" [(isDirtyFn)]="isDirtyInternal" [(submitFn)]="submitInternal"></se-restriction-management-edit></div><div *ngIf="!isEditMode"><se-restriction-management-select [existingRestrictions]="config?.existingRestrictions" [fetchRestrictionTypes]="config?.getRestrictionTypesFn" [getSupportedRestrictionTypes]="config?.getSupportedRestrictionTypesFn" [uriContext]="uriContext" [(isDirtyFn)]="isDirtyInternal" [(submitFn)]="submitInternal"></se-restriction-management-select></div></div>`
    }),
    __metadata("design:paramtypes", [RestrictionPickerConfigService])
], /* @ngInject */ RestrictionManagementComponent);

window.__smartedit__.addDecoratorPayload("Component", "RestrictionManagementEditComponent", {
    selector: 'se-restriction-management-edit',
    template: `<div *ngIf="ready"><div *ngIf="isTypeSupported"><div class="se-restriction-management-edit__header"><div>{{ restriction.name }}</div><div>{{ restriction.typeCode }}</div></div><div><se-item-manager [item]="restriction" [mode]="itemManagementMode" [structureApi]="structureApi" [contentApi]="contentApi" [uriContext]="uriContext" [componentType]="restriction.itemtype" [(submitFunction)]="submitInternal" [(isDirty)]="isDirtyInternal"></se-item-manager></div></div><div *ngIf="!isTypeSupported"><div class="se-restrictions-list__item-content"><div translate="se.cms.restriction.management.select.type.not.supported.warning"></div><p class="se-restriction__item-name">{{ restriction.name }}</p><div class="se-restriction__item-description">{{ restriction.description }}</div></div></div></div>`,
    styles: [`.se-restriction-management-edit__header{margin-bottom:16px}`, `#restrictions-label{display:none}.se-restriction__select{text-transform:capitalize;width:100%}.se-restrictions-list__item-content{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;cursor:default;flex-grow:1}#userGroups-selector .se-generic-editor-multiple-dropdown__match li[draggable=true]{display:flex;flex-direction:row;align-items:center;justify-content:center;display:inline-flex!important;border:1px solid #d9d9d9;margin:4px 0 4px 8px;padding:4px 8px;border-radius:4px;background-color:var(--fd-token-background-color);color:#51555a;min-height:28px}`]
});
let /* @ngInject */ RestrictionManagementEditComponent = class /* @ngInject */ RestrictionManagementEditComponent {
    constructor(restrictionsService) {
        this.restrictionsService = restrictionsService;
        this.isDirtyFnChange = new core.EventEmitter();
        this.submitFnChange = new core.EventEmitter();
        this.ready = false;
        this.itemManagementMode = 'edit';
        this.structureApi = this.restrictionsService.getStructureApiUri(this.itemManagementMode);
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const dryRunCmsItemsUri = smarteditcommons.cmsitemsUri + '/:identifier';
            this.restriction = this.restriction || {};
            this.contentApi = new smarteditcommons.URIBuilder(dryRunCmsItemsUri).replaceParams(this.uriContext).build();
            if (typeof this.getSupportedRestrictionTypes !== 'undefined') {
                const supportedTypes = yield this.getSupportedRestrictionTypes();
                this.emitActions(supportedTypes.includes(this.restriction.itemtype));
            }
            else {
                return this.emitActions(true);
            }
        });
    }
    emitActions(isRestrictionTypeSupported) {
        this.isTypeSupported = isRestrictionTypeSupported;
        if (isRestrictionTypeSupported) {
            this.submitFnChange.emit(() => this.submitInternal().then((itemResponse) => Promise.resolve(itemResponse)));
            this.isDirtyFnChange.emit(() => this.isDirtyLocal());
        }
        else {
            this.submitFnChange.emit(() => Promise.resolve(null));
            this.isDirtyFnChange.emit(() => false);
        }
        this.ready = true;
    }
    isDirtyLocal() {
        if (this.isDirtyInternal) {
            return this.isDirtyInternal();
        }
        return false;
    }
};
RestrictionManagementEditComponent.$inject = ["restrictionsService"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ RestrictionManagementEditComponent.prototype, "restriction", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ RestrictionManagementEditComponent.prototype, "getSupportedRestrictionTypes", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ RestrictionManagementEditComponent.prototype, "uriContext", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ RestrictionManagementEditComponent.prototype, "isDirtyFn", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ RestrictionManagementEditComponent.prototype, "submitFn", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ RestrictionManagementEditComponent.prototype, "isDirtyFnChange", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ RestrictionManagementEditComponent.prototype, "submitFnChange", void 0);
/* @ngInject */ RestrictionManagementEditComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-restriction-management-edit',
        template: `<div *ngIf="ready"><div *ngIf="isTypeSupported"><div class="se-restriction-management-edit__header"><div>{{ restriction.name }}</div><div>{{ restriction.typeCode }}</div></div><div><se-item-manager [item]="restriction" [mode]="itemManagementMode" [structureApi]="structureApi" [contentApi]="contentApi" [uriContext]="uriContext" [componentType]="restriction.itemtype" [(submitFunction)]="submitInternal" [(isDirty)]="isDirtyInternal"></se-item-manager></div></div><div *ngIf="!isTypeSupported"><div class="se-restrictions-list__item-content"><div translate="se.cms.restriction.management.select.type.not.supported.warning"></div><p class="se-restriction__item-name">{{ restriction.name }}</p><div class="se-restriction__item-description">{{ restriction.description }}</div></div></div></div>`,
        styles: [`.se-restriction-management-edit__header{margin-bottom:16px}`, `#restrictions-label{display:none}.se-restriction__select{text-transform:capitalize;width:100%}.se-restrictions-list__item-content{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;cursor:default;flex-grow:1}#userGroups-selector .se-generic-editor-multiple-dropdown__match li[draggable=true]{display:flex;flex-direction:row;align-items:center;justify-content:center;display:inline-flex!important;border:1px solid #d9d9d9;margin:4px 0 4px 8px;padding:4px 8px;border-radius:4px;background-color:var(--fd-token-background-color);color:#51555a;min-height:28px}`]
    }),
    __metadata("design:paramtypes", [exports.RestrictionsService])
], /* @ngInject */ RestrictionManagementEditComponent);

window.__smartedit__.addDecoratorPayload("Component", "RestrictionManagementSelectItemComponent", {
    selector: 'se-restriction-management-select-item',
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    template: `<span class="se-restriction-management-item-name">{{
        data.item.name | seL10n | async
    }}</span>`
});
let RestrictionManagementSelectItemComponent = class RestrictionManagementSelectItemComponent {
    constructor(data) {
        this.data = data;
    }
};
RestrictionManagementSelectItemComponent = __decorate([
    core.Component({
        selector: 'se-restriction-management-select-item',
        changeDetection: core.ChangeDetectionStrategy.OnPush,
        template: `<span class="se-restriction-management-item-name">{{
        data.item.name | seL10n | async
    }}</span>`
    }),
    __param(0, core.Inject(smarteditcommons.ITEM_COMPONENT_DATA_TOKEN)),
    __metadata("design:paramtypes", [Object])
], RestrictionManagementSelectItemComponent);

window.__smartedit__.addDecoratorPayload("Component", "RestrictionManagementSelectComponent", {
    selector: 'se-restriction-management-select',
    template: `<div><se-message [style.display]="showWarningMessage() ? 'block' : 'none'" [type]="'warning'"><span se-message-title translate="se.cms.restriction.management.select.type.not.supported.warning"></span></se-message><div class="se-restriction-management-select__select"><label class="se-control-label">{{ 'se.cms.restriction.management.select.type.label' | translate }}</label><se-select id="restriction-type" [fetchStrategy]="fetchStrategy" [itemComponent]="itemComponent" [placeholder]="'se.cms.restriction.management.select.type.placeholder'" [(model)]="selectModel.selectedIds.restrictionType" (modelChange)="selectRestrictionType()" [searchEnabled]="false"></se-select></div><div *ngIf="viewConfig.showRestrictionSelector" class="se-restriction-management-select__restriction-info"><label class="se-control-label" translate="se.cms.restriction.management.select.restriction.label"></label><se-select id="restriction-name" [fetchStrategy]="fetchOptions" [(model)]="selectModel.selectedIds.restriction" (modelChange)="selectRestriction()" [placeholder]="'se.cms.restriction.management.select.restriction.placeholder'" [disableChoiceFn]="disableRestrictionChoice" [itemComponent]="itemComponent" [resultsHeaderLabel]="resultsHeaderLabel" [actionableSearchItem]="actionableSearchItem" [(reset)]="reset"></se-select></div><div class="se-restriction-management-select__restriction-editor" *ngIf="viewConfig.showRestrictionEditor"><p class="se-restriction-management-select__new-restriction-message" [translate]="editorHeader"></p><div *ngIf="selectModel.isTypeSupported()"><se-item-manager [item]="selectModel.getRestriction()" [mode]="viewConfig.mode" [structureApi]="viewConfig.structureApi" [contentApi]="viewConfig.contentApi" [uriContext]="uriContext" [componentType]="selectModel.getRestrictionTypeCode()" [(submitFunction)]="submitInternal" [(isDirty)]="isDirtyInternal"></se-item-manager></div><div *ngIf="!selectModel.isTypeSupported()"><p class="se-restriction__item-name">{{ selectModel.getRestriction().name }}</p><div class="se-restriction__item-description">{{ selectModel.getRestriction().description }}</div></div></div></div>`,
    styles: [`se-restriction-management-select .se-restriction-management-select__restriction-info,se-restriction-management-select .se-restriction-management-select__select{margin-bottom:16px}se-restriction-management-select .se-restriction-management-select__restriction-editor{border-top:1px solid #d9d9d9;padding-top:16px}se-restriction-management-select .se-restriction-management-select__new-restriction-message{font-weight:700}se-restriction-management-select .fd-menu__list-header{font-size:1.1428571429rem;line-height:1.25;font-weight:400;padding:8px 12px;border-bottom:1px solid #d9d9d9;color:#51555a;list-style:none;padding-left:24px}se-restriction-management-select .se-select-list__item.is-disabled{opacity:.65}se-restriction-management-select .se-select-list__item.is-disabled .fd-menu__item{cursor:not-allowed}se-restriction-management-select div.se-actionable-search-item{display:flex;align-items:center;justify-content:space-between;padding:0 0 0 13px}`],
    encapsulation: core.ViewEncapsulation.None,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ RestrictionManagementSelectComponent = class /* @ngInject */ RestrictionManagementSelectComponent {
    constructor(restrictionManagementSelectModelFactory, restrictionsService, systemEventService, cdr) {
        this.restrictionManagementSelectModelFactory = restrictionManagementSelectModelFactory;
        this.restrictionsService = restrictionsService;
        this.systemEventService = systemEventService;
        this.cdr = cdr;
        this.RESTRICTION_CREATE_BUTTON_PRESSED_EVENT_ID = 'RESTRICTION_CREATE_BUTTON_PRESSED_EVENT_ID';
        this.resultsHeaderLabel = 'se.cms.restrictionmanagement.restrictionresults.header';
        this.itemComponent = RestrictionManagementSelectItemComponent;
        this.editorHeader = '';
        this.isDirtyFnChange = new core.EventEmitter();
        this.submitFnChange = new core.EventEmitter();
    }
    ngOnInit() {
        this.selectModel = this.restrictionManagementSelectModelFactory.createRestrictionManagementSelectModel(this.fetchRestrictionTypes, this.getSupportedRestrictionTypes);
        const dryRunCmsItemsUri = smarteditcommons.cmsitemsUri + '/:identifier';
        this.viewConfig = {
            showRestrictionSelector: false,
            showRestrictionEditor: false,
            mode: 'add',
            contentApi: new smarteditcommons.URIBuilder(dryRunCmsItemsUri).replaceParams(this.uriContext).build()
        };
        this.fetchOptions = {
            fetchPage: (search, pageSize, currentPage) => this.selectModel.getRestrictionsPaged(search, pageSize, currentPage),
            fetchEntity: () => this.selectModel.getRestrictionFromBackend()
        };
        this.fetchStrategy = {
            fetchAll: () => this.selectModel.getRestrictionTypes()
        };
        this.disableRestrictionChoice = (restriction) => !!this.existingRestrictions.find((existingRestriction) => restriction.uid === existingRestriction.uid);
        setTimeout(() => {
            this.submitFnChange.emit(() => __awaiter(this, void 0, void 0, function* () {
                if (this.selectModel.isTypeSupported()) {
                    return this.submitInternal().then((value) => value);
                }
                return this.selectModel.getRestriction();
            }));
            this.isDirtyFnChange.emit(() => {
                if (this.viewConfig.mode === 'add') {
                    return this.viewConfig.showRestrictionEditor;
                }
                else if (this.isDirtyInternal) {
                    return this.isDirtyInternal();
                }
                return false;
            });
        });
        this.createButtonUnsubscribe = this.systemEventService.subscribe(this.RESTRICTION_CREATE_BUTTON_PRESSED_EVENT_ID, (_eventId, eventData) => this.createButtonEventHandler(eventData));
    }
    ngOnDestroy() {
        if (this.createButtonUnsubscribe) {
            this.createButtonUnsubscribe();
        }
    }
    selectRestrictionType() {
        if (this.selectModel.restrictionTypeSelected()) {
            if (this.viewConfig.showRestrictionSelector) {
                this.resetSelector();
            }
            else {
                this.viewConfig.showRestrictionSelector = true;
            }
            this.viewConfig.showRestrictionEditor = false;
        }
        this.actionableSearchItem = this.selectModel.isTypeSupported()
            ? { eventId: this.RESTRICTION_CREATE_BUTTON_PRESSED_EVENT_ID }
            : undefined;
    }
    selectRestriction() {
        if (this.selectModel.restrictionSelected()) {
            this.setViewConfig('se.cms.restriction.management.select.editor.header.add', 'add');
            if (!this.viewConfig.showRestrictionEditor) {
                this.viewConfig.showRestrictionEditor = true;
            }
        }
    }
    createRestriction(name) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.selectModel.createRestrictionSelected(name, this.uriContext);
            this.setViewConfig('se.cms.restriction.management.select.editor.header.create', 'create');
            if (this.viewConfig.showRestrictionEditor) {
                this.resetSelector();
            }
            else {
                this.viewConfig.showRestrictionEditor = true;
            }
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    showWarningMessage() {
        return this.selectModel.getRestriction() && !this.selectModel.isTypeSupported();
    }
    createButtonEventHandler(name) {
        this.createRestriction(name);
    }
    resetSelector() {
        if (typeof this.reset === 'function') {
            this.reset(true);
        }
    }
    setViewConfig(editorHeader, mode) {
        this.editorHeader = editorHeader;
        this.viewConfig.mode = mode;
        this.viewConfig.structureApi = this.restrictionsService.getStructureApiUri(this.viewConfig.mode);
    }
};
RestrictionManagementSelectComponent.$inject = ["restrictionManagementSelectModelFactory", "restrictionsService", "systemEventService", "cdr"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ RestrictionManagementSelectComponent.prototype, "uriContext", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Array)
], /* @ngInject */ RestrictionManagementSelectComponent.prototype, "existingRestrictions", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ RestrictionManagementSelectComponent.prototype, "fetchRestrictionTypes", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ RestrictionManagementSelectComponent.prototype, "getSupportedRestrictionTypes", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ RestrictionManagementSelectComponent.prototype, "isDirtyFn", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ RestrictionManagementSelectComponent.prototype, "submitFn", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ RestrictionManagementSelectComponent.prototype, "isDirtyFnChange", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ RestrictionManagementSelectComponent.prototype, "submitFnChange", void 0);
/* @ngInject */ RestrictionManagementSelectComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-restriction-management-select',
        template: `<div><se-message [style.display]="showWarningMessage() ? 'block' : 'none'" [type]="'warning'"><span se-message-title translate="se.cms.restriction.management.select.type.not.supported.warning"></span></se-message><div class="se-restriction-management-select__select"><label class="se-control-label">{{ 'se.cms.restriction.management.select.type.label' | translate }}</label><se-select id="restriction-type" [fetchStrategy]="fetchStrategy" [itemComponent]="itemComponent" [placeholder]="'se.cms.restriction.management.select.type.placeholder'" [(model)]="selectModel.selectedIds.restrictionType" (modelChange)="selectRestrictionType()" [searchEnabled]="false"></se-select></div><div *ngIf="viewConfig.showRestrictionSelector" class="se-restriction-management-select__restriction-info"><label class="se-control-label" translate="se.cms.restriction.management.select.restriction.label"></label><se-select id="restriction-name" [fetchStrategy]="fetchOptions" [(model)]="selectModel.selectedIds.restriction" (modelChange)="selectRestriction()" [placeholder]="'se.cms.restriction.management.select.restriction.placeholder'" [disableChoiceFn]="disableRestrictionChoice" [itemComponent]="itemComponent" [resultsHeaderLabel]="resultsHeaderLabel" [actionableSearchItem]="actionableSearchItem" [(reset)]="reset"></se-select></div><div class="se-restriction-management-select__restriction-editor" *ngIf="viewConfig.showRestrictionEditor"><p class="se-restriction-management-select__new-restriction-message" [translate]="editorHeader"></p><div *ngIf="selectModel.isTypeSupported()"><se-item-manager [item]="selectModel.getRestriction()" [mode]="viewConfig.mode" [structureApi]="viewConfig.structureApi" [contentApi]="viewConfig.contentApi" [uriContext]="uriContext" [componentType]="selectModel.getRestrictionTypeCode()" [(submitFunction)]="submitInternal" [(isDirty)]="isDirtyInternal"></se-item-manager></div><div *ngIf="!selectModel.isTypeSupported()"><p class="se-restriction__item-name">{{ selectModel.getRestriction().name }}</p><div class="se-restriction__item-description">{{ selectModel.getRestriction().description }}</div></div></div></div>`,
        styles: [`se-restriction-management-select .se-restriction-management-select__restriction-info,se-restriction-management-select .se-restriction-management-select__select{margin-bottom:16px}se-restriction-management-select .se-restriction-management-select__restriction-editor{border-top:1px solid #d9d9d9;padding-top:16px}se-restriction-management-select .se-restriction-management-select__new-restriction-message{font-weight:700}se-restriction-management-select .fd-menu__list-header{font-size:1.1428571429rem;line-height:1.25;font-weight:400;padding:8px 12px;border-bottom:1px solid #d9d9d9;color:#51555a;list-style:none;padding-left:24px}se-restriction-management-select .se-select-list__item.is-disabled{opacity:.65}se-restriction-management-select .se-select-list__item.is-disabled .fd-menu__item{cursor:not-allowed}se-restriction-management-select div.se-actionable-search-item{display:flex;align-items:center;justify-content:space-between;padding:0 0 0 13px}`],
        encapsulation: core.ViewEncapsulation.None,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [RestrictionManagementSelectModelFactory,
        exports.RestrictionsService,
        smarteditcommons.SystemEventService,
        core.ChangeDetectorRef])
], /* @ngInject */ RestrictionManagementSelectComponent);

window.__smartedit__.addDecoratorPayload("Component", "RestrictionsTableComponent", {
    selector: 'se-restrictions-table',
    template: `<div class="se-restriction-table-wrapper se-restriction-table-left" [ngClass]="customClass"><div class="se-restrictions-list fd-menu__list fd-menu__list--separated" *ngIf="restrictions.length > 0"><div id="restriction-{{ index + 1 }}" *ngFor="let restriction of restrictions; let index = index" class="se-restriction__item fd-menu__item"><div class="se-restrictions-list__item-content"><p class="se-restriction__item-name" [ngClass]="{ 'error-input': isInError(index) }">{{ restriction.name }}</p><div class="se-restriction__item-type-and-id" [ngClass]="{ 'error-input': isInError(index) }">{{ restriction.typeCode }}</div><div class="se-restriction__item-description" [ngClass]="{ 'error-input': isInError(index) }" [title]="restriction.description">{{ restriction.description }}</div><div id="restrictionPartOfWorkflow" *ngIf="restriction.canBeEdited!==undefined && !restriction.canBeEdited" translate="se.cms.restrictions.editor.part.of.workflow"></div></div><div *ngIf="editable"><se-dropdown-menu [dropdownItems]="restriction.actions || defaultActions" [selectedItem]="restriction" [placement]="'bottom-start'"></se-dropdown-menu></div></div></div><div *ngIf="restrictions.length === 0" class="se-restrictions-list--empty"><span class="se-restrictions-list--empty__message" translate="se.cms.restrictions.emptylist.message"></span></div></div>`,
    styles: [`.se-restrictions-list .se-restriction__item{display:flex;flex-direction:row;align-items:center;justify-content:space-between;border-top-color:#eeeeef!important;cursor:default}.se-restrictions-list .se-restriction__item:last-child{margin-bottom:42px}.se-restriction__item-name{font-weight:700;color:#32363a;margin:0}.se-restriction__item-type-and-id{color:#51555a;margin-top:0}.se-restriction__item-description{text-overflow:ellipsis;white-space:initial;overflow:hidden;word-break:break-all;color:#6a6d70;width:90%}.se-restrictions-list--empty__message{color:#6a6d70}.error-input.se-restriction__item-description,.error-input.se-restriction__item-name,.error-input.se-restriction__item-type-and-id{color:#b00}`]
});
let /* @ngInject */ RestrictionsTableComponent = class /* @ngInject */ RestrictionsTableComponent {
    constructor(pageRestrictionsCriteriaService) {
        this.pageRestrictionsCriteriaService = pageRestrictionsCriteriaService;
        this.REMOVE_RESTRICTION_KEY = 'se.cms.restrictions.item.remove';
        this.EDIT_RESTRICTION_KEY = 'se.cms.restrictions.item.edit';
        this.onEdit = new core.EventEmitter();
        this.onRemove = new core.EventEmitter();
        this.errors = [];
        this.criteriaOptions = [];
        this.defaultActions = [];
        this.oldRestrictionsEditability = [];
    }
    ngOnInit() {
        this.oldRestrictionsEditability = this.getRestrictionsEditability(this.restrictions);
        this.defaultActions = this.getDefaultActions();
        this.provideActionsForRestrictions();
        this.criteriaOptions = this.pageRestrictionsCriteriaService.getRestrictionCriteriaOptions();
        this.resetRestrictionCriteria();
    }
    ngOnChanges() {
        if (this.restrictionsEditabilityChanged(this.restrictions)) {
            this.provideActionsForRestrictions();
            this.oldRestrictionsEditability = this.getRestrictionsEditability(this.restrictions);
        }
        this.resetRestrictionCriteria();
    }
    resetRestrictionCriteria() {
        if (!this.restrictions || this.restrictions.length < 2) {
            this.restrictionCriteria = this.criteriaOptions[0];
        }
    }
    removeRestriction(restrictionToRemove) {
        const restrictionIndex = this.restrictions.findIndex((restriction) => restriction.uuid === restrictionToRemove.uuid);
        this.onRemove.emit(restrictionIndex);
        this.removeUnnecessaryError(restrictionIndex);
        this.modifyErrorPositions(restrictionIndex);
    }
    editRestriction(restriction) {
        this.onEdit.emit(restriction);
    }
    isInError(index) {
        var _a;
        return !!((_a = this.errors) === null || _a === void 0 ? void 0 : _a.some((error) => error.position === index));
    }
    getRestrictionsEditability(restrictions) {
        return (restrictions || []).map((restriction) => restriction.canBeEdited);
    }
    modifyErrorPositions(removedRestrictionIndex) {
        this.errors = this.errors.map((error) => {
            if (error.position >= removedRestrictionIndex) {
                error.position = error.position - 1;
            }
            return error;
        });
    }
    removeUnnecessaryError(removedRestrictionIndex) {
        const errorIndex = this.errors.findIndex((error) => error.position === removedRestrictionIndex);
        if (errorIndex > -1) {
            this.errors = this.errors.filter((_, index) => index !== errorIndex);
        }
    }
    getDefaultActions() {
        return [
            {
                key: this.EDIT_RESTRICTION_KEY,
                callback: (restriction) => this.editRestriction(restriction)
            },
            {
                key: this.REMOVE_RESTRICTION_KEY,
                callback: (restrictionToRemove) => this.removeRestriction(restrictionToRemove),
                customCss: 'se-dropdown-item__delete'
            }
        ];
    }
    getRestrictionActions(restriction) {
        const actions = this.getDefaultActions();
        if (!restriction.canBeEdited) {
            return actions.filter((action) => action.key !== this.EDIT_RESTRICTION_KEY);
        }
        return actions;
    }
    provideActionsForRestrictions() {
        (this.restrictions || []).forEach((restriction) => {
            restriction.actions = this.getRestrictionActions(restriction);
        });
    }
    restrictionsEditabilityChanged(restrictions) {
        const restrictionsEditability = this.getRestrictionsEditability(restrictions);
        return !lodash.isEqual(restrictionsEditability, this.oldRestrictionsEditability);
    }
};
RestrictionsTableComponent.$inject = ["pageRestrictionsCriteriaService"];
__decorate([
    core.Input(),
    __metadata("design:type", Array)
], /* @ngInject */ RestrictionsTableComponent.prototype, "restrictions", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ RestrictionsTableComponent.prototype, "customClass", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], /* @ngInject */ RestrictionsTableComponent.prototype, "editable", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ RestrictionsTableComponent.prototype, "restrictionCriteria", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Array)
], /* @ngInject */ RestrictionsTableComponent.prototype, "errors", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ RestrictionsTableComponent.prototype, "onEdit", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ RestrictionsTableComponent.prototype, "onRemove", void 0);
/* @ngInject */ RestrictionsTableComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-restrictions-table',
        template: `<div class="se-restriction-table-wrapper se-restriction-table-left" [ngClass]="customClass"><div class="se-restrictions-list fd-menu__list fd-menu__list--separated" *ngIf="restrictions.length > 0"><div id="restriction-{{ index + 1 }}" *ngFor="let restriction of restrictions; let index = index" class="se-restriction__item fd-menu__item"><div class="se-restrictions-list__item-content"><p class="se-restriction__item-name" [ngClass]="{ 'error-input': isInError(index) }">{{ restriction.name }}</p><div class="se-restriction__item-type-and-id" [ngClass]="{ 'error-input': isInError(index) }">{{ restriction.typeCode }}</div><div class="se-restriction__item-description" [ngClass]="{ 'error-input': isInError(index) }" [title]="restriction.description">{{ restriction.description }}</div><div id="restrictionPartOfWorkflow" *ngIf="restriction.canBeEdited!==undefined && !restriction.canBeEdited" translate="se.cms.restrictions.editor.part.of.workflow"></div></div><div *ngIf="editable"><se-dropdown-menu [dropdownItems]="restriction.actions || defaultActions" [selectedItem]="restriction" [placement]="'bottom-start'"></se-dropdown-menu></div></div></div><div *ngIf="restrictions.length === 0" class="se-restrictions-list--empty"><span class="se-restrictions-list--empty__message" translate="se.cms.restrictions.emptylist.message"></span></div></div>`,
        styles: [`.se-restrictions-list .se-restriction__item{display:flex;flex-direction:row;align-items:center;justify-content:space-between;border-top-color:#eeeeef!important;cursor:default}.se-restrictions-list .se-restriction__item:last-child{margin-bottom:42px}.se-restriction__item-name{font-weight:700;color:#32363a;margin:0}.se-restriction__item-type-and-id{color:#51555a;margin-top:0}.se-restriction__item-description{text-overflow:ellipsis;white-space:initial;overflow:hidden;word-break:break-all;color:#6a6d70;width:90%}.se-restrictions-list--empty__message{color:#6a6d70}.error-input.se-restriction__item-description,.error-input.se-restriction__item-name,.error-input.se-restriction__item-type-and-id{color:#b00}`]
    }),
    __metadata("design:paramtypes", [exports.PageRestrictionsCriteriaService])
], /* @ngInject */ RestrictionsTableComponent);

window.__smartedit__.addDecoratorPayload("Component", "RestrictionEditorCriteriaSelectItemComponent", {
    selector: 'se-restriction-editor-criteria-select-item',
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    template: `<span [translate]="data.item.editLabel"></span>`
});
let RestrictionEditorCriteriaSelectItemComponent = class RestrictionEditorCriteriaSelectItemComponent {
    constructor(data) {
        this.data = data;
    }
};
RestrictionEditorCriteriaSelectItemComponent = __decorate([
    core.Component({
        selector: 'se-restriction-editor-criteria-select-item',
        changeDetection: core.ChangeDetectionStrategy.OnPush,
        template: `<span [translate]="data.item.editLabel"></span>`
    }),
    __param(0, core.Inject(smarteditcommons.ITEM_COMPONENT_DATA_TOKEN)),
    __metadata("design:paramtypes", [Object])
], RestrictionEditorCriteriaSelectItemComponent);

const ITEM_MANAGEMENT_EDITOR_ID = 'se-item-management-editor';
window.__smartedit__.addDecoratorPayload("Component", "RestrictionsEditorComponent", {
    selector: 'se-restrictions-editor',
    template: `<div class="se-restrictions-container"><div class="se-restrictions-container__header" [ngClass]="{ 'se-restrictions-container__header--empty': restrictions.length === 0 }"><label class="se-restrictions__sub-header" translate="se.cms.restrictions.list.title"></label><div class="se-restrictions-container__header--right"><div *ngIf="restrictions.length > 1"><div *ngIf="editable"><se-select id="criteria-type" [fetchStrategy]="criteriaFetchStrategy" [itemComponent]="itemComponent" [placeholder]="'se.cms.restrictions.picker.type.placeholder'" [model]="criteria.id" (modelChange)="matchCriteriaChanged($event)" [searchEnabled]="false"></se-select></div><div *ngIf="!editable">{{ 'se.cms.restrictions.criteria' | translate }} {{ criteria.label | translate }}</div></div><button *ngIf="!showRestrictionPicker" type="button" class="se-restrictions__add-restriction-btn fd-button--cozy" [disabled]="!editable" (click)="onAddRestriction()"><span translate="se.cms.restrictions.editor.button.add.new"></span></button> <button class="cms-clean-btn se-restriction__clear-all__btn fd-button--light fd-button--compact" *ngIf="showRemoveAllButton()" (click)="removeAllRestrictions()" translate="se.cms.restrictions.list.clear.all"></button></div></div><se-slider-panel [sliderPanelConfiguration]="sliderPanelConfiguration" [(sliderPanelHide)]="sliderPanelHide" [(sliderPanelShow)]="sliderPanelShow" (isShownChange)="onSliderVisibilityChange($event)" class="se-add-restriction-panel"><se-restriction-management *ngIf="isSliderVisible" class="se-se-add-restriction-panel__restriction-management" [config]="restrictionManagement.config" [uriContext]="restrictionManagement.uriContext" [(submitFn)]="restrictionManagement.submitFn" [(isDirtyFn)]="restrictionManagement.isDirtyFn"></se-restriction-management></se-slider-panel><div *ngIf="errors.length > 0"><span class="se-help-block--has-error help-block fd-form__message fd-form__message--error" *ngFor="let error of errors" [translate]="error.message"></span></div><se-restrictions-table *ngIf="isRestrictionsReady" [editable]="editable" [restrictions]="restrictions" [restrictionCriteria]="criteria" [errors]="errors" [customClass]="'ySERestrictionListLink'" (onEdit)="onEditRestriction($event)" (onRemove)="onRemoveRestriction($event)"></se-restrictions-table></div>`,
    styles: [`.se-restrictions-container__header{display:flex;flex-direction:row;align-items:center;justify-content:space-between;border-bottom:1px solid #d9d9d9;padding-bottom:12px}.se-restrictions-container__header--right{display:flex;flex-direction:row;align-items:center}.se-restrictions-container__header--right>div,.se-restrictions-container__header--right>span{margin-left:12px;margin-right:16px;width:115px}.se-restrictions-container__header--empty{border-bottom:none}.se-restrictions__sub-header{font-weight:700;align-self:flex-start;color:#51555a;margin:0}.se-restriction__clear-all__btn{text-transform:capitalize}`]
});
let /* @ngInject */ RestrictionsEditorComponent = class /* @ngInject */ RestrictionsEditorComponent {
    constructor(logService, systemEventService, restrictionPickerConfigService, pageRestrictionsCriteriaService, contextAwareEditableItemService, cmsitemsRestService, cdr) {
        this.logService = logService;
        this.systemEventService = systemEventService;
        this.restrictionPickerConfigService = restrictionPickerConfigService;
        this.pageRestrictionsCriteriaService = pageRestrictionsCriteriaService;
        this.contextAwareEditableItemService = contextAwareEditableItemService;
        this.cmsitemsRestService = cmsitemsRestService;
        this.cdr = cdr;
        this.cancelFnChange = new core.EventEmitter();
        this.isDirtyFnChange = new core.EventEmitter();
        this.onRestrictionsChange = new core.EventEmitter();
        this.resetFnChange = new core.EventEmitter();
        this.errors = [];
        this.restrictions = [];
        this.originalRestrictions = [];
        this.restrictionUuids = [];
        this.isRestrictionsReady = false;
        this.restrictionsArrayIsDirty = false;
        this.showRestrictionPicker = false;
        this.disableAddButton = false;
        this.criteriaOptions = [];
        this.criteria = {};
        this.itemComponent = RestrictionEditorCriteriaSelectItemComponent;
        this.matchCriteriaIsDirty = false;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.restrictionUuids = this.restrictionUuids || [];
            const restrictionsData = yield this.cmsitemsRestService.getByIdsNoCache(this.restrictionUuids, 'FULL');
            const restrictionUuidsLength = 2;
            this.restrictions = (restrictionsData.response
                ? restrictionsData.response
                : [restrictionsData]);
            this.criteriaFetchStrategy = {
                fetchAll: () => Promise.resolve(this.criteriaOptions)
            };
            this.prepareRestrictionsCriteria();
            yield this.setupResults();
            this.sliderPanelConfiguration = {
                modal: {
                    showDismissButton: true,
                    title: '',
                    dismiss: {
                        label: 'se.cms.restriction.management.panel.button.cancel',
                        onClick: () => {
                            this.sliderPanelHide();
                        },
                        isDisabledFn: () => false
                    },
                    save: {
                        onClick: () => {
                        },
                        label: '',
                        isDisabledFn: () => false
                    }
                },
                cssSelector: '#y-modal-dialog'
            };
            this.restrictionManagement = {
                uriContext: this.item.uriContext,
                submitFn: null,
                isDirtyFn: null,
                config: null
            };
            this.isDirtyFnChange.emit(() => this.restrictionsArrayIsDirty ||
                (this.matchCriteriaIsDirty &&
                    this.restrictionUuids.length >= restrictionUuidsLength));
            this.resetFnChange.emit(() => true);
            this.cancelFnChange.emit(() => Promise.resolve(true));
            this.initEvents();
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    ngOnDestroy() {
        this.clearEvents();
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!changes.restrictionUuids) {
                return Promise.resolve();
            }
            this.restrictionsArrayIsDirty =
                !changes.restrictionUuids.firstChange &&
                    JSON.stringify(this.originalRestrictions) !== JSON.stringify(this.restrictions);
            const haveRestrictionsChanged = !lodash.isEqual(changes.restrictionUuids.previousValue, changes.restrictionUuids.currentValue);
            if (haveRestrictionsChanged) {
                this.indexRestrictions();
            }
            return this.applyIsRestrictionEditable();
        });
    }
    onAddRestriction() {
        this.setSliderConfigForAddOrCreate();
        this.restrictionManagement.config = this.restrictionPickerConfigService.getConfigForSelecting([...this.restrictions], this.getRestrictionTypes, this.getSupportedRestrictionTypes);
        this.sliderPanelShow();
    }
    onEditRestriction(restriction) {
        this.setSliderConfigForEditing();
        this.restrictionManagement.config = this.restrictionPickerConfigService.getConfigForEditing(Object.assign({}, restriction), this.getSupportedRestrictionTypes);
        this.sliderPanelShow();
    }
    onRemoveRestriction(restrictionIndex) {
        this.restrictions = this.restrictions.filter((_, index) => index !== restrictionIndex);
        this.updateRestrictionsData();
    }
    removeAllRestrictions() {
        this.restrictions = [];
        if (this.removeValidationMessages) {
            this.removeValidationMessages();
        }
        this.updateRestrictionsData();
    }
    showRemoveAllButton() {
        return this.restrictionUuids.length > 0 && this.editable;
    }
    matchCriteriaChanged(selectedCriteriaId) {
        this.criteria = this.criteriaOptions.find((criteria) => criteria.id === selectedCriteriaId);
        this.matchCriteriaIsDirty = this.criteria !== this.originalCriteria;
        this.updateRestrictionsData();
    }
    onSliderVisibilityChange(isVisible) {
        this.isSliderVisible = isVisible;
    }
    setupResults() {
        return __awaiter(this, void 0, void 0, function* () {
            this.indexRestrictions();
            this.originalRestrictions = this.cloneRestrictions(this.restrictions);
            this.updateRestrictionsData();
            yield this.applyIsRestrictionEditable();
            this.isRestrictionsReady = true;
        });
    }
    updateRestrictionsData(alwaysEnableSubmit = false) {
        this.onRestrictionsChange.emit({
            onlyOneRestrictionMustApply: this.criteria.value,
            restrictionUuids: this.restrictions.map((restriction) => restriction.uuid),
            alwaysEnableSubmit
        });
    }
    prepareRestrictionsCriteria() {
        this.criteriaOptions = this.pageRestrictionsCriteriaService.getRestrictionCriteriaOptions();
        if (!!this.item.onlyOneRestrictionMustApply) {
            this.criteria = this.criteriaOptions[1];
            this.originalCriteria = this.criteriaOptions[1];
        }
        else {
            this.criteria = this.criteriaOptions[0];
            this.originalCriteria = this.criteriaOptions[0];
        }
    }
    isRestrictionRelatedError(validationError) {
        return lodash.includes(validationError.subject, 'restrictions');
    }
    formatRestrictionRelatedError(validationError) {
        const error = lodash.clone(validationError);
        if (!smarteditcommons.stringUtils.isBlank(error.position)) {
            error.position = parseInt(error.position, 10);
        }
        if (!smarteditcommons.stringUtils.isBlank(error.subject)) {
            error.subject = error.subject.split('.').pop();
        }
        return error;
    }
    handleUnrelatedValidationErrors(validationData) {
        this.errors = validationData.messages
            .filter((error) => this.isRestrictionRelatedError(error))
            .map((error) => this.formatRestrictionRelatedError(error));
    }
    propagateErrors(genericEditorId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const restrictionInEditMode = ((_a = this.restrictionManagement.config) === null || _a === void 0 ? void 0 : _a.mode) ===
                this.restrictionPickerConfigService.MODE_EDITING &&
                genericEditorId === ITEM_MANAGEMENT_EDITOR_ID;
            if (!restrictionInEditMode) {
                return;
            }
            const restrictionIndex = this.restrictionManagement.config
                .restriction.restrictionIndex;
            const errorsToPropagate = this.errors.filter((error) => error.position === restrictionIndex);
            this.clearEvents();
            yield this.systemEventService.publishAsync(smarteditcommons.GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT, {
                messages: errorsToPropagate,
                targetGenericEditorId: genericEditorId
            });
            this.initEvents();
        });
    }
    indexRestrictions() {
        this.restrictions = (this.restrictions || []).map((restriction, index) => (Object.assign(Object.assign({}, restriction), { restrictionIndex: index })));
    }
    cloneRestrictions(restrictions) {
        return lodash.cloneDeep(restrictions);
    }
    initEvents() {
        this.unregisterErrorListener = this.systemEventService.subscribe(smarteditcommons.GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT, (_eventId, data) => this.handleUnrelatedValidationErrors(data));
        this.unregisterErrorPropagationEvent = this.systemEventService.subscribe(smarteditcommons.GENERIC_EDITOR_LOADED_EVENT, (_eventId, data) => this.propagateErrors(data));
    }
    clearEvents() {
        try {
            this.unregisterErrorListener();
            this.unregisterErrorPropagationEvent();
        }
        catch (e) {
        }
    }
    applyIsRestrictionEditable() {
        return __awaiter(this, void 0, void 0, function* () {
            this.restrictions = yield Promise.all(this.restrictions.map((restriction) => __awaiter(this, void 0, void 0, function* () {
                if (restriction.uid) {
                    restriction.canBeEdited = yield this.contextAwareEditableItemService.isItemEditable(restriction.uid);
                    if (!this.cdr.destroyed) {
                        this.cdr.detectChanges();
                    }
                    return restriction;
                }
                restriction.canBeEdited = true;
                if (!this.cdr.destroyed) {
                    this.cdr.detectChanges();
                }
                return restriction;
            })));
        });
    }
    setSliderConfigForAddOrCreate() {
        this.sliderPanelConfiguration.modal.title = 'se.cms.restriction.management.panel.title.add';
        this.sliderPanelConfiguration.modal.save.label =
            'se.cms.restriction.management.panel.button.add';
        this.sliderPanelConfiguration.modal.save.isDisabledFn = () => {
            if (this.disableAddButton) {
                return true;
            }
            if (this.restrictionManagement.isDirtyFn) {
                return !this.restrictionManagement.isDirtyFn();
            }
            return true;
        };
        this.sliderPanelConfiguration.modal.save.onClick = () => __awaiter(this, void 0, void 0, function* () {
            try {
                this.disableAddButton = true;
                const restriction = yield this.restrictionManagement.submitFn();
                this.disableAddButton = false;
                this.restrictions = this.restrictions.concat(restriction);
                this.updateRestrictionsData();
                this.sliderPanelHide();
            }
            catch (_a) {
                this.disableAddButton = false;
                this.logService.warn('RestrictionsEditorComponent.setSliderConfigForAddOrCreate - Failed to create restriction');
            }
        });
    }
    setSliderConfigForEditing() {
        this.sliderPanelConfiguration.modal.title =
            'se.cms.restriction.management.panel.title.edit';
        this.sliderPanelConfiguration.modal.save.label =
            'se.cms.restriction.management.panel.button.save';
        this.sliderPanelConfiguration.modal.save.isDisabledFn = () => {
            if (this.restrictionManagement.isDirtyFn) {
                return !this.restrictionManagement.isDirtyFn();
            }
            return true;
        };
        this.sliderPanelConfiguration.modal.save.onClick = () => __awaiter(this, void 0, void 0, function* () {
            const restrictionEdited = yield this.restrictionManagement.submitFn();
            if (this.restrictionManagement.config) {
                const payloadRestriction = this.restrictionManagement
                    .config.restriction;
                restrictionEdited.restrictionIndex = payloadRestriction.restrictionIndex;
            }
            const restrictionIndex = restrictionEdited.restrictionIndex;
            if (restrictionIndex !== -1) {
                this.restrictions = this.restrictions.map((restriction, index) => {
                    if (index === restrictionIndex) {
                        return restrictionEdited;
                    }
                    return restriction;
                });
            }
            else {
                throw new Error('RestrictionsEditorComponent - edited restriction not found in list: ' +
                    restrictionEdited);
            }
            this.updateRestrictionsData(true);
            this.sliderPanelHide();
        });
    }
};
RestrictionsEditorComponent.$inject = ["logService", "systemEventService", "restrictionPickerConfigService", "pageRestrictionsCriteriaService", "contextAwareEditableItemService", "cmsitemsRestService", "cdr"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ RestrictionsEditorComponent.prototype, "item", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], /* @ngInject */ RestrictionsEditorComponent.prototype, "editable", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ RestrictionsEditorComponent.prototype, "resetFn", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ RestrictionsEditorComponent.prototype, "cancelFn", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ RestrictionsEditorComponent.prototype, "isDirtyFn", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ RestrictionsEditorComponent.prototype, "getRestrictionTypes", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ RestrictionsEditorComponent.prototype, "getSupportedRestrictionTypes", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ RestrictionsEditorComponent.prototype, "removeValidationMessages", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Array)
], /* @ngInject */ RestrictionsEditorComponent.prototype, "restrictionUuids", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ RestrictionsEditorComponent.prototype, "onRestrictionsChange", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ RestrictionsEditorComponent.prototype, "resetFnChange", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ RestrictionsEditorComponent.prototype, "cancelFnChange", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ RestrictionsEditorComponent.prototype, "isDirtyFnChange", void 0);
/* @ngInject */ RestrictionsEditorComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-restrictions-editor',
        template: `<div class="se-restrictions-container"><div class="se-restrictions-container__header" [ngClass]="{ 'se-restrictions-container__header--empty': restrictions.length === 0 }"><label class="se-restrictions__sub-header" translate="se.cms.restrictions.list.title"></label><div class="se-restrictions-container__header--right"><div *ngIf="restrictions.length > 1"><div *ngIf="editable"><se-select id="criteria-type" [fetchStrategy]="criteriaFetchStrategy" [itemComponent]="itemComponent" [placeholder]="'se.cms.restrictions.picker.type.placeholder'" [model]="criteria.id" (modelChange)="matchCriteriaChanged($event)" [searchEnabled]="false"></se-select></div><div *ngIf="!editable">{{ 'se.cms.restrictions.criteria' | translate }} {{ criteria.label | translate }}</div></div><button *ngIf="!showRestrictionPicker" type="button" class="se-restrictions__add-restriction-btn fd-button--cozy" [disabled]="!editable" (click)="onAddRestriction()"><span translate="se.cms.restrictions.editor.button.add.new"></span></button> <button class="cms-clean-btn se-restriction__clear-all__btn fd-button--light fd-button--compact" *ngIf="showRemoveAllButton()" (click)="removeAllRestrictions()" translate="se.cms.restrictions.list.clear.all"></button></div></div><se-slider-panel [sliderPanelConfiguration]="sliderPanelConfiguration" [(sliderPanelHide)]="sliderPanelHide" [(sliderPanelShow)]="sliderPanelShow" (isShownChange)="onSliderVisibilityChange($event)" class="se-add-restriction-panel"><se-restriction-management *ngIf="isSliderVisible" class="se-se-add-restriction-panel__restriction-management" [config]="restrictionManagement.config" [uriContext]="restrictionManagement.uriContext" [(submitFn)]="restrictionManagement.submitFn" [(isDirtyFn)]="restrictionManagement.isDirtyFn"></se-restriction-management></se-slider-panel><div *ngIf="errors.length > 0"><span class="se-help-block--has-error help-block fd-form__message fd-form__message--error" *ngFor="let error of errors" [translate]="error.message"></span></div><se-restrictions-table *ngIf="isRestrictionsReady" [editable]="editable" [restrictions]="restrictions" [restrictionCriteria]="criteria" [errors]="errors" [customClass]="'ySERestrictionListLink'" (onEdit)="onEditRestriction($event)" (onRemove)="onRemoveRestriction($event)"></se-restrictions-table></div>`,
        styles: [`.se-restrictions-container__header{display:flex;flex-direction:row;align-items:center;justify-content:space-between;border-bottom:1px solid #d9d9d9;padding-bottom:12px}.se-restrictions-container__header--right{display:flex;flex-direction:row;align-items:center}.se-restrictions-container__header--right>div,.se-restrictions-container__header--right>span{margin-left:12px;margin-right:16px;width:115px}.se-restrictions-container__header--empty{border-bottom:none}.se-restrictions__sub-header{font-weight:700;align-self:flex-start;color:#51555a;margin:0}.se-restriction__clear-all__btn{text-transform:capitalize}`]
    }),
    __metadata("design:paramtypes", [smarteditcommons.LogService,
        smarteditcommons.SystemEventService,
        RestrictionPickerConfigService,
        exports.PageRestrictionsCriteriaService,
        cmscommons.IContextAwareEditableItemService,
        smarteditcommons.CmsitemsRestService,
        core.ChangeDetectorRef])
], /* @ngInject */ RestrictionsEditorComponent);

let RestrictionsModule = class RestrictionsModule {
};
RestrictionsModule = __decorate([
    core.NgModule({
        imports: [
            common.CommonModule,
            core$1.TranslateModule.forChild(),
            smarteditcommons.SeGenericEditorModule,
            smarteditcommons.MessageModule,
            smarteditcommons.SelectModule,
            smarteditcommons.L10nPipeModule,
            smarteditcommons.DropdownMenuModule,
            smarteditcommons.SliderPanelModule
        ],
        providers: [RestrictionPickerConfigService, RestrictionManagementSelectModelFactory],
        declarations: [
            RestrictionManagementEditComponent,
            ItemManagementComponent,
            RestrictionManagementSelectComponent,
            RestrictionManagementSelectItemComponent,
            RestrictionManagementComponent,
            RestrictionsTableComponent,
            RestrictionsEditorComponent,
            RestrictionEditorCriteriaSelectItemComponent
        ],
        entryComponents: [
            RestrictionManagementEditComponent,
            ItemManagementComponent,
            RestrictionManagementSelectComponent,
            RestrictionManagementSelectItemComponent,
            RestrictionManagementComponent,
            RestrictionsTableComponent,
            RestrictionsEditorComponent,
            RestrictionEditorCriteriaSelectItemComponent
        ],
        exports: [RestrictionsEditorComponent]
    })
], RestrictionsModule);

window.__smartedit__.addDecoratorPayload("Component", "PageRestrictionsEditorComponent", {
    selector: 'se-page-restrictions-editor',
    template: `<se-page-restrictions-info-message *ngIf="page.restrictions?.length > 1"></se-page-restrictions-info-message><se-restrictions-editor [editable]="isEditable" [getRestrictionTypes]="getRestrictionTypes" [getSupportedRestrictionTypes]="getSupportedRestrictionTypes" [item]="page" [restrictionUuids]="page.restrictions" [removeValidationMessages]="onRemoveValidationMessages" (onRestrictionsChange)="onRestrictionsChange($event)"></se-restrictions-editor>`
});
/* @ngInject */ exports.PageRestrictionsEditorComponent = class /* @ngInject */ PageRestrictionsEditorComponent {
    constructor(data, restrictionsService, restrictionTypesService) {
        this.data = data;
        this.restrictionsService = restrictionsService;
        this.restrictionTypesService = restrictionTypesService;
        ({ editor: this.editor, model: this.page } = data);
        this.isEditable = !data.isFieldDisabled();
    }
    ngOnInit() {
        this.initGetRestrictionTypes();
        this.initSupportedRestrictionTypes();
        this.initOnRemoveValidationMessages();
    }
    onRestrictionsChange({ onlyOneRestrictionMustApply, restrictionUuids, alwaysEnableSubmit }) {
        this.page.onlyOneRestrictionMustApply = onlyOneRestrictionMustApply;
        this.page.restrictions = restrictionUuids;
    }
    initGetRestrictionTypes() {
        this.getRestrictionTypes = () => this.restrictionTypesService.getRestrictionTypesByPageType(this.page.typeCode);
    }
    initSupportedRestrictionTypes() {
        this.getSupportedRestrictionTypes = () => this.restrictionsService.getSupportedRestrictionTypeCodes();
    }
    initOnRemoveValidationMessages() {
        this.onRemoveValidationMessages = () => this.editor.api.clearMessages();
    }
};
exports.PageRestrictionsEditorComponent.$inject = ["data", "restrictionsService", "restrictionTypesService"];
/* @ngInject */ exports.PageRestrictionsEditorComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-restrictions-editor',
        template: `<se-page-restrictions-info-message *ngIf="page.restrictions?.length > 1"></se-page-restrictions-info-message><se-restrictions-editor [editable]="isEditable" [getRestrictionTypes]="getRestrictionTypes" [getSupportedRestrictionTypes]="getSupportedRestrictionTypes" [item]="page" [restrictionUuids]="page.restrictions" [removeValidationMessages]="onRemoveValidationMessages" (onRestrictionsChange)="onRestrictionsChange($event)"></se-restrictions-editor>`
    }),
    __param(0, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [Object, exports.RestrictionsService,
        exports.RestrictionTypesService])
], /* @ngInject */ exports.PageRestrictionsEditorComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageRestrictionsInfoMessageComponent", {
    selector: 'se-page-restrictions-info-message',
    template: `<se-message [type]="'info'" class="se-restrictions-info__message"><ng-container se-message-title>{{ 'se.cms.restrictions.editor.ymessage.title' | translate }}</ng-container><ng-container se-message-description>{{ 'se.cms.restrictions.editor.ymessage.description' | translate }}</ng-container></se-message>`,
    styles: [`.se-restrictions-info__message{margin-bottom:10px;display:block}`]
});
let /* @ngInject */ PageRestrictionsInfoMessageComponent = class /* @ngInject */ PageRestrictionsInfoMessageComponent {
};
/* @ngInject */ PageRestrictionsInfoMessageComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-restrictions-info-message',
        template: `<se-message [type]="'info'" class="se-restrictions-info__message"><ng-container se-message-title>{{ 'se.cms.restrictions.editor.ymessage.title' | translate }}</ng-container><ng-container se-message-description>{{ 'se.cms.restrictions.editor.ymessage.description' | translate }}</ng-container></se-message>`,
        styles: [`.se-restrictions-info__message{margin-bottom:10px;display:block}`]
    })
], /* @ngInject */ PageRestrictionsInfoMessageComponent);

exports.PageRestrictionsModule = class PageRestrictionsModule {
};
exports.PageRestrictionsModule = __decorate([
    core.NgModule({
        imports: [common.CommonModule, smarteditcommons.MessageModule, RestrictionsModule, smarteditcommons.TranslationModule.forChild()],
        declarations: [exports.PageRestrictionsEditorComponent, PageRestrictionsInfoMessageComponent],
        entryComponents: [exports.PageRestrictionsEditorComponent, PageRestrictionsInfoMessageComponent],
        exports: [RestrictionsModule, PageRestrictionsInfoMessageComponent]
    })
], exports.PageRestrictionsModule);

exports.CmsComponentsModule = class CmsComponentsModule {
};
exports.CmsComponentsModule = __decorate([
    core.NgModule({
        imports: [
            common.CommonModule,
            smarteditcommons.TranslationModule.forChild(),
            exports.ComponentMenuModule,
            exports.PageRestrictionsModule,
            smarteditcommons.GenericEditorDropdownModule
        ],
        providers: [
            SelectComponentTypeModalService,
            NestedComponentManagementService,
            {
                provide: smarteditcommons.CustomDropdownPopulatorsToken,
                useClass: CMSItemDropdownDropdownPopulator,
                multi: true
            }
        ],
        declarations: [
            exports.SubTypeSelectorComponent,
            exports.SelectComponentTypeModalComponent,
            exports.ComponentRestrictionsEditorComponent,
            exports.CmsDropdownItemComponent,
            exports.CmsComponentDropdownComponent
        ],
        entryComponents: [
            exports.SubTypeSelectorComponent,
            exports.SelectComponentTypeModalComponent,
            exports.ComponentRestrictionsEditorComponent,
            exports.CmsDropdownItemComponent,
            exports.CmsComponentDropdownComponent
        ]
    })
], exports.CmsComponentsModule);

window.__smartedit__.addDecoratorPayload("Component", "ItemSelectorPanelComponent", {
    selector: 'se-item-selector-panel',
    template: `<se-slider-panel [sliderPanelConfiguration]="panelConfig" [(sliderPanelHide)]="hidePanel" [(sliderPanelShow)]="showPanel" class="se-item-selector-panel"><div *ngIf="catalogs.length > 0"><div *ngIf="catalogs.length > 1" class="se-item-selector-panel__selector"><label class="se-control-label" translate="se.cms.catalogaware.panel.catalogs.label"></label><se-select id="se-catalog-selector-dropdown" [(model)]="catalogInfo.catalogId" [fetchStrategy]="catalogSelectorFetchStrategy" [onChange]="onCatalogSelectorChange"></se-select><label>{{ catalogInfo.name | seL10n | async }}</label></div><div class="se-item-selector-panel__selector"><label class="se-control-label" translate="se.cms.catalogaware.panel.catalogsversion.label"></label><se-select id="se-catalog-version-selector-dropdown" [(model)]="catalogInfo.catalogVersion" [fetchStrategy]="catalogVersionSelectorFetchStrategy" [onChange]="onCatalogVersionSelectorChange" [searchEnabled]="false" [(reset)]="resetCatalogVersionSelector"></se-select></div><div class="se-item-selector-panel__selector" *ngIf="catalogInfo.catalogVersion"><label class="se-control-label" [translate]="catalogItemTypeI18nKey"></label><se-select id="se-items-selector-dropdown" [multiSelect]="true" [controls]="true" [(model)]="internalItemsSelected" [onChange]="onItemsSelectorChange" [fetchStrategy]="itemsSelectorFetchStrategy" [(reset)]="resetItemsListSelector" [itemComponent]="itemComponent" [isReadOnly]="!isItemSelectorEnabled()"></se-select></div></div></se-slider-panel>`,
    styles: [`.se-item-selector-panel__selector{margin-bottom:25px}`]
});
let /* @ngInject */ ItemSelectorPanelComponent = class /* @ngInject */ ItemSelectorPanelComponent {
    constructor() {
        this.onSaveChanges = new core.EventEmitter();
        this.catalogs = [];
        this.catalogInfo = {};
        this.saveButtonDisabled = true;
        this.internalItemsSelected = [];
        this.initOnCatalogSelectorChange();
        this.initOnCatalogVersionSelectorChange();
        this.initOnItemsSelectorChange();
    }
    ngOnInit() {
        this.panelConfig = {
            cssSelector: '#y-modal-dialog',
            noGreyedOutOverlay: true,
            modal: {
                title: this.catalogItemTypeI18nKey,
                showDismissButton: false,
                cancel: {
                    onClick: () => this.cancel(),
                    label: 'se.cms.catalogaware.panel.button.cancel',
                    isDisabledFn: () => false
                },
                save: {
                    onClick: () => this.saveChanges(),
                    label: 'se.cms.catalogaware.panel.button.add',
                    isDisabledFn: () => this.isSaveButtonDisabled()
                }
            }
        };
        return this.initCatalogs();
    }
    initAndShowPanel(selectedItems) {
        this.catalogInfo = {};
        this.initCatalogs();
        this.internalItemsSelected = selectedItems || [];
        this.showPanel();
    }
    isItemSelectorEnabled() {
        return (this.catalogInfo && !!this.catalogInfo.catalogId && !!this.catalogInfo.catalogVersion);
    }
    initOnCatalogSelectorChange() {
        this.onCatalogSelectorChange = () => {
            if (this.resetCatalogVersionSelector) {
                this.resetCatalogVersionSelector();
            }
        };
    }
    initOnCatalogVersionSelectorChange() {
        this.onCatalogVersionSelectorChange = () => {
            if (this.catalogInfo.catalogId && this.catalogInfo.catalogVersion) {
                if (this.resetItemsListSelector) {
                    this.resetItemsListSelector();
                }
            }
        };
    }
    initOnItemsSelectorChange() {
        this.onItemsSelectorChange = () => {
            if (this.isItemSelectorEnabled()) {
                this.saveButtonDisabled = false;
            }
        };
    }
    initCatalogs() {
        return __awaiter(this, void 0, void 0, function* () {
            this.catalogs = yield this.getCatalogs();
            if (this.catalogs.length === 1) {
                this.catalogInfo.catalogId = this.catalogs[0].id;
            }
            this.initCatalogSelector();
            this.initCatalogVersionSelector();
            this.initItemsSelector();
        });
    }
    initCatalogSelector() {
        this.catalogSelectorFetchStrategy = {
            fetchAll: () => Promise.resolve(this.catalogs)
        };
    }
    initCatalogVersionSelector() {
        this.catalogVersionSelectorFetchStrategy = {
            fetchAll: () => {
                let versions = [];
                if (this.catalogInfo.catalogId) {
                    const catalog = this.catalogs.find(({ id }) => id === this.catalogInfo.catalogId);
                    versions = catalog.versions.slice(0);
                }
                return Promise.resolve(versions);
            }
        };
    }
    initItemsSelector() {
        this.itemsSelectorFetchStrategy = {
            fetchPage: (mask, pageSize, currentPage) => this.itemsFetchPageAndFilter(mask, pageSize, currentPage),
            fetchEntity: (uid) => this.itemsFetchStrategy.fetchEntity(uid)
        };
    }
    itemsFetchPageAndFilter(mask, pageSize, currentPage) {
        return __awaiter(this, void 0, void 0, function* () {
            const page = yield this.itemsFetchStrategy.fetchPage(this.catalogInfo, mask, pageSize, currentPage);
            return this.limitToNonSelectedItems(page);
        });
    }
    limitToNonSelectedItems(page) {
        let itemIndex = page.results.length;
        while (itemIndex--) {
            const item = page.results[itemIndex];
            if (this.internalItemsSelected.includes(item.uid)) {
                page.results.splice(itemIndex, 1);
                page.pagination.count--;
            }
        }
        return page;
    }
    isSaveButtonDisabled() {
        return this.saveButtonDisabled;
    }
    cancel() {
        this.catalogInfo = {};
        this.hidePanel();
    }
    saveChanges() {
        this.onSaveChanges.emit([...this.internalItemsSelected]);
        this.hidePanel();
    }
};
__decorate([
    core.Input(),
    __metadata("design:type", core.Type)
], /* @ngInject */ ItemSelectorPanelComponent.prototype, "itemComponent", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ ItemSelectorPanelComponent.prototype, "getCatalogs", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ ItemSelectorPanelComponent.prototype, "itemsFetchStrategy", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ ItemSelectorPanelComponent.prototype, "catalogItemTypeI18nKey", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ ItemSelectorPanelComponent.prototype, "onSaveChanges", void 0);
/* @ngInject */ ItemSelectorPanelComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-item-selector-panel',
        template: `<se-slider-panel [sliderPanelConfiguration]="panelConfig" [(sliderPanelHide)]="hidePanel" [(sliderPanelShow)]="showPanel" class="se-item-selector-panel"><div *ngIf="catalogs.length > 0"><div *ngIf="catalogs.length > 1" class="se-item-selector-panel__selector"><label class="se-control-label" translate="se.cms.catalogaware.panel.catalogs.label"></label><se-select id="se-catalog-selector-dropdown" [(model)]="catalogInfo.catalogId" [fetchStrategy]="catalogSelectorFetchStrategy" [onChange]="onCatalogSelectorChange"></se-select><label>{{ catalogInfo.name | seL10n | async }}</label></div><div class="se-item-selector-panel__selector"><label class="se-control-label" translate="se.cms.catalogaware.panel.catalogsversion.label"></label><se-select id="se-catalog-version-selector-dropdown" [(model)]="catalogInfo.catalogVersion" [fetchStrategy]="catalogVersionSelectorFetchStrategy" [onChange]="onCatalogVersionSelectorChange" [searchEnabled]="false" [(reset)]="resetCatalogVersionSelector"></se-select></div><div class="se-item-selector-panel__selector" *ngIf="catalogInfo.catalogVersion"><label class="se-control-label" [translate]="catalogItemTypeI18nKey"></label><se-select id="se-items-selector-dropdown" [multiSelect]="true" [controls]="true" [(model)]="internalItemsSelected" [onChange]="onItemsSelectorChange" [fetchStrategy]="itemsSelectorFetchStrategy" [(reset)]="resetItemsListSelector" [itemComponent]="itemComponent" [isReadOnly]="!isItemSelectorEnabled()"></se-select></div></div></se-slider-panel>`,
        styles: [`.se-item-selector-panel__selector{margin-bottom:25px}`]
    }),
    __metadata("design:paramtypes", [])
], /* @ngInject */ ItemSelectorPanelComponent);

window.__smartedit__.addDecoratorPayload("Component", "CatalogAwareSelectorComponent", {
    selector: 'se-catalog-aware-selector',
    host: {
        '[class.se-catalog-aware-selector]': 'true'
    },
    template: `<div *ngIf="selectedItemListIsEmpty()"><button type="button" id="catalog-aware-selector-add-item" class="fd-button fd-button--compact se-catalog-aware-selector__add-item-btn" *ngIf="editable" (click)="openItemSelectorPanel()"><span translate="se.cms.catalogaware.newbutton.title" [translateParams]="{ catalogItemType: catalogItemTypeI18nKey | translate }" class="se-catalog-aware-selector__add-item-btn-text"></span></button></div><div *ngIf="!selectedItemListIsEmpty()" class="se-catalog-aware-selector__content"><div class="se-catalog-aware-selector__add-more-btn-wrapper" *ngIf="editable"><button type="button" class="fd-button--light" translate="se.cms.catalogaware.list.addmore" (click)="openItemSelectorPanel()"></button></div><se-editable-list [id]="editableListId" [itemComponent]="nodeComponent" [(items)]="itemList" [onChange]="onListChange" [editable]="editable" [(refresh)]="refreshItemListWidget" class="se-catalog-aware-selector__list"></se-editable-list></div><se-item-selector-panel [itemComponent]="itemComponent" [getCatalogs]="getCatalogs" [itemsFetchStrategy]="itemsFetchStrategy" [catalogItemTypeI18nKey]="catalogItemTypeI18nKey" (onSaveChanges)="onItemSelectorPanelSaveChanges($event)"></se-item-selector-panel>`,
    styles: [`.se-catalog-aware-selector__add-item-btn{display:flex;flex-direction:row;align-items:center;color:#0a6ed1}.se-catalog-aware-selector__add-more-btn-wrapper{display:flex;justify-content:flex-end;align-items:center}.se-catalog-aware-selector__list .se-tree-node{color:var(--sapList_TextColor);background-color:#fff}.se-catalog-aware-selector__list .se-tree__nodes--item .se-tree-node,.se-catalog-aware-selector__list .se-tree__nodes--item .se-tree-node__ol{display:flex;flex-direction:column;align-items:center}.se-catalog-aware-selector__list .se-tree__nodes--item .se-tree-node .se-tree-node__li,.se-catalog-aware-selector__list .se-tree__nodes--item .se-tree-node__ol .se-tree-node__li{width:100%}`],
    encapsulation: core.ViewEncapsulation.None,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ CatalogAwareSelectorComponent = class /* @ngInject */ CatalogAwareSelectorComponent {
    constructor(logService, cdr) {
        this.logService = logService;
        this.cdr = cdr;
        this.selectedItemIds = [];
        this.selectedItemIdsChange = new core.EventEmitter();
        this.itemList = [];
        this.onListChange = () => this.selectItemsFromItemList();
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.editable === undefined) {
                this.editable = true;
            }
            this.editableListId = `${this.id}_list`;
            if (this.selectedItemIds.length > 0) {
                return this.syncFromSelectedItemsToItemsList(this.selectedItemIds);
            }
        });
    }
    selectedItemListIsEmpty() {
        return this.selectedItemIds.length === 0;
    }
    openItemSelectorPanel() {
        this.itemSelectorPanel.initAndShowPanel([...this.selectedItemIds]);
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
    }
    onItemSelectorPanelSaveChanges(selectedItemIds) {
        this.selectedItemIdsChange.emit(selectedItemIds);
        return this.syncFromSelectedItemsToItemsList(selectedItemIds);
    }
    selectItemsFromItemList() {
        const selectedItemIds = this.itemList.map((item) => item.id);
        this.selectedItemIdsChange.emit(selectedItemIds);
    }
    syncFromSelectedItemsToItemsList(selectedItemIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const [idsFoundInList, idsMissingInList] = this.selectItemIdsFromItemList(selectedItemIds, this.itemList);
            const itemsFoundInList = new Map();
            this.itemList
                .filter(({ id }) => idsFoundInList.includes(id))
                .forEach((item) => {
                itemsFoundInList.set(item.id, item);
            });
            if (idsMissingInList.length > 0) {
                const newItems = yield this.fetchItems(idsMissingInList);
                newItems.forEach((item) => {
                    itemsFoundInList.set(item.id, item);
                });
            }
            this.itemList.length = 0;
            selectedItemIds.forEach((id) => {
                const item = itemsFoundInList.get(id);
                if (!item) {
                    this.logService.warn(`[${this.constructor.name}] - Cannot find item with key `, id);
                    return;
                }
                this.itemList.push(item);
            });
            if (this.itemList.length > 0) {
                this.updatePosition();
            }
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    updatePosition() {
        if (!!this.refreshItemListWidget) {
            this.refreshItemListWidget();
        }
    }
    selectItemIdsFromItemList(selectedItemIds, itemList) {
        const idsFound = [];
        const idsMissing = [];
        const itemIds = new Set(itemList.map(({ id }) => id));
        selectedItemIds.forEach((id) => {
            if (itemIds.has(id)) {
                idsFound.push(id);
            }
            else {
                idsMissing.push(id);
            }
        });
        return [idsFound, idsMissing];
    }
    fetchItems(itemsToRetrieve) {
        return __awaiter(this, void 0, void 0, function* () {
            const fetchEntityPromises = itemsToRetrieve.map((id) => this.itemsFetchStrategy.fetchEntity(id));
            return Promise.all(fetchEntityPromises);
        });
    }
};
CatalogAwareSelectorComponent.$inject = ["logService", "cdr"];
__decorate([
    core.Input(),
    core.HostBinding('attr.id'),
    __metadata("design:type", String)
], /* @ngInject */ CatalogAwareSelectorComponent.prototype, "id", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Array)
], /* @ngInject */ CatalogAwareSelectorComponent.prototype, "selectedItemIds", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ CatalogAwareSelectorComponent.prototype, "getCatalogs", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ CatalogAwareSelectorComponent.prototype, "itemsFetchStrategy", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", core.Type)
], /* @ngInject */ CatalogAwareSelectorComponent.prototype, "itemComponent", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", core.Type)
], /* @ngInject */ CatalogAwareSelectorComponent.prototype, "nodeComponent", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ CatalogAwareSelectorComponent.prototype, "catalogItemTypeI18nKey", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], /* @ngInject */ CatalogAwareSelectorComponent.prototype, "editable", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ CatalogAwareSelectorComponent.prototype, "selectedItemIdsChange", void 0);
__decorate([
    core.ViewChild(ItemSelectorPanelComponent, { static: false }),
    __metadata("design:type", ItemSelectorPanelComponent)
], /* @ngInject */ CatalogAwareSelectorComponent.prototype, "itemSelectorPanel", void 0);
/* @ngInject */ CatalogAwareSelectorComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-catalog-aware-selector',
        host: {
            '[class.se-catalog-aware-selector]': 'true'
        },
        template: `<div *ngIf="selectedItemListIsEmpty()"><button type="button" id="catalog-aware-selector-add-item" class="fd-button fd-button--compact se-catalog-aware-selector__add-item-btn" *ngIf="editable" (click)="openItemSelectorPanel()"><span translate="se.cms.catalogaware.newbutton.title" [translateParams]="{ catalogItemType: catalogItemTypeI18nKey | translate }" class="se-catalog-aware-selector__add-item-btn-text"></span></button></div><div *ngIf="!selectedItemListIsEmpty()" class="se-catalog-aware-selector__content"><div class="se-catalog-aware-selector__add-more-btn-wrapper" *ngIf="editable"><button type="button" class="fd-button--light" translate="se.cms.catalogaware.list.addmore" (click)="openItemSelectorPanel()"></button></div><se-editable-list [id]="editableListId" [itemComponent]="nodeComponent" [(items)]="itemList" [onChange]="onListChange" [editable]="editable" [(refresh)]="refreshItemListWidget" class="se-catalog-aware-selector__list"></se-editable-list></div><se-item-selector-panel [itemComponent]="itemComponent" [getCatalogs]="getCatalogs" [itemsFetchStrategy]="itemsFetchStrategy" [catalogItemTypeI18nKey]="catalogItemTypeI18nKey" (onSaveChanges)="onItemSelectorPanelSaveChanges($event)"></se-item-selector-panel>`,
        styles: [`.se-catalog-aware-selector__add-item-btn{display:flex;flex-direction:row;align-items:center;color:#0a6ed1}.se-catalog-aware-selector__add-more-btn-wrapper{display:flex;justify-content:flex-end;align-items:center}.se-catalog-aware-selector__list .se-tree-node{color:var(--sapList_TextColor);background-color:#fff}.se-catalog-aware-selector__list .se-tree__nodes--item .se-tree-node,.se-catalog-aware-selector__list .se-tree__nodes--item .se-tree-node__ol{display:flex;flex-direction:column;align-items:center}.se-catalog-aware-selector__list .se-tree__nodes--item .se-tree-node .se-tree-node__li,.se-catalog-aware-selector__list .se-tree__nodes--item .se-tree-node__ol .se-tree-node__li{width:100%}`],
        encapsulation: core.ViewEncapsulation.None,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [smarteditcommons.LogService, core.ChangeDetectorRef])
], /* @ngInject */ CatalogAwareSelectorComponent);

window.__smartedit__.addDecoratorPayload("Component", "ProductNodeComponent", {
    selector: 'se-product-node',
    template: `<div class="se-product-row"><div class="se-product-node" [ngClass]="{
            'se-product-node--no-drag' : !parent.dragEnabled,
            'se-product-node--drag': parent.dragEnabled 
        }"><img class="se-product-row__img" [src]="node.thumbnail.url || '/cmssmartedit/images/product_thumbnail_default.png'" alt="product image"/><div class="se-product-row__product se-nowrap-ellipsis" [title]="node.name | seL10n  | async">{{ node.name | seL10n | async }}</div><div class="se-product-row__product se-nowrap-ellipsis" [title]="node.code">{{ node.code }}</div><div class="se-product-row__catalog se-nowrap-ellipsis" title="{{ node.catalogId }} - {{ node.catalogVersion }}">{{ node.catalogId }} - {{ node.catalogVersion }}</div><se-dropdown-menu *ngIf="parent.dragEnabled" [dropdownItems]="dropdownItems" [selectedItem]="node" class="pull-right se-tree-node__actions--more-menu"></se-dropdown-menu></div></div>`,
    styles: [`.se-product-node{display:grid;grid-template-columns:1fr 5fr 5fr 7fr;grid-column-gap:12px;width:100%;align-items:center;padding:0 8px}.se-product-node--no-drag{grid-template-columns:1fr 6fr 6fr 7fr;cursor:default}.se-product-node--drag{grid-template-columns:1fr 5fr 5fr 7fr .5fr}`, `.se-product-row__catalog,.se-product-row__product{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;text-align:left}.se-product-row__img{padding:2px;width:36px;height:36px;font-size:.35rem}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let ProductNodeComponent = class ProductNodeComponent {
    constructor(node, parent) {
        this.node = node;
        this.parent = parent;
        const { getDropdownItems } = this.parent.nodeActions;
        this.dropdownItems = getDropdownItems();
    }
};
ProductNodeComponent = __decorate([
    core.Component({
        selector: 'se-product-node',
        template: `<div class="se-product-row"><div class="se-product-node" [ngClass]="{
            'se-product-node--no-drag' : !parent.dragEnabled,
            'se-product-node--drag': parent.dragEnabled 
        }"><img class="se-product-row__img" [src]="node.thumbnail.url || '/cmssmartedit/images/product_thumbnail_default.png'" alt="product image"/><div class="se-product-row__product se-nowrap-ellipsis" [title]="node.name | seL10n  | async">{{ node.name | seL10n | async }}</div><div class="se-product-row__product se-nowrap-ellipsis" [title]="node.code">{{ node.code }}</div><div class="se-product-row__catalog se-nowrap-ellipsis" title="{{ node.catalogId }} - {{ node.catalogVersion }}">{{ node.catalogId }} - {{ node.catalogVersion }}</div><se-dropdown-menu *ngIf="parent.dragEnabled" [dropdownItems]="dropdownItems" [selectedItem]="node" class="pull-right se-tree-node__actions--more-menu"></se-dropdown-menu></div></div>`,
        styles: [`.se-product-node{display:grid;grid-template-columns:1fr 5fr 5fr 7fr;grid-column-gap:12px;width:100%;align-items:center;padding:0 8px}.se-product-node--no-drag{grid-template-columns:1fr 6fr 6fr 7fr;cursor:default}.se-product-node--drag{grid-template-columns:1fr 5fr 5fr 7fr .5fr}`, `.se-product-row__catalog,.se-product-row__product{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;text-align:left}.se-product-row__img{padding:2px;width:36px;height:36px;font-size:.35rem}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(0, core.Inject(smarteditcommons.TREE_NODE)),
    __param(1, core.Inject(core.forwardRef(() => smarteditcommons.TreeComponent))),
    __metadata("design:paramtypes", [Object, smarteditcommons.TreeComponent])
], ProductNodeComponent);

window.__smartedit__.addDecoratorPayload("Component", "ProductSelectorItemComponent", {
    selector: 'se-product-selector-item',
    template: `<div class="se-product-row"><div class="se-product-node"><img class="se-product-row__img" [src]="getThumbnailUrl(item.thumbnail?.url)" alt="product image"/><div class="se-product-row__product se-nowrap-ellipsis" [title]="item.name | seL10n | async">{{ item.name | seL10n | async }}</div><div class="se-product-row__product se-nowrap-ellipsis" [title]="item.code">{{ item.code }}</div><div class="se-product-row__catalog"><div class="se-nowrap-ellipsis" title="{{ item.catalogId }} - {{ item.catalogVersion }}">{{ item.catalogId }} - {{ item.catalogVersion }}</div></div></div></div>`,
    styles: [`.se-product-node{display:grid;grid-template-columns:1fr 5fr 5fr 7fr;grid-column-gap:12px;width:100%;align-items:center;padding:0 8px}.se-product-node--no-drag{grid-template-columns:1fr 6fr 6fr 7fr;cursor:default}.se-product-node--drag{grid-template-columns:1fr 5fr 5fr 7fr .5fr}`, `.se-product-row__catalog,.se-product-row__product{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;text-align:left}.se-product-row__img{padding:2px;width:36px;height:36px;font-size:.35rem}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let ProductSelectorItemComponent = class ProductSelectorItemComponent {
    constructor(data) {
        this.data = data;
        this.defaultThumbnail = `${cmscommons.IMAGES_URL}/product_thumbnail_default.png`;
        ({ item: this.item } = data);
    }
    getThumbnailUrl(url) {
        return url || this.defaultThumbnail;
    }
};
ProductSelectorItemComponent = __decorate([
    core.Component({
        selector: 'se-product-selector-item',
        template: `<div class="se-product-row"><div class="se-product-node"><img class="se-product-row__img" [src]="getThumbnailUrl(item.thumbnail?.url)" alt="product image"/><div class="se-product-row__product se-nowrap-ellipsis" [title]="item.name | seL10n | async">{{ item.name | seL10n | async }}</div><div class="se-product-row__product se-nowrap-ellipsis" [title]="item.code">{{ item.code }}</div><div class="se-product-row__catalog"><div class="se-nowrap-ellipsis" title="{{ item.catalogId }} - {{ item.catalogVersion }}">{{ item.catalogId }} - {{ item.catalogVersion }}</div></div></div></div>`,
        styles: [`.se-product-node{display:grid;grid-template-columns:1fr 5fr 5fr 7fr;grid-column-gap:12px;width:100%;align-items:center;padding:0 8px}.se-product-node--no-drag{grid-template-columns:1fr 6fr 6fr 7fr;cursor:default}.se-product-node--drag{grid-template-columns:1fr 5fr 5fr 7fr .5fr}`, `.se-product-row__catalog,.se-product-row__product{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;text-align:left}.se-product-row__img{padding:2px;width:36px;height:36px;font-size:.35rem}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(0, core.Inject(smarteditcommons.ITEM_COMPONENT_DATA_TOKEN)),
    __metadata("design:paramtypes", [Object])
], ProductSelectorItemComponent);

/**
 * Supplies Fetch Strategies for Product and Category Selectors.
 * These strategies are used to fetch items in a paged way or to fetch an individual item.
 * Ultimately, the strategies are utilized by Select Componnet.
 */
let /* @ngInject */ CatalogInformationService = class /* @ngInject */ CatalogInformationService {
    constructor(catalogService, sharedDataService, productCategoryService, productService) {
        this.catalogService = catalogService;
        this.sharedDataService = sharedDataService;
        this.productCategoryService = productCategoryService;
        this.productService = productService;
        this.init();
    }
    /**
     * Strategy necessary to display products in a paged way.
     * It contains a method to retrieve pages of products and another method to retrieve individual products.
     * Such strategy is necessary to work with products in SelectComponent.
     */
    get productsFetchStrategy() {
        return this._productsFetchStrategy;
    }
    /**
     * Strategy necessary to display categories in a paged way.
     * It contains a method to retrieve pages of categories and another method to retrieve individual categories.
     * Such strategy is necessary to work with categories in a SelectComponent.
     */
    get categoriesFetchStrategy() {
        return this._categoriesFetchStrategy;
    }
    makeGetProductCatalogsInformation() {
        return () => this.getProductCatalogsInformation();
    }
    /**
     *
     * Retrieves the information of the product catalogs available in the current site.
     *
     * @returns A promise that resolves to an array containing the information of all the product catalogs available in the current site.
     */
    getProductCatalogsInformation() {
        return __awaiter(this, void 0, void 0, function* () {
            const siteUid = yield this.getSiteUid();
            if (this.cachedSiteUid === siteUid && this.parsedCatalogs) {
                // Return the cached catalogs only if the site hasn't changed
                // otherwise it's necessary to reload them.
                return this.parsedCatalogs;
            }
            else {
                this.cachedSiteUid = siteUid;
                const catalogs = yield this.catalogService.getProductCatalogsForSite(siteUid);
                const productCatalogById = this.catalogsToProductCatalogById(catalogs);
                this.parsedCatalogs = lodash.values(productCatalogById);
                return this.parsedCatalogs;
            }
        });
    }
    init() {
        this._productsFetchStrategy = {
            fetchPage: (catalogInfo, mask, pageSize, currentPage) => __awaiter(this, void 0, void 0, function* () { return this.productsFetchPage(catalogInfo, mask, pageSize, currentPage); }),
            fetchEntity: (productUID) => __awaiter(this, void 0, void 0, function* () { return this.productsFetchEntity(productUID); })
        };
        this._categoriesFetchStrategy = {
            fetchPage: (catalogInfo, mask, pageSize, currentPage) => __awaiter(this, void 0, void 0, function* () { return this.categoriesFetchPage(catalogInfo, mask, pageSize, currentPage); }),
            fetchEntity: (categoryUID) => __awaiter(this, void 0, void 0, function* () { return this.categoriesFetchEntity(categoryUID); })
        };
    }
    productsFetchPage(catalogInfo, mask, pageSize, currentPage) {
        return __awaiter(this, void 0, void 0, function* () {
            const siteUid = yield this.getSiteUid();
            catalogInfo.siteUID = siteUid;
            const { products, pagination } = yield this.productService.findProducts(catalogInfo, {
                mask,
                pageSize,
                currentPage
            });
            const items = products.map((product) => (Object.assign(Object.assign({}, product), { id: product.uid })));
            return {
                pagination,
                results: items
            };
        });
    }
    productsFetchEntity(productUid) {
        return __awaiter(this, void 0, void 0, function* () {
            const siteUid = yield this.getSiteUid();
            const product = yield this.productService.getProductById(siteUid, productUid);
            return Object.assign(Object.assign({}, product), { id: product.uid });
        });
    }
    categoriesFetchPage(catalogInfo, mask, pageSize, currentPage) {
        return __awaiter(this, void 0, void 0, function* () {
            const siteUid = yield this.getSiteUid();
            catalogInfo.siteUID = siteUid;
            const { productCategories, pagination } = yield this.productCategoryService.getCategories({
                catalogId: catalogInfo.catalogId,
                catalogVersion: catalogInfo.catalogVersion,
                siteUID: catalogInfo.siteUID,
                mask,
                pageSize,
                currentPage
            });
            const items = productCategories.map((category) => (Object.assign(Object.assign({}, category), { id: category.uid })));
            return {
                pagination,
                results: items
            };
        });
    }
    categoriesFetchEntity(categoryUID) {
        return __awaiter(this, void 0, void 0, function* () {
            const siteUid = yield this.getSiteUid();
            const category = yield this.productCategoryService.getCategoryById(siteUid, categoryUID);
            category.id = category.uid;
            return category;
        });
    }
    getSiteUid() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.sharedDataService
                .get(smarteditcommons.EXPERIENCE_STORAGE_KEY)
                .then(({ siteDescriptor: { uid } }) => uid);
        });
    }
    catalogsToProductCatalogById(catalogs) {
        const productCatalogById = {};
        catalogs.forEach((catalog) => {
            productCatalogById[catalog.catalogId] = {
                id: catalog.catalogId,
                name: catalog.name,
                versions: catalog.versions.map(({ version }) => ({
                    id: version,
                    label: version
                }))
            };
        });
        return productCatalogById;
    }
};
CatalogInformationService.$inject = ["catalogService", "sharedDataService", "productCategoryService", "productService"];
/* @ngInject */ CatalogInformationService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.ICatalogService,
        smarteditcommons.ISharedDataService,
        exports.ProductCategoryService,
        smarteditcontainer.ProductService])
], /* @ngInject */ CatalogInformationService);

window.__smartedit__.addDecoratorPayload("Component", "MultiProductSelectorComponent", {
    selector: 'se-multi-product-selector',
    template: `<se-catalog-aware-selector [id]="id" [selectedItemIds]="selectedItemIds" (selectedItemIdsChange)="onSelectedItemIdsChange($event)" [getCatalogs]="getCatalogs" [itemComponent]="productSelectorItemComponent" [nodeComponent]="productNodeComponent" [itemsFetchStrategy]="itemsFetchStrategy" [catalogItemTypeI18nKey]="'se.cms.catalogaware.catalogitemtype.product'" [editable]="editable"></se-catalog-aware-selector>`,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let MultiProductSelectorComponent = class MultiProductSelectorComponent {
    constructor(catalogInformationService, data) {
        this.catalogInformationService = catalogInformationService;
        ({
            field: { qualifier: this.id },
            model: this.model,
            qualifier: this.qualifier,
            field: { editable: this.editable }
        } = data);
        this.productNodeComponent = ProductNodeComponent;
        this.productSelectorItemComponent = ProductSelectorItemComponent;
    }
    ngOnInit() {
        this.getCatalogs = this.catalogInformationService.makeGetProductCatalogsInformation();
        this.itemsFetchStrategy = this.catalogInformationService.productsFetchStrategy;
        if (this.editable === undefined) {
            this.editable = true;
        }
        this.selectedItemIds = [...(this.model[this.qualifier] || [])];
    }
    onSelectedItemIdsChange(ids) {
        this.selectedItemIds = [...ids];
        this.model[this.qualifier] = this.selectedItemIds;
    }
};
MultiProductSelectorComponent = __decorate([
    core.Component({
        selector: 'se-multi-product-selector',
        template: `<se-catalog-aware-selector [id]="id" [selectedItemIds]="selectedItemIds" (selectedItemIdsChange)="onSelectedItemIdsChange($event)" [getCatalogs]="getCatalogs" [itemComponent]="productSelectorItemComponent" [nodeComponent]="productNodeComponent" [itemsFetchStrategy]="itemsFetchStrategy" [catalogItemTypeI18nKey]="'se.cms.catalogaware.catalogitemtype.product'" [editable]="editable"></se-catalog-aware-selector>`,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(1, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [CatalogInformationService, Object])
], MultiProductSelectorComponent);

window.__smartedit__.addDecoratorPayload("Component", "CategoryNodeComponent", {
    selector: 'se-category-node',
    template: `<div class="se-product-row"><div class="se-category-node" [ngClass]="{
          'se-category-node--no-drag': !parent.dragEnabled,
          'se-category-node--drag': parent.dragEnabled
        }"><div class="se-product-row__product" [title]="node.name | seL10n | async">{{ node.name | seL10n | async }}</div><div class="se-product-row__product" [title]="node.code">{{ node.code }}</div><div class="se-product-row__catalog" title="{{ node.catalogId }} - {{ node.catalogVersion }}">{{ node.catalogId }} - {{ node.catalogVersion }}</div><div><se-dropdown-menu *ngIf="parent.dragEnabled" [dropdownItems]="dropdownItems" [selectedItem]="node" class="pull-right se-tree-node__actions--more-menu"></se-dropdown-menu></div></div></div>`,
    styles: [`.se-category-node{padding:0 16px;display:grid;grid-column-gap:12px;align-items:center}.se-category-node--no-drag{grid-template-columns:6fr 6fr 8fr}.se-category-node--drag{grid-template-columns:6fr 6fr 7fr 1fr}`, `.se-product-row__catalog,.se-product-row__product{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;text-align:left}.se-product-row__img{padding:2px;width:36px;height:36px;font-size:.35rem}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let CategoryNodeComponent = class CategoryNodeComponent {
    constructor(node, parent) {
        this.node = node;
        this.parent = parent;
        const { getDropdownItems } = this.parent.nodeActions;
        this.dropdownItems = getDropdownItems();
    }
};
CategoryNodeComponent = __decorate([
    core.Component({
        selector: 'se-category-node',
        template: `<div class="se-product-row"><div class="se-category-node" [ngClass]="{
          'se-category-node--no-drag': !parent.dragEnabled,
          'se-category-node--drag': parent.dragEnabled
        }"><div class="se-product-row__product" [title]="node.name | seL10n | async">{{ node.name | seL10n | async }}</div><div class="se-product-row__product" [title]="node.code">{{ node.code }}</div><div class="se-product-row__catalog" title="{{ node.catalogId }} - {{ node.catalogVersion }}">{{ node.catalogId }} - {{ node.catalogVersion }}</div><div><se-dropdown-menu *ngIf="parent.dragEnabled" [dropdownItems]="dropdownItems" [selectedItem]="node" class="pull-right se-tree-node__actions--more-menu"></se-dropdown-menu></div></div></div>`,
        styles: [`.se-category-node{padding:0 16px;display:grid;grid-column-gap:12px;align-items:center}.se-category-node--no-drag{grid-template-columns:6fr 6fr 8fr}.se-category-node--drag{grid-template-columns:6fr 6fr 7fr 1fr}`, `.se-product-row__catalog,.se-product-row__product{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;text-align:left}.se-product-row__img{padding:2px;width:36px;height:36px;font-size:.35rem}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(0, core.Inject(smarteditcommons.TREE_NODE)),
    __param(1, core.Inject(core.forwardRef(() => smarteditcommons.TreeComponent))),
    __metadata("design:paramtypes", [Object, smarteditcommons.TreeComponent])
], CategoryNodeComponent);

window.__smartedit__.addDecoratorPayload("Component", "CategorySelectorItemComponent", {
    selector: 'se-category-selector-item',
    template: `<div class="se-product-row"><div class="se-category-row-container--item"><div class="se-product-row__product" [title]="item.name | seL10n | async">{{ item.name | seL10n | async }}</div><div class="se-product-row__product" [title]="item.code">{{ item.code }}</div><div class="se-product-row__catalog" title="{{ item.catalogId }} - {{ item.catalogVersion }}">{{ item.catalogId }} - {{ item.catalogVersion }}</div></div></div>`,
    styles: [`.se-category-row-container--item{display:grid;grid-template-columns:6fr 6fr 8fr;grid-column-gap:12px;width:100%;padding:0 8px}`, `.se-product-row__catalog,.se-product-row__product{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;text-align:left}.se-product-row__img{padding:2px;width:36px;height:36px;font-size:.35rem}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let CategorySelectorItemComponent = class CategorySelectorItemComponent {
    constructor(data) {
        this.data = data;
        ({ item: this.item } = data);
    }
};
CategorySelectorItemComponent = __decorate([
    core.Component({
        selector: 'se-category-selector-item',
        template: `<div class="se-product-row"><div class="se-category-row-container--item"><div class="se-product-row__product" [title]="item.name | seL10n | async">{{ item.name | seL10n | async }}</div><div class="se-product-row__product" [title]="item.code">{{ item.code }}</div><div class="se-product-row__catalog" title="{{ item.catalogId }} - {{ item.catalogVersion }}">{{ item.catalogId }} - {{ item.catalogVersion }}</div></div></div>`,
        styles: [`.se-category-row-container--item{display:grid;grid-template-columns:6fr 6fr 8fr;grid-column-gap:12px;width:100%;padding:0 8px}`, `.se-product-row__catalog,.se-product-row__product{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;text-align:left}.se-product-row__img{padding:2px;width:36px;height:36px;font-size:.35rem}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(0, core.Inject(smarteditcommons.ITEM_COMPONENT_DATA_TOKEN)),
    __metadata("design:paramtypes", [Object])
], CategorySelectorItemComponent);

window.__smartedit__.addDecoratorPayload("Component", "MultiCategorySelectorComponent", {
    selector: 'se-multi-category-selector',
    template: `<se-catalog-aware-selector [id]="id" [selectedItemIds]="selectedItemIds" (selectedItemIdsChange)="onSelectedItemIdsChange($event)" [getCatalogs]="getCatalogs" [itemComponent]="categorySelectorItemComponent" [nodeComponent]="categoryNodeComponent" [itemsFetchStrategy]="itemsFetchStrategy" [catalogItemTypeI18nKey]="'se.cms.catalogaware.catalogitemtype.category'" [editable]="editable"></se-catalog-aware-selector>`,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let MultiCategorySelectorComponent = class MultiCategorySelectorComponent {
    constructor(catalogInformationService, data) {
        this.catalogInformationService = catalogInformationService;
        ({
            model: this.model,
            qualifier: this.qualifier,
            field: { qualifier: this.id, editable: this.editable }
        } = data);
        this.categoryNodeComponent = CategoryNodeComponent;
        this.categorySelectorItemComponent = CategorySelectorItemComponent;
    }
    ngOnInit() {
        this.getCatalogs = this.catalogInformationService.makeGetProductCatalogsInformation();
        this.itemsFetchStrategy = this.catalogInformationService.categoriesFetchStrategy;
        if (this.editable === undefined) {
            this.editable = true;
        }
        this.selectedItemIds = [...(this.model[this.qualifier] || [])];
    }
    onSelectedItemIdsChange(ids) {
        this.selectedItemIds = [...ids];
        this.model[this.qualifier] = this.selectedItemIds;
    }
};
MultiCategorySelectorComponent = __decorate([
    core.Component({
        selector: 'se-multi-category-selector',
        template: `<se-catalog-aware-selector [id]="id" [selectedItemIds]="selectedItemIds" (selectedItemIdsChange)="onSelectedItemIdsChange($event)" [getCatalogs]="getCatalogs" [itemComponent]="categorySelectorItemComponent" [nodeComponent]="categoryNodeComponent" [itemsFetchStrategy]="itemsFetchStrategy" [catalogItemTypeI18nKey]="'se.cms.catalogaware.catalogitemtype.category'" [editable]="editable"></se-catalog-aware-selector>`,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(1, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [CatalogInformationService, Object])
], MultiCategorySelectorComponent);

let CatalogModule = class CatalogModule {
};
CatalogModule = __decorate([
    core.NgModule({
        imports: [
            common.CommonModule,
            forms.FormsModule,
            smarteditcommons.DropdownMenuModule,
            smarteditcommons.SliderPanelModule,
            smarteditcommons.SelectModule,
            core$1.TranslateModule.forChild(),
            smarteditcommons.L10nPipeModule,
            smarteditcommons.EditableListModule
        ],
        providers: [CatalogInformationService],
        declarations: [
            ItemSelectorPanelComponent,
            ProductNodeComponent,
            CategoryNodeComponent,
            ProductSelectorItemComponent,
            CategorySelectorItemComponent,
            CatalogAwareSelectorComponent,
            MultiProductSelectorComponent,
            MultiCategorySelectorComponent
        ],
        entryComponents: [
            ProductNodeComponent,
            CategoryNodeComponent,
            ProductSelectorItemComponent,
            CategorySelectorItemComponent,
            MultiProductSelectorComponent,
            MultiCategorySelectorComponent
        ]
    })
], CatalogModule);

const PAGE_APPROVAL_SELECTOR_CLOSE_CALLBACK_ID = 'pageApprovalSelectorClose';
window.__smartedit__.addDecoratorPayload("Component", "PageApprovalSelectorComponent", {
    selector: 'se-page-approval-selector',
    template: `<fd-popover *ngIf="showDropdown" [triggers]="[]" [closeOnOutsideClick]="false" [isOpen]="isOpen" [placement]="'bottom-end'"><fd-popover-control><button (click)="onClickDropdown()" class="se-page-approval-selector__toggle-btn fd-button--light sap-icon--navigation-down-arrow"></button></fd-popover-control><fd-popover-body><div *ngIf="showApprovalInfo" class="se-page-approval-info">{{ approvalInfo }}</div><fd-menu *ngIf="!showApprovalInfo"><ul fd-menu-list class="se-dropdown-menu__list se-page-approval-selector-list"><se-dropdown-menu-item *ngFor="let dropdownItem of pageApprovalOptions$ | async" [dropdownItem]="dropdownItem"></se-dropdown-menu-item></ul></fd-menu></fd-popover-body></fd-popover>`,
    styles: [`.se-page-approval-selector__toggle-btn{color:#0a6ed1}.se-page-approval-selector__toggle-btn::before{font-size:1rem;line-height:1.4285714286;font-weight:400}.se-page-approval-selector__toggle-btn:active,.se-page-approval-selector__toggle-btn:focus{box-shadow:none}.se-page-approval-selector__toggle-btn:active,.se-page-approval-selector__toggle-btn:hover{outline:0;border-color:var(--sapButton_Hover_BorderColor);background-color:#fff}.se-page-approval-selector__icon--draft,.se-page-approval-selector__icon--ready-to-sync{width:12px;height:12px;border-radius:50%;margin-right:10px}.se-page-approval-selector__icon--draft{background-color:#6a6d70}.se-page-approval-selector__icon--ready-to-sync{background-color:#0a6ed1}.se-page-approval-selector-list{margin:0;min-width:190px;border:1px solid transparent;box-shadow:0 2px 8px 0 #d9d9d9;border-radius:4px}.se-page-approval-selector .se-dropdown-item{display:flex;align-items:center}.se-page-approval-selector .se-dropdown-item:hover{background-color:var(--sapBackgroundColor,#f7f7f7)}.se-page-approval-selector .fd-popover-container-custom{box-shadow:var(--sapContent_Shadow0)}.se-page-approval-selector .fd-menu{padding:0}.se-page-approval-info{width:320px;white-space:normal;padding:16px}`],
    host: {
        '[class.se-page-approval-selector]': 'true'
    },
    encapsulation: core.ViewEncapsulation.None,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ PageApprovalSelectorComponent = class /* @ngInject */ PageApprovalSelectorComponent {
    constructor(iframeClickDetectionService, pageService, waitDialogService, workflowService, crossFrameEventService, routingService, logService, cdr, userTrackingService) {
        this.iframeClickDetectionService = iframeClickDetectionService;
        this.pageService = pageService;
        this.waitDialogService = waitDialogService;
        this.workflowService = workflowService;
        this.crossFrameEventService = crossFrameEventService;
        this.routingService = routingService;
        this.logService = logService;
        this.cdr = cdr;
        this.userTrackingService = userTrackingService;
        this.isOpen = false;
        this.showApprovalInfo = false;
        this.showDropdown = true;
        this.pageApprovalOptionsSubject = new rxjs.BehaviorSubject({
            CHECK: {
                status: smarteditcommons.CmsApprovalStatus.CHECK,
                key: 'se.cms.page.approval.check',
                icon: 'se-page-approval-selector__icon--draft',
                component: smarteditcommons.DropdownMenuItemDefaultComponent,
                condition: () => true,
                callback: (_selectedItem, clickedItem) => this.selectApprovalStatus(clickedItem)
            },
            APPROVED: {
                status: smarteditcommons.CmsApprovalStatus.APPROVED,
                key: 'se.cms.page.approval.approved',
                icon: 'se-page-approval-selector__icon--ready-to-sync',
                component: smarteditcommons.DropdownMenuItemDefaultComponent,
                condition: () => true,
                callback: (_selectedItem, clickedItem) => this.selectApprovalStatus(clickedItem)
            }
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.unRegWfFinishedHandler = this.crossFrameEventService.subscribe(cmscommons.WORKFLOW_FINISHED_EVENT, () => this.hideComponentIfWorkflowInProgress());
            this.unRegPerspectiveChangedHandler = this.crossFrameEventService.subscribe(smarteditcommons.EVENT_PERSPECTIVE_CHANGED, () => this.hideComponentIfWorkflowInProgress());
            this.iframeClickDetectionService.registerCallback(PAGE_APPROVAL_SELECTOR_CLOSE_CALLBACK_ID, () => this.closeDropdown());
            this.pageApprovalOptions$ = this.pageApprovalOptionsSubject.pipe(operators.map((options) => Object.values(options).filter((option) => !option.selected)));
            yield this.hideComponentIfWorkflowInProgress();
        });
    }
    ngOnDestroy() {
        this.unRegWfFinishedHandler();
        this.unRegPerspectiveChangedHandler();
        this.iframeClickDetectionService.removeCallback(PAGE_APPROVAL_SELECTOR_CLOSE_CALLBACK_ID);
    }
    onClickDropdown() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isOpen) {
                const approvalStatus = yield this.getCurrentPageApprovalStatus();
                const pageHasUnavailableDependencies = yield this.workflowService.pageHasUnavailableDependencies();
                if (approvalStatus !== smarteditcommons.CmsApprovalStatus.APPROVED && pageHasUnavailableDependencies) {
                    this.approvalInfo = yield this.workflowService.fetchPageTranslatedApprovalInfo();
                    this.showApprovalInfo = true;
                }
                else {
                    this.showApprovalInfo = false;
                }
                this.selectOption(approvalStatus);
            }
            this.isOpen = !this.isOpen;
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    selectApprovalStatus({ status }) {
        return __awaiter(this, void 0, void 0, function* () {
            this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.TOOL_BAR, 'Ready To Sync');
            this.waitDialogService.showWaitModal(null);
            try {
                yield this.pageService.forcePageApprovalStatus(status);
                this.crossFrameEventService.publish(smarteditcommons.EVENTS.PAGE_UPDATED);
                this.routingService.reload();
            }
            catch (error) {
                this.logService.warn("[PageApprovalSelector] - Can't change page status.", error);
            }
            finally {
                this.waitDialogService.hideWaitModal();
                this.unselectOptions();
            }
        });
    }
    getCurrentPageApprovalStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            const { approvalStatus } = yield this.pageService.getCurrentPageInfo();
            return approvalStatus;
        });
    }
    hideComponentIfWorkflowInProgress() {
        return __awaiter(this, void 0, void 0, function* () {
            const { uuid } = yield this.pageService.getCurrentPageInfo();
            const workflow = yield this.workflowService.getActiveWorkflowForPageUuid(uuid);
            this.showDropdown = !workflow;
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    selectOption(option) {
        this.unselectOptions();
        const options = this.getOptions();
        if (options[option]) {
            options[option].selected = true;
        }
        this.pageApprovalOptionsSubject.next(options);
    }
    unselectOptions() {
        const options = this.getOptions();
        Object.keys(options).forEach((key) => {
            options[key].selected = false;
        });
        this.pageApprovalOptionsSubject.next(options);
    }
    getOptions() {
        return Object.assign({}, this.pageApprovalOptionsSubject.getValue());
    }
    closeDropdown() {
        this.isOpen = false;
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
    }
};
PageApprovalSelectorComponent.$inject = ["iframeClickDetectionService", "pageService", "waitDialogService", "workflowService", "crossFrameEventService", "routingService", "logService", "cdr", "userTrackingService"];
/* @ngInject */ PageApprovalSelectorComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-approval-selector',
        template: `<fd-popover *ngIf="showDropdown" [triggers]="[]" [closeOnOutsideClick]="false" [isOpen]="isOpen" [placement]="'bottom-end'"><fd-popover-control><button (click)="onClickDropdown()" class="se-page-approval-selector__toggle-btn fd-button--light sap-icon--navigation-down-arrow"></button></fd-popover-control><fd-popover-body><div *ngIf="showApprovalInfo" class="se-page-approval-info">{{ approvalInfo }}</div><fd-menu *ngIf="!showApprovalInfo"><ul fd-menu-list class="se-dropdown-menu__list se-page-approval-selector-list"><se-dropdown-menu-item *ngFor="let dropdownItem of pageApprovalOptions$ | async" [dropdownItem]="dropdownItem"></se-dropdown-menu-item></ul></fd-menu></fd-popover-body></fd-popover>`,
        styles: [`.se-page-approval-selector__toggle-btn{color:#0a6ed1}.se-page-approval-selector__toggle-btn::before{font-size:1rem;line-height:1.4285714286;font-weight:400}.se-page-approval-selector__toggle-btn:active,.se-page-approval-selector__toggle-btn:focus{box-shadow:none}.se-page-approval-selector__toggle-btn:active,.se-page-approval-selector__toggle-btn:hover{outline:0;border-color:var(--sapButton_Hover_BorderColor);background-color:#fff}.se-page-approval-selector__icon--draft,.se-page-approval-selector__icon--ready-to-sync{width:12px;height:12px;border-radius:50%;margin-right:10px}.se-page-approval-selector__icon--draft{background-color:#6a6d70}.se-page-approval-selector__icon--ready-to-sync{background-color:#0a6ed1}.se-page-approval-selector-list{margin:0;min-width:190px;border:1px solid transparent;box-shadow:0 2px 8px 0 #d9d9d9;border-radius:4px}.se-page-approval-selector .se-dropdown-item{display:flex;align-items:center}.se-page-approval-selector .se-dropdown-item:hover{background-color:var(--sapBackgroundColor,#f7f7f7)}.se-page-approval-selector .fd-popover-container-custom{box-shadow:var(--sapContent_Shadow0)}.se-page-approval-selector .fd-menu{padding:0}.se-page-approval-info{width:320px;white-space:normal;padding:16px}`],
        host: {
            '[class.se-page-approval-selector]': 'true'
        },
        encapsulation: core.ViewEncapsulation.None,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [smarteditcommons.IIframeClickDetectionService,
        smarteditcommons.IPageService,
        smarteditcommons.IWaitDialogService,
        smarteditcommons.WorkflowService,
        smarteditcommons.CrossFrameEventService,
        smarteditcommons.SmarteditRoutingService,
        smarteditcommons.LogService,
        core.ChangeDetectorRef,
        smarteditcommons.UserTrackingService])
], /* @ngInject */ PageApprovalSelectorComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageStatusComponent", {
    selector: 'se-page-status',
    template: `<div class="se-page-status"><div class="se-page-status__icon" [ngClass]="statusIconCssClass"></div><div class="se-page-status__label">{{ statusLabel | translate }}</div></div>`,
    styles: [`.se-page-status{display:flex;flex-direction:row;align-items:center}.se-page-status__label{white-space:nowrap}.se-page-status__icon{float:left;margin-left:10px;margin-right:10px}.se-page-status__icon--draft{width:12px;height:12px;border-radius:50%;background-color:#74777a}.se-page-status__icon--in_progress{width:12px;height:12px;border-radius:50%;background-color:#e9730c}.se-page-status__icon--ready_to_sync{width:12px;height:12px;border-radius:50%;background-color:#0a6ed1}.se-page-status__icon--synced{width:12px;height:12px;border-radius:50%;background-color:#0a7e3e}.se-page-status__icon--locked{color:#32363a}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let PageStatusComponent = class PageStatusComponent {
    constructor(workflowService, cdr) {
        this.workflowService = workflowService;
        this.cdr = cdr;
        this.LOCALIZATION_PREFIX = 'se.cms.page.displaystatus.';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            const uuidChange = changes.uuid;
            const displayStatusChange = changes.displayStatus;
            let detectChanges = false;
            if (uuidChange && uuidChange.currentValue) {
                this.isPageLocked = yield this.isPageLockedToCurrentUser(this.uuid);
                detectChanges = true;
            }
            if (displayStatusChange && displayStatusChange.currentValue) {
                const displayStatusLC = this.displayStatus.toLowerCase();
                this.statusLabel = `${this.LOCALIZATION_PREFIX}${displayStatusLC}`;
                this.statusIconCssClass = this.getStatusIconCssClass(this.isPageLocked, displayStatusLC);
            }
            if (detectChanges) {
                if (!this.cdr.destroyed) {
                    this.cdr.detectChanges();
                }
            }
        });
    }
    isPageLockedToCurrentUser(uuid) {
        return __awaiter(this, void 0, void 0, function* () {
            const workflow = yield this.workflowService.getActiveWorkflowForPageUuid(uuid);
            return workflow && !workflow.isAvailableForCurrentPrincipal;
        });
    }
    getStatusIconCssClass(isPageLocked, displayStatus) {
        return isPageLocked
            ? 'icon-locked se-page-status__icon--locked'
            : `se-page-status__icon--${displayStatus}`;
    }
};
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], PageStatusComponent.prototype, "uuid", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], PageStatusComponent.prototype, "displayStatus", void 0);
PageStatusComponent = __decorate([
    core.Component({
        selector: 'se-page-status',
        template: `<div class="se-page-status"><div class="se-page-status__icon" [ngClass]="statusIconCssClass"></div><div class="se-page-status__label">{{ statusLabel | translate }}</div></div>`,
        styles: [`.se-page-status{display:flex;flex-direction:row;align-items:center}.se-page-status__label{white-space:nowrap}.se-page-status__icon{float:left;margin-left:10px;margin-right:10px}.se-page-status__icon--draft{width:12px;height:12px;border-radius:50%;background-color:#74777a}.se-page-status__icon--in_progress{width:12px;height:12px;border-radius:50%;background-color:#e9730c}.se-page-status__icon--ready_to_sync{width:12px;height:12px;border-radius:50%;background-color:#0a6ed1}.se-page-status__icon--synced{width:12px;height:12px;border-radius:50%;background-color:#0a7e3e}.se-page-status__icon--locked{color:#32363a}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [smarteditcommons.WorkflowService, core.ChangeDetectorRef])
], PageStatusComponent);

/*
 * Copyright (c) 2022 SAP SE or an SAP affiliate company. All rights reserved.
 */
const CMS_EVENT_OPEN_PAGE_WORKFLOW_MENU = 'CMS_EVENT_OPEN_PAGE_WORKFLOW_MENU';
const WORKFLOW_TASKS_MENU_OPENED_EVENT = 'WORKFLOW_TASKS_MENU_OPENED_EVENT';
const WORKFLOW_DECISION_SELECTED_EVENT = 'WORKFLOW_DECISION_SELECTED_EVENT';
const CMS_EVENT_OPEN_WORKFLOW_INBOX_DROPDOWN = 'CMS_EVENT_OPEN_WORKFLOW_INBOX_DROPDOWN';
const WORKFLOW_ITEM_MENU_OPENED_EVENT = 'WORKFLOW_ITEM_MENU_OPENED_EVENT';
const WORKFLOW_REFRESH_EVENT = 'WORKFLOW_REFRESH_EVENT';

window.__smartedit__.addDecoratorPayload("Component", "PageDisplayStatusComponent", {
    selector: 'se-page-display-status',
    template: `<ng-container *ngIf="showLastSyncTime; else pageStatus"><se-tooltip [triggers]="['click']" [placement]="'left'" [isChevronVisible]="true"><ng-container se-tooltip-trigger *ngTemplateOutlet="pageStatus"></ng-container><div se-tooltip-body class="popover-tooltip"><ng-container *ngIf="hasBeenSynchedBefore(); else notPublished"><span [translate]="'se.cms.page.displaystatus.lastpublished.date'"></span> <span>&ngsp;{{ lastSynchedDate | date: 'M/d/yy h:mm a' }}</span></ng-container><ng-template #notPublished><span [translate]="'se.cms.page.displaystatus.not.published'"></span></ng-template></div></se-tooltip></ng-container><ng-template #pageStatus><se-page-status [uuid]="page?.uuid" [displayStatus]="page?.displayStatus"></se-page-status></ng-template>`,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ PageDisplayStatusComponent = class /* @ngInject */ PageDisplayStatusComponent {
    constructor(pageService, crossFrameEventService, systemEventService, cdr) {
        this.pageService = pageService;
        this.crossFrameEventService = crossFrameEventService;
        this.systemEventService = systemEventService;
        this.cdr = cdr;
        this.showLastSyncTime = true;
    }
    ngOnInit() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.unRegPageSyncEvent = this.crossFrameEventService.subscribe(cmscommons.DEFAULT_SYNCHRONIZATION_POLLING.FAST_FETCH, (_eventId, eventData) => this.updateLastSynchedDate(eventData));
            this.unRegPageUpdatedEvent = this.crossFrameEventService.subscribe(smarteditcommons.EVENTS.PAGE_UPDATED, (_eventId, eventData) => this.updatePageInfo((eventData === null || eventData === void 0 ? void 0 : eventData.uuid) || null));
            const pageUuid = ((_a = this.cmsPage) === null || _a === void 0 ? void 0 : _a.uuid) || null;
            yield this.initPageInfo(pageUuid);
        });
    }
    ngOnDestroy() {
        this.unRegPageSyncEvent();
        this.unRegPageUpdatedEvent();
    }
    hasBeenSynchedBefore() {
        return this.lastSynchedDate !== undefined;
    }
    initPageInfo(pageUuid) {
        return __awaiter(this, void 0, void 0, function* () {
            this.page = yield (pageUuid ? this.cmsPage : this.pageService.getCurrentPageInfo());
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    updateLastSynchedDate(syncStatus) {
        if (this.canUpdateLastSynchedDate(syncStatus.itemId)) {
            this.lastSynchedDate = syncStatus.lastSyncStatus;
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        }
    }
    updatePageInfo(updatedPageUuid) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.canUpdatePageInfo(updatedPageUuid)) {
                return;
            }
            const displayStatusPrevious = (_a = this.page) === null || _a === void 0 ? void 0 : _a.displayStatus;
            this.page = yield this.pageService.getCurrentPageInfo();
            if (!!displayStatusPrevious && this.page.displayStatus === 'DRAFT') {
                this.systemEventService.publish(WORKFLOW_REFRESH_EVENT);
            }
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    canUpdateLastSynchedDate(syncStatusItemId) {
        return this.page && this.page.uuid === syncStatusItemId;
    }
    canUpdatePageInfo(cmsPageUuidToUpdate) {
        return !cmsPageUuidToUpdate || (this.page && this.page.uuid === cmsPageUuidToUpdate);
    }
};
PageDisplayStatusComponent.$inject = ["pageService", "crossFrameEventService", "systemEventService", "cdr"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ PageDisplayStatusComponent.prototype, "cmsPage", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ PageDisplayStatusComponent.prototype, "showLastSyncTime", void 0);
/* @ngInject */ PageDisplayStatusComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-display-status',
        template: `<ng-container *ngIf="showLastSyncTime; else pageStatus"><se-tooltip [triggers]="['click']" [placement]="'left'" [isChevronVisible]="true"><ng-container se-tooltip-trigger *ngTemplateOutlet="pageStatus"></ng-container><div se-tooltip-body class="popover-tooltip"><ng-container *ngIf="hasBeenSynchedBefore(); else notPublished"><span [translate]="'se.cms.page.displaystatus.lastpublished.date'"></span> <span>&ngsp;{{ lastSynchedDate | date: 'M/d/yy h:mm a' }}</span></ng-container><ng-template #notPublished><span [translate]="'se.cms.page.displaystatus.not.published'"></span></ng-template></div></se-tooltip></ng-container><ng-template #pageStatus><se-page-status [uuid]="page?.uuid" [displayStatus]="page?.displayStatus"></se-page-status></ng-template>`,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [smarteditcommons.IPageService,
        smarteditcommons.CrossFrameEventService,
        smarteditcommons.SystemEventService,
        core.ChangeDetectorRef])
], /* @ngInject */ PageDisplayStatusComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageDisplayStatusWrapperComponent", {
    selector: 'se-page-display-status-wrapper',
    template: `
        <div class="se-page-status-toolbar-container">
            <se-page-display-status></se-page-display-status>
        </div>
    `,
    styles: [
        `
            .se-page-status-toolbar-container {
                padding-left: 5px;
                padding-right: 20px;
                height: 100%;
                display: flex;
                align-items: center;
                border-left: 1px solid fd-color('neutral', 3);
            }
        `
    ],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ PageDisplayStatusWrapperComponent = class /* @ngInject */ PageDisplayStatusWrapperComponent {
};
/* @ngInject */ PageDisplayStatusWrapperComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-display-status-wrapper',
        template: `
        <div class="se-page-status-toolbar-container">
            <se-page-display-status></se-page-display-status>
        </div>
    `,
        styles: [
            `
            .se-page-status-toolbar-container {
                padding-left: 5px;
                padding-right: 20px;
                height: 100%;
                display: flex;
                align-items: center;
                border-left: 1px solid fd-color('neutral', 3);
            }
        `
        ],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    })
], /* @ngInject */ PageDisplayStatusWrapperComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageInWorkflowNotificationComponent", {
    selector: 'se-page-in-workflow-notification',
    template: `<div><span translate="se.cms.workflow.page.in.workflow"></span></div>`
});
let PageInWorkflowNotificationComponent = class PageInWorkflowNotificationComponent {
};
PageInWorkflowNotificationComponent = __decorate([
    smarteditcommons.SeCustomComponent(),
    core.Component({
        selector: 'se-page-in-workflow-notification',
        template: `<div><span translate="se.cms.workflow.page.in.workflow"></span></div>`
    })
], PageInWorkflowNotificationComponent);

/**
 * Used to manage workflows.
 */
let /* @ngInject */ WorkflowFacade = class /* @ngInject */ WorkflowFacade {
    constructor(alertService, workflowService, confirmationModalService, genericEditorModalService, pageInfoService, systemEventService, l10nPipe) {
        this.alertService = alertService;
        this.workflowService = workflowService;
        this.confirmationModalService = confirmationModalService;
        this.genericEditorModalService = genericEditorModalService;
        this.pageInfoService = pageInfoService;
        this.systemEventService = systemEventService;
        this.l10nPipe = l10nPipe;
        this.VERSION_LABEL_QUALIFIER = 'versionLabel';
        this.CREATE_VERSION_QUALIFIER = 'createVersion';
        this.SYNC_POLLING_SPEED_PREFIX = 'workflow-';
        this.startWorkflowStructureAttributes = [
            {
                cmsStructureType: 'EditableDropdown',
                qualifier: 'templateCode',
                i18nKey: 'se.cms.workflow.editor.template',
                localized: false,
                required: true,
                idAttribute: 'code',
                labelAttributes: ['name']
            },
            {
                cmsStructureType: 'LongString',
                qualifier: 'description',
                i18nKey: 'se.cms.workflow.editor.description',
                required: false
            },
            {
                cmsStructureType: 'WorkflowCreateVersionField',
                qualifier: this.CREATE_VERSION_QUALIFIER,
                required: false
            }
        ];
        this.editWorkflowStructureAttributes = [
            {
                cmsStructureType: 'LongString',
                qualifier: 'description',
                i18nKey: 'se.cms.workflow.editor.description',
                required: false
            }
        ];
        this.makeDecisionStructureAttributes = [
            {
                cmsStructureType: 'LongString',
                qualifier: 'comment',
                i18nKey: 'se.cms.workflow.editor.comment',
                required: false
            },
            {
                cmsStructureType: 'WorkflowCreateVersionField',
                qualifier: this.CREATE_VERSION_QUALIFIER,
                required: false
            }
        ];
    }
    /**
     * Opens the generic editor form that is used to start a workflow.
     *
     * @returns A promise that resolves to a workflow instance.
     */
    startWorkflow() {
        return __awaiter(this, void 0, void 0, function* () {
            const componentData = yield this.getWorkflowDataForEditor();
            const unregisterErrorListener = this.systemEventService.subscribe(smarteditcommons.GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT, (eventId, eventData) => this.handleUnrelatedValidationErrors(eventId, eventData));
            try {
                return yield this.genericEditorModalService.open(componentData, (result) => {
                    this.alertService.showSuccess('se.cms.workflow.create.alert.success');
                    this.systemEventService.publish(cmscommons.WORKFLOW_CREATED_EVENT);
                    this.updateWorkflowTasksCount();
                    return result;
                });
            }
            finally {
                unregisterErrorListener();
            }
        });
    }
    /**
     * Cancels the workflow. Shows the confirmation message before sending the request.
     */
    cancelWorflow(workflow) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.confirmationModalService.confirm({
                title: 'se.cms.workflow.cancel.confirmation.title',
                description: 'se.cms.workflow.cancel.confirmation.description'
            });
            try {
                yield this.workflowService.cancelWorflow(workflow);
                this.alertService.showSuccess('se.cms.workflow.cancel.alert.success');
            }
            finally {
                this.systemEventService.publish(cmscommons.WORKFLOW_FINISHED_EVENT);
                this.updateWorkflowTasksCount();
            }
        });
    }
    /**
     * Opens modal to edit workflow.
     *
     * Returns edited workflow.
     */
    editWorkflow(workflow) {
        return __awaiter(this, void 0, void 0, function* () {
            const componentData = yield this.getWorkflowDataForEditor(workflow);
            return this.genericEditorModalService.open(componentData, (result) => result);
        });
    }
    updateWorkflowTasksCount(count) {
        return __awaiter(this, void 0, void 0, function* () {
            const tasksCount = yield (typeof count === 'undefined'
                ? this.getTotalNumberOfTasks()
                : count);
            this.workflowService.updateWorkflowTasksCount(tasksCount);
        });
    }
    /**
     * Returns all actions for a given workflow code.
     */
    getAllActionsForWorkflow(workflowCode) {
        return this.workflowService.getAllActionsForWorkflowCode(workflowCode);
    }
    /**
     * Returns all active actions for a given workflow code and for the current user.
     */
    getActiveActionsForWorkflow(workflowCode) {
        return this.workflowService.getActiveActionsForWorkflowCode(workflowCode);
    }
    /**
     * Returns a paged list of comments for a given workflow and workflow action.
     *
     * Since the result is paginated and used by the InfiniteScrollingComponent, the list of comments is populated in the results property.
     */
    getCommentsForWorkflowAction(workflowCode, workflowActionCode, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const page = yield this.workflowService.getCommentsForWorkflowAction(workflowCode, workflowActionCode, payload);
            page.results = page.comments;
            delete page.comments;
            return page;
        });
    }
    /**
     * Returns a paged list of active workflow inbox tasks for a given user.
     */
    getWorkflowInboxTasks(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const page = yield this.workflowService.getWorkflowInboxTasks(payload);
            page.results = page.tasks;
            delete page.tasks;
            return page;
        });
    }
    getTotalNumberOfTasks() {
        return __awaiter(this, void 0, void 0, function* () {
            const page = yield this.getWorkflowInboxTasks({ pageSize: 1, currentPage: 0 });
            return page.pagination.totalCount;
        });
    }
    /**
     * Makes a decision for a given workflow action and workflow decision.
     */
    makeDecision(workflowCode, workflowAction, decision) {
        return __awaiter(this, void 0, void 0, function* () {
            const componentData = {
                title: yield this.l10nPipe.transform(decision.name).pipe(operators.take(1)).toPromise(),
                structure: {
                    attributes: this.makeDecisionStructureAttributes
                },
                contentApi: this.workflowService.getResourceWorkflowOperationsURI(),
                saveLabel: 'se.cms.workflow.editor.button.submit',
                content: {
                    operation: smarteditcommons.WorkflowOperations.MAKE_DECISION,
                    workflowCode,
                    actionCode: workflowAction.code,
                    decisionCode: decision.code
                },
                initialDirty: true
            };
            return this.genericEditorModalService.open(componentData, (result) => __awaiter(this, void 0, void 0, function* () {
                yield this.confirmDecision(result.status, workflowAction, decision);
                return result;
            }), null);
        });
    }
    confirmDecision(status, workflowAction, decision) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentPageUuid = yield this.pageInfoService.getPageUUID();
            yield this.systemEventService.publish(cmscommons.DEFAULT_SYNCHRONIZATION_POLLING.SPEED_UP, this.SYNC_POLLING_SPEED_PREFIX + currentPageUuid);
            if (status.toLowerCase() === smarteditcommons.WorkflowStatus.FINISHED) {
                this.alertService.showSuccess('se.cms.workflow.completed.alert.success');
                this.systemEventService.publishAsync(cmscommons.WORKFLOW_FINISHED_EVENT);
            }
            else {
                this.alertService.showSuccess({
                    message: 'se.cms.workflow.make.decision.success',
                    messagePlaceholders: {
                        workflowDecisionName: yield this.l10nPipe
                            .transform(decision.name)
                            .pipe(operators.take(1))
                            .toPromise(),
                        workflowActionName: yield this.l10nPipe
                            .transform(workflowAction.name)
                            .pipe(operators.take(1))
                            .toPromise()
                    }
                });
            }
            // resets back to slow polling
            this.systemEventService.publish(cmscommons.DEFAULT_SYNCHRONIZATION_POLLING.SLOW_DOWN, this.SYNC_POLLING_SPEED_PREFIX + currentPageUuid);
            const tasksCount = yield this.getTotalNumberOfTasks();
            this.updateWorkflowTasksCount(tasksCount);
        });
    }
    /**
     * Returns the data for GenericEditorModalComponent.
     *
     * @param workflow the data object to populate generic editor.
     * If workflow is null the generic editor displays fields to start a workflow,
     * Otherwise, the generic editor displays fields to edit a workflow.
     */
    getWorkflowDataForEditor(workflow = null) {
        return __awaiter(this, void 0, void 0, function* () {
            const isStartingWorkflow = workflow === null;
            const componentData = {
                title: null,
                contentApi: this.workflowService.getResourceWorkflowURI()
            };
            return isStartingWorkflow
                ? this.getComponentDataForStartingWorkflow(componentData)
                : this.getComponentDataForNonStartingWorkflow(componentData, workflow.workflowCode);
        });
    }
    getComponentDataForStartingWorkflow(componentData) {
        return __awaiter(this, void 0, void 0, function* () {
            const templateCodeField = this.startWorkflowStructureAttributes.find((structureAttribute) => structureAttribute.qualifier === 'templateCode');
            const workflowTemplates = yield this.workflowService.getWorkflowTemplates({});
            templateCodeField.options = workflowTemplates;
            componentData.title = 'se.cms.workflow.editor.start.workflow.title';
            componentData.saveLabel = 'se.cms.workflow.editor.button.start';
            componentData.structure = {
                attributes: this.startWorkflowStructureAttributes
            };
            const pageUuid = yield this.pageInfoService.getPageUUID();
            componentData.content = {
                attachments: [pageUuid]
            };
            return componentData;
        });
    }
    getComponentDataForNonStartingWorkflow(componentData, workflowCode) {
        componentData.title = 'se.cms.workflow.editor.edit.workflow.title';
        componentData.saveLabel = 'se.cms.workflow.editor.button.save';
        componentData.structure = {
            attributes: this.editWorkflowStructureAttributes
        };
        componentData.componentUuid = workflowCode;
        componentData.componentType = 'workflow';
        return componentData;
    }
    /**
     * Handles errors that the generic editor didn't handle directly (for example, due to unknown qualifiers) in two
     * ways:
     * 1. Even though there are different attributes for createVersion and versionLabel, in the front-end they are handled
     *    in the same widget, under the createVersion qualifier. However, when validating, the backend sends the error
     *    directly to versionLabel. Thus, any time there's an error directed to versionLabel it needs to be assigned to
     *    createVersion and republished for it to become visible.
     * 2. Any other error will be displayed in an alert.
     */
    handleUnrelatedValidationErrors(key, eventData) {
        if (!eventData.sourceGenericEditorId) {
            return;
        }
        let alertMessage = '';
        const errorsToRepublish = [];
        eventData.messages.forEach((error) => {
            if (error.subject === this.VERSION_LABEL_QUALIFIER) {
                error.subject = this.CREATE_VERSION_QUALIFIER;
                errorsToRepublish.push(error);
            }
            else {
                alertMessage += error.message + ' ';
            }
        });
        if (alertMessage) {
            this.alertService.showDanger(alertMessage);
        }
        if (errorsToRepublish.length > 0) {
            this.systemEventService.publishAsync(smarteditcommons.GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT, {
                messages: errorsToRepublish
            });
        }
    }
};
WorkflowFacade.$inject = ["alertService", "workflowService", "confirmationModalService", "genericEditorModalService", "pageInfoService", "systemEventService", "l10nPipe"];
/* @ngInject */ WorkflowFacade = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.IAlertService,
        smarteditcommons.WorkflowService,
        smarteditcommons.IConfirmationModalService,
        exports.GenericEditorModalService,
        smarteditcommons.IPageInfoService,
        smarteditcommons.SystemEventService,
        smarteditcommons.L10nPipe])
], /* @ngInject */ WorkflowFacade);

window.__smartedit__.addDecoratorPayload("Component", "PageWorkflowMenuAllTasksTabComponent", {
    selector: 'se-page-workflow-menu-all-tasks-tab',
    template: `
        <se-page-workflow-menu-tasks-tab
            [actions]="actions"
            [workflow]="workflow"
            [canMakeDecisions]="false"
        >
        </se-page-workflow-menu-tasks-tab>
    `
});
let PageWorkflowMenuAllTasksTabComponent = class PageWorkflowMenuAllTasksTabComponent {
    constructor(tabData) {
        ({ actions: this.actions, workflow: this.workflow } = tabData.model);
    }
};
PageWorkflowMenuAllTasksTabComponent = __decorate([
    core.Component({
        selector: 'se-page-workflow-menu-all-tasks-tab',
        template: `
        <se-page-workflow-menu-tasks-tab
            [actions]="actions"
            [workflow]="workflow"
            [canMakeDecisions]="false"
        >
        </se-page-workflow-menu-tasks-tab>
    `
    }),
    __param(0, core.Inject(smarteditcommons.TAB_DATA)),
    __metadata("design:paramtypes", [Object])
], PageWorkflowMenuAllTasksTabComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageWorkflowMenuCurrentTasksTabComponent", {
    selector: 'se-page-workflow-menu-current-tasks-tab',
    template: `
        <se-page-workflow-menu-tasks-tab
            [actions]="currentActions"
            [workflow]="workflow"
            [canMakeDecisions]="true"
        >
        </se-page-workflow-menu-tasks-tab>
    `
});
let PageWorkflowMenuCurrentTasksTabComponent = class PageWorkflowMenuCurrentTasksTabComponent {
    constructor(tabData) {
        ({ actions: this.actions, workflow: this.workflow } = tabData.model);
    }
    ngOnInit() {
        this.currentActions = this.actions.filter((action) => action.status.toLowerCase() === smarteditcommons.WorkflowActionStatus.IN_PROGRESS);
    }
};
PageWorkflowMenuCurrentTasksTabComponent = __decorate([
    core.Component({
        selector: 'se-page-workflow-menu-current-tasks-tab',
        template: `
        <se-page-workflow-menu-tasks-tab
            [actions]="currentActions"
            [workflow]="workflow"
            [canMakeDecisions]="true"
        >
        </se-page-workflow-menu-tasks-tab>
    `
    }),
    __param(0, core.Inject(smarteditcommons.TAB_DATA)),
    __metadata("design:paramtypes", [Object])
], PageWorkflowMenuCurrentTasksTabComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageWorkflowMenuComponent", {
    selector: 'se-page-workflow-menu',
    template: `<div *ngIf="isReady"><div *ngIf="!pageHasWorkflow && isWorkflowEnabled"><ng-container *seHasOperationPermission="'se.start.page.workflow'"><button id="smartEditPerspectiveToolbar_option_se.cms.startWorkflow_btn" class="btn toolbar-action--button" type="button" (click)="startWorkflow()" aria-expanded="false"><span id="smartEditPerspectiveToolbar_option_se.cms.startWorkflow_btn_lbl" class="toolbar-action-button__txt" translate="se.cms.workflow.toolbar.start.workflow"></span></button></ng-container></div><div *seHasOperationPermission="'se.view.page.workflowMenu'"><fd-popover *ngIf="pageHasWorkflow" class="toolbar-action" [closeOnOutsideClick]="true" [isOpen]="actionItem.isOpen" (isOpenChange)="onDropdownToggle($event)"><fd-popover-control><button type="button" class="page-tasks-btn toolbar-action--button" [attr.aria-expanded]="actionItem.isOpen"><span class="page-tasks-btn__icon sap-icon--workflow-tasks"></span> <span class="page-tasks-btn__label" translate="se.cms.workflow.toolbar.view.workflow.menu"></span></button></fd-popover-control><fd-popover-body><div *ngIf="actionItem.isOpen" class="toolbar-action--include se-page-workflow-menu"><div class="se-page-workflow-menu__header"><div class="se-page-workflow-menu__header-text" translate="se.cms.workflow.toolbar.view.workflow.menu"></div><div class="se-page-workflow-menu__header-menu"><se-workflow-item-menu [workflowInfo]="workflow"></se-workflow-item-menu></div></div><div class="se-version-toolbar-menu-content__body"><div class="se-page-workflow-menu-tabs"><se-tabs *ngIf="areTabsReady; else spinner" [tabsList]="tabsList" [model]="tabsData" [numTabsDisplayed]="2"></se-tabs><ng-template #spinner><se-spinner [isSpinning]="true"></se-spinner></ng-template></div></div></div></fd-popover-body></fd-popover></div></div>`,
    styles: [`/*!
 * Fundamental Library Styles v0.4.1
 * Copyright (c) 2020 SAP SE or an SAP affiliate company.
 * Licensed under Apache License 2.0 (https://github.com/SAP/fundamental-styles/blob/master/LICENSE)
 *//*!
.fd-button-split+()
    .fd-button
*/.fd-button-split{font-size:.875rem;font-size:var(--sapFontSize,.875rem);line-height:1.42857;color:#32363a;color:var(--sapTextColor,#32363a);font-family:"72","72full",Arial,Helvetica,sans-serif;font-family:var(--sapFontFamily, "72", "72full", Arial, Helvetica, sans-serif);font-weight:400;-webkit-font-smoothing:antialiased;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0;margin:0;border:0;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;vertical-align:middle;position:relative}.fd-button-split:after,.fd-button-split:before{-webkit-box-sizing:inherit;box-sizing:inherit;font-size:inherit}.fd-button-split :first-child{margin:0;border-top-right-radius:0;border-bottom-right-radius:0}.fd-button-split :nth-child(2){margin:0;border-top-left-radius:0;border-bottom-left-radius:0;border-left-width:0}.fd-button-split[dir=rtl] :first-child,[dir=rtl] .fd-button-split :first-child{border-top-left-radius:0;border-bottom-left-radius:0;border-top-right-radius:.25rem;border-top-right-radius:var(--sapButton_BorderCornerRadius,.25rem);border-bottom-right-radius:.25rem;border-bottom-right-radius:var(--sapButton_BorderCornerRadius,.25rem)}.fd-button-split[dir=rtl] :nth-child(2),[dir=rtl] .fd-button-split :nth-child(2){border-top-left-radius:.25rem;border-top-left-radius:var(--sapButton_BorderCornerRadius,.25rem);border-bottom-left-radius:.25rem;border-bottom-left-radius:var(--sapButton_BorderCornerRadius,.25rem);border-top-right-radius:0;border-bottom-right-radius:0;border-left-width:.0625rem;border-left-width:var(--sapButton_BorderWidth,.0625rem);border-right-width:0}.fd-button-split [class*="--emphasized"]:first-child{margin-right:1px}.fd-button-split [class*="--emphasized"][dir=rtl]:first-child,[dir=rtl] .fd-button-split [class*="--emphasized"]:first-child{margin-right:0;margin-left:1px}se-page-workflow-menu .toolbar-action .page-tasks-btn[aria-expanded=true]{background-color:rgba(10,110,209,.07)}se-page-workflow-menu .toolbar-action .page-tasks-btn__label{font-size:14px;color:#32363a}se-page-workflow-menu .toolbar-action .page-tasks-btn__icon{color:#0a6ed1;font-size:18px;margin-right:8px}se-page-workflow-menu .se-page-workflow-menu{box-shadow:0 6px 12px rgba(0,0,0,.175);background-color:#fff;border-radius:4px!important;min-width:100px;width:fit-content;position:absolute;border:1px solid #d9d9d9;z-index:2000;top:96%;min-width:350px;min-height:130px;right:-126px;left:auto;font-size:14px;font-family:'72',-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;line-height:20/14}se-page-workflow-menu .se-page-workflow-menu::before{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#d9d9d9;border-bottom-color:var(var(--fd-color-neutral-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-8px}se-page-workflow-menu .se-page-workflow-menu::after{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#fff;border-bottom-color:var(var(--fd-color-background-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-7px}se-page-workflow-menu .se-page-workflow-menu,se-page-workflow-menu .se-page-workflow-menu::after,se-page-workflow-menu .se-page-workflow-menu::before{left:50%;transform:translate(-50%)}se-page-workflow-menu .se-page-workflow-menu__header{display:flex;justify-content:space-between}se-page-workflow-menu .se-page-workflow-menu__header-text{font-size:16px;padding:20px 0 0 16px}se-page-workflow-menu .se-page-workflow-menu__header-menu{padding:16px 16px 0 0}se-page-workflow-menu .se-page-workflow-menu-tabs .se-tabset{margin:0}se-page-workflow-menu .se-page-workflow-menu-tabs .se-tabset__tab{margin-left:16px}se-page-workflow-menu .se-page-workflow-menu-tabs .se-tabset__link{color:#32363a}se-page-workflow-menu .se-page-workflow-menu-tabs .se-tabset__link:hover{color:#0a6ed1}`],
    encapsulation: core.ViewEncapsulation.None,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ PageWorkflowMenuComponent = class /* @ngInject */ PageWorkflowMenuComponent {
    constructor(workflowService, workflowFacade, systemEventService, routingService, pageService, cdr, actionItem) {
        this.workflowService = workflowService;
        this.workflowFacade = workflowFacade;
        this.systemEventService = systemEventService;
        this.routingService = routingService;
        this.pageService = pageService;
        this.cdr = cdr;
        this.actionItem = actionItem;
        this.isReady = false;
        this.isWorkflowEnabled = false;
        this.areTabsReady = false;
        this.pageHasWorkflow = false;
        this.tabsList = [
            {
                id: 'currentTasksTab',
                title: 'se.cms.page.workflow.tabs.currenttasks',
                hasErrors: false,
                component: PageWorkflowMenuCurrentTasksTabComponent
            },
            {
                id: 'allTasksTab',
                title: 'se.cms.page.workflow.tabs.alltasks',
                hasErrors: false,
                component: PageWorkflowMenuAllTasksTabComponent
            }
        ];
        this.tabsData = {
            workflow: null,
            actions: []
        };
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.unRegOpenMenuEvent = this.systemEventService.subscribe(CMS_EVENT_OPEN_PAGE_WORKFLOW_MENU, (_eventId, open) => this.onDropdownToggle(open));
            this.unRegPerspectiveChangedEvent = this.systemEventService.subscribe(smarteditcommons.EVENT_PERSPECTIVE_CHANGED, () => this.loadWorkflow());
            this.unRegWorkflowFinishedEvent = this.systemEventService.subscribe(cmscommons.WORKFLOW_FINISHED_EVENT, () => this.loadWorkflow());
            this.unRegDecisionSelectedEvent = this.systemEventService.subscribe(WORKFLOW_DECISION_SELECTED_EVENT, () => this.closeDropdown());
            this.unRegWorkflowRefreshEvent = this.systemEventService.subscribe(WORKFLOW_REFRESH_EVENT, () => this.loadWorkflow());
            yield this.loadWorkflow();
            this.isReady = true;
            this.actionItem.isOpen = false;
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    ngOnDestroy() {
        this.unRegOpenMenuEvent();
        this.unRegPerspectiveChangedEvent();
        this.unRegWorkflowFinishedEvent();
        this.unRegDecisionSelectedEvent();
        this.unRegWorkflowRefreshEvent();
    }
    set workflow(value) {
        this._workflow = value;
        this.tabsData.workflow = value;
    }
    get workflow() {
        return this._workflow;
    }
    onDropdownToggle(open) {
        return __awaiter(this, void 0, void 0, function* () {
            this.actionItem.isOpen = open;
            if (!open) {
                return;
            }
            this.systemEventService.publish(WORKFLOW_TASKS_MENU_OPENED_EVENT);
            yield this.loadWorkflowAndActions();
        });
    }
    startWorkflow() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.workflowFacade.startWorkflow();
            this.routingService.reload();
        });
    }
    loadWorkflowAndActions() {
        return __awaiter(this, void 0, void 0, function* () {
            this.areTabsReady = false;
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
            yield this.loadWorkflow(false);
            yield this.loadActions();
            this.areTabsReady = true;
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    loadWorkflow(detectChanges = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const page = yield this.pageService.getCurrentPageInfo();
            const workflow = yield this.workflowService.getActiveWorkflowForPageUuid(page.uuid);
            this.workflow = workflow;
            this.pageHasWorkflow = !!workflow;
            this.isWorkflowEnabled = page.displayStatus === 'DRAFT';
            if (detectChanges) {
                if (!this.cdr.destroyed) {
                    this.cdr.detectChanges();
                }
            }
        });
    }
    loadActions() {
        return __awaiter(this, void 0, void 0, function* () {
            const actions = yield this.workflowFacade.getAllActionsForWorkflow(this.workflow.workflowCode);
            this.setActions(actions);
        });
    }
    setActions(actions) {
        actions.sort((a, b) => this.actionComparator(a, b));
        this.tabsData.actions = actions;
    }
    closeDropdown() {
        this.actionItem.isOpen = false;
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
    }
    actionComparator(a, b) {
        const priorityA = this.getActionPriority(a);
        const priorityB = this.getActionPriority(b);
        return priorityA !== priorityB
            ? priorityA - priorityB
            : a.startedAgoInMillis - b.startedAgoInMillis;
    }
    getActionPriority(action) {
        switch (action.status.toLowerCase()) {
            case smarteditcommons.WorkflowActionStatus.IN_PROGRESS:
                return 1;
            case smarteditcommons.WorkflowActionStatus.PENDING:
                return 2;
            case smarteditcommons.WorkflowActionStatus.COMPLETED:
                return 3;
            default:
                return 4;
        }
    }
};
PageWorkflowMenuComponent.$inject = ["workflowService", "workflowFacade", "systemEventService", "routingService", "pageService", "cdr", "actionItem"];
/* @ngInject */ PageWorkflowMenuComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-workflow-menu',
        template: `<div *ngIf="isReady"><div *ngIf="!pageHasWorkflow && isWorkflowEnabled"><ng-container *seHasOperationPermission="'se.start.page.workflow'"><button id="smartEditPerspectiveToolbar_option_se.cms.startWorkflow_btn" class="btn toolbar-action--button" type="button" (click)="startWorkflow()" aria-expanded="false"><span id="smartEditPerspectiveToolbar_option_se.cms.startWorkflow_btn_lbl" class="toolbar-action-button__txt" translate="se.cms.workflow.toolbar.start.workflow"></span></button></ng-container></div><div *seHasOperationPermission="'se.view.page.workflowMenu'"><fd-popover *ngIf="pageHasWorkflow" class="toolbar-action" [closeOnOutsideClick]="true" [isOpen]="actionItem.isOpen" (isOpenChange)="onDropdownToggle($event)"><fd-popover-control><button type="button" class="page-tasks-btn toolbar-action--button" [attr.aria-expanded]="actionItem.isOpen"><span class="page-tasks-btn__icon sap-icon--workflow-tasks"></span> <span class="page-tasks-btn__label" translate="se.cms.workflow.toolbar.view.workflow.menu"></span></button></fd-popover-control><fd-popover-body><div *ngIf="actionItem.isOpen" class="toolbar-action--include se-page-workflow-menu"><div class="se-page-workflow-menu__header"><div class="se-page-workflow-menu__header-text" translate="se.cms.workflow.toolbar.view.workflow.menu"></div><div class="se-page-workflow-menu__header-menu"><se-workflow-item-menu [workflowInfo]="workflow"></se-workflow-item-menu></div></div><div class="se-version-toolbar-menu-content__body"><div class="se-page-workflow-menu-tabs"><se-tabs *ngIf="areTabsReady; else spinner" [tabsList]="tabsList" [model]="tabsData" [numTabsDisplayed]="2"></se-tabs><ng-template #spinner><se-spinner [isSpinning]="true"></se-spinner></ng-template></div></div></div></fd-popover-body></fd-popover></div></div>`,
        styles: [`/*!
 * Fundamental Library Styles v0.4.1
 * Copyright (c) 2020 SAP SE or an SAP affiliate company.
 * Licensed under Apache License 2.0 (https://github.com/SAP/fundamental-styles/blob/master/LICENSE)
 *//*!
.fd-button-split+()
    .fd-button
*/.fd-button-split{font-size:.875rem;font-size:var(--sapFontSize,.875rem);line-height:1.42857;color:#32363a;color:var(--sapTextColor,#32363a);font-family:"72","72full",Arial,Helvetica,sans-serif;font-family:var(--sapFontFamily, "72", "72full", Arial, Helvetica, sans-serif);font-weight:400;-webkit-font-smoothing:antialiased;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0;margin:0;border:0;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;vertical-align:middle;position:relative}.fd-button-split:after,.fd-button-split:before{-webkit-box-sizing:inherit;box-sizing:inherit;font-size:inherit}.fd-button-split :first-child{margin:0;border-top-right-radius:0;border-bottom-right-radius:0}.fd-button-split :nth-child(2){margin:0;border-top-left-radius:0;border-bottom-left-radius:0;border-left-width:0}.fd-button-split[dir=rtl] :first-child,[dir=rtl] .fd-button-split :first-child{border-top-left-radius:0;border-bottom-left-radius:0;border-top-right-radius:.25rem;border-top-right-radius:var(--sapButton_BorderCornerRadius,.25rem);border-bottom-right-radius:.25rem;border-bottom-right-radius:var(--sapButton_BorderCornerRadius,.25rem)}.fd-button-split[dir=rtl] :nth-child(2),[dir=rtl] .fd-button-split :nth-child(2){border-top-left-radius:.25rem;border-top-left-radius:var(--sapButton_BorderCornerRadius,.25rem);border-bottom-left-radius:.25rem;border-bottom-left-radius:var(--sapButton_BorderCornerRadius,.25rem);border-top-right-radius:0;border-bottom-right-radius:0;border-left-width:.0625rem;border-left-width:var(--sapButton_BorderWidth,.0625rem);border-right-width:0}.fd-button-split [class*="--emphasized"]:first-child{margin-right:1px}.fd-button-split [class*="--emphasized"][dir=rtl]:first-child,[dir=rtl] .fd-button-split [class*="--emphasized"]:first-child{margin-right:0;margin-left:1px}se-page-workflow-menu .toolbar-action .page-tasks-btn[aria-expanded=true]{background-color:rgba(10,110,209,.07)}se-page-workflow-menu .toolbar-action .page-tasks-btn__label{font-size:14px;color:#32363a}se-page-workflow-menu .toolbar-action .page-tasks-btn__icon{color:#0a6ed1;font-size:18px;margin-right:8px}se-page-workflow-menu .se-page-workflow-menu{box-shadow:0 6px 12px rgba(0,0,0,.175);background-color:#fff;border-radius:4px!important;min-width:100px;width:fit-content;position:absolute;border:1px solid #d9d9d9;z-index:2000;top:96%;min-width:350px;min-height:130px;right:-126px;left:auto;font-size:14px;font-family:'72',-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;line-height:20/14}se-page-workflow-menu .se-page-workflow-menu::before{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#d9d9d9;border-bottom-color:var(var(--fd-color-neutral-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-8px}se-page-workflow-menu .se-page-workflow-menu::after{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#fff;border-bottom-color:var(var(--fd-color-background-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-7px}se-page-workflow-menu .se-page-workflow-menu,se-page-workflow-menu .se-page-workflow-menu::after,se-page-workflow-menu .se-page-workflow-menu::before{left:50%;transform:translate(-50%)}se-page-workflow-menu .se-page-workflow-menu__header{display:flex;justify-content:space-between}se-page-workflow-menu .se-page-workflow-menu__header-text{font-size:16px;padding:20px 0 0 16px}se-page-workflow-menu .se-page-workflow-menu__header-menu{padding:16px 16px 0 0}se-page-workflow-menu .se-page-workflow-menu-tabs .se-tabset{margin:0}se-page-workflow-menu .se-page-workflow-menu-tabs .se-tabset__tab{margin-left:16px}se-page-workflow-menu .se-page-workflow-menu-tabs .se-tabset__link{color:#32363a}se-page-workflow-menu .se-page-workflow-menu-tabs .se-tabset__link:hover{color:#0a6ed1}`],
        encapsulation: core.ViewEncapsulation.None,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(6, core.Inject(smarteditcommons.TOOLBAR_ITEM)),
    __metadata("design:paramtypes", [smarteditcommons.WorkflowService,
        WorkflowFacade,
        smarteditcommons.SystemEventService,
        smarteditcommons.SmarteditRoutingService,
        smarteditcommons.IPageService,
        core.ChangeDetectorRef, Object])
], /* @ngInject */ PageWorkflowMenuComponent);

window.__smartedit__.addDecoratorPayload("Component", "WorkflowInboxMultipleTasksAnnouncementComponent", {
    selector: 'se-workflow-inbox-multiple-tasks-announcement',
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    template: `<div (click)="onClick($event)" class="se-announcement__message--multi">{{ 'se.cms.workflow.tasks.announcement' | translate: count }}</div>`
});
let WorkflowInboxMultipleTasksAnnouncementComponent = class WorkflowInboxMultipleTasksAnnouncementComponent {
    constructor(systemEventService, announcementService, data) {
        this.systemEventService = systemEventService;
        this.announcementService = announcementService;
        this.count = {
            announcementCount: null
        };
        ({ id: this.announcementId, tasks: this.tasks } = data);
    }
    ngOnInit() {
        this.count.announcementCount = String(this.tasks.length);
    }
    onClick($event) {
        $event.stopPropagation();
        this.systemEventService.publish(CMS_EVENT_OPEN_WORKFLOW_INBOX_DROPDOWN);
        this.announcementService.closeAnnouncement(this.announcementId);
    }
};
WorkflowInboxMultipleTasksAnnouncementComponent = __decorate([
    core.Component({
        selector: 'se-workflow-inbox-multiple-tasks-announcement',
        changeDetection: core.ChangeDetectionStrategy.OnPush,
        template: `<div (click)="onClick($event)" class="se-announcement__message--multi">{{ 'se.cms.workflow.tasks.announcement' | translate: count }}</div>`
    }),
    __param(2, core.Inject(smarteditcommons.ANNOUNCEMENT_DATA)),
    __metadata("design:paramtypes", [smarteditcommons.SystemEventService,
        smarteditcommons.IAnnouncementService, Object])
], WorkflowInboxMultipleTasksAnnouncementComponent);

window.__smartedit__.addDecoratorPayload("Component", "WorkflowInboxSingleTaskAnnouncementComponent", {
    selector: 'se-workflow-inbox-single-task-announcement',
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    template: `<div (click)="onClick($event)"><div class="se-announcement__title">{{ task.action.name | seL10n | async }}</div><div class="se-announcement__message">{{ task.attachments[0].catalogName | seL10n | async }} | {{ task.attachments[0].pageName }}</div><div class="se-announcement__time-stamp">{{ startedAgo }}</div></div>`
});
let WorkflowInboxSingleTaskAnnouncementComponent = class WorkflowInboxSingleTaskAnnouncementComponent {
    constructor(workflowService, cmsTimeService, announcementService, data) {
        this.workflowService = workflowService;
        this.cmsTimeService = cmsTimeService;
        this.announcementService = announcementService;
        ({ id: this.announcementId, task: this.task } = data);
    }
    ngOnInit() {
        this.startedAgo = this.getStartedAgo();
    }
    onClick(event) {
        event.stopPropagation();
        this.workflowService.loadExperienceAndOpenPageWorkflowMenu(this.task);
        this.announcementService.closeAnnouncement(this.announcementId);
    }
    getStartedAgo() {
        if (!!this.task.action.startedAgoInMillis) {
            return this.cmsTimeService.getTimeAgo(this.task.action.startedAgoInMillis);
        }
        return null;
    }
};
WorkflowInboxSingleTaskAnnouncementComponent = __decorate([
    core.Component({
        selector: 'se-workflow-inbox-single-task-announcement',
        changeDetection: core.ChangeDetectionStrategy.OnPush,
        template: `<div (click)="onClick($event)"><div class="se-announcement__title">{{ task.action.name | seL10n | async }}</div><div class="se-announcement__message">{{ task.attachments[0].catalogName | seL10n | async }} | {{ task.attachments[0].pageName }}</div><div class="se-announcement__time-stamp">{{ startedAgo }}</div></div>`
    }),
    __param(3, core.Inject(smarteditcommons.ANNOUNCEMENT_DATA)),
    __metadata("design:paramtypes", [smarteditcommons.WorkflowService,
        cmscommons.CMSTimeService,
        smarteditcommons.IAnnouncementService, Object])
], WorkflowInboxSingleTaskAnnouncementComponent);

/**
 * This service is used to show announcements for workflow inbox tasks.
 */
let /* @ngInject */ WorkflowInboxAnnouncementService = class /* @ngInject */ WorkflowInboxAnnouncementService {
    constructor(workflowTasksPollingService, announcementService) {
        this.workflowTasksPollingService = workflowTasksPollingService;
        this.announcementService = announcementService;
        this.unsubscribePollingService = this.workflowTasksPollingService.addSubscriber(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        (tasks, pagination) => {
            if (tasks) {
                this.displayAnnouncement(tasks);
            }
        }, false);
    }
    ngOnDestroy() {
        this.unsubscribePollingService();
    }
    displayAnnouncement(tasks) {
        if (tasks.length === 1) {
            this.showSingleTaskAnnouncement(tasks[0]);
        }
        else if (tasks.length > 1) {
            this.showMultipleTasksAnnouncement(tasks);
        }
    }
    showSingleTaskAnnouncement(task) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.showAnnouncement(WorkflowInboxSingleTaskAnnouncementComponent, {
                task
            });
        });
    }
    showMultipleTasksAnnouncement(tasks) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.showAnnouncement(WorkflowInboxMultipleTasksAnnouncementComponent, {
                tasks
            });
        });
    }
    showAnnouncement(component, data) {
        return this.announcementService.showAnnouncement({
            component,
            data
        });
    }
};
WorkflowInboxAnnouncementService.$inject = ["workflowTasksPollingService", "announcementService"];
/* @ngInject */ WorkflowInboxAnnouncementService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.WorkflowTasksPollingService,
        smarteditcommons.IAnnouncementService])
], /* @ngInject */ WorkflowInboxAnnouncementService);

window.__smartedit__.addDecoratorPayload("Component", "WorkflowInboxComponent", {
    selector: 'se-workflow-inbox',
    template: `<fd-popover class="toolbar-action se-workflow-inbox-container dropdown" [class.open]="actionItem.isOpen" [(isOpen)]="actionItem.isOpen" (isOpenChange)="onDropdownToggle(isOpen)" [closeOnOutsideClick]="true" [triggers]="['click']" [placement]="'bottom-' + actionItem.dropdownPosition"><fd-popover-control class="se-workflow-inbox-toggle-control"><button type="button" class="se-workflow-inbox-toggle toolbar-action--button--compact" [attr.aria-pressed]="actionItem.isOpen"><span class="se-toolbar-actions__icon sap-icon--task"></span><se-workflow-inbox-badge></se-workflow-inbox-badge></button></fd-popover-control><fd-popover-body><div [ngClass]="{
                'se-toolbar__dropdown--right': actionItem.dropdownPosition === 'right',
                'se-toolbar__dropdown--center': actionItem.dropdownPosition === 'center',
                'se-toolbar__dropdown--left': actionItem.dropdownPosition === 'left'
            }" class="toolbar-action--include--compact"><div *ngIf="actionItem.isOpen" class="se-workflow-inbox"><div class="se-workflow-inbox"><div class="se-workflow-inbox-header"><div class="se-workflow-inbox-header__title" [translate]="'se.cms.workflow.toolbar.inbox'"></div></div><div class="se-workflow-inbox-tasks se-cms-dev-workflow-inbox-tasks fd-panel__body"><div *ngIf="!tasksNotReady && totalNumberOfTasks === 0" class="se-workflow-inbox-tasks__no-tasks"><img src="static-resources/images/Inbox.svg" alt="empty-inbox"/> <span class="se-workflow-inbox__empty-inbox-message" [translate]="'se.cms.workflow.toolbar.inbox.emptyinbox.message'"></span> <span class="se-workflow-inbox__empty-inbox-message-alt" [translate]="'se.cms.workflow.toolbar.inbox.emptyinbox.message.alt'"></span></div><se-infinite-scrolling class="se-version-panel__infinite-scroll se-infinite-scrolling--narrowed" [pageSize]="pageSize" [fetchPage]="fetchPageOfInboxTasks" (itemsChange)="onInboxTasksLoaded($event)"><div *ngFor="let task of workflowTasks; let i = index; let last = last; trackBy: trackByIndex" class="se-workflow-inbox-task se-cms-dev-workflow-inbox-task"><se-workflow-inbox-task id="workflow-inbox-task-{{i}}" [class.se-workflow-inbox-task-last]="last" [task]="task"></se-workflow-inbox-task></div></se-infinite-scrolling></div></div></div></div></fd-popover-body></fd-popover>`,
    styles: [`.se-workflow-inbox-toggle{outline:0}.se-workflow-inbox-header{padding:20px;display:flex;flex-direction:row;align-items:center;justify-content:space-between;border-bottom:1px solid #d9d9d9;height:53px;padding-top:15px;height:48px;font-size:1.1428571429rem;line-height:1.25;font-weight:400;color:#32363a;border-bottom:1px solid #d9d9d9;padding:10px 0 15px 20px;height:46px}.se-workflow-inbox-header:first-child{font-size:1.1428571429rem;line-height:1.25;font-weight:400;color:#32363a}.se-workflow-inbox-tasks{padding:16px 0 8px;width:280px}.se-workflow-inbox-tasks__no-tasks{display:flex;flex-direction:column;align-items:center}.se-workflow-inbox__empty-inbox-message{color:#51555a;padding:8px 0 4px}.se-workflow-inbox__empty-inbox-message-alt{font-size:13px;color:#6a6d70;padding-bottom:30px}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ WorkflowInboxComponent = class /* @ngInject */ WorkflowInboxComponent {
    constructor(workflowFacade, systemEventService, workflowTasksPollingService, userTrackingService, actionItem, cdr) {
        this.workflowFacade = workflowFacade;
        this.systemEventService = systemEventService;
        this.workflowTasksPollingService = workflowTasksPollingService;
        this.userTrackingService = userTrackingService;
        this.actionItem = actionItem;
        this.cdr = cdr;
        this.pageSize = 10;
        this.workflowTasks = [];
        this.fetchPageOfInboxTasks = (search, pageSize, currentPage) => this.loadInboxTasks(search, pageSize, currentPage);
    }
    ngOnInit() {
        this.tasksNotReady = true;
        this.unRegisterOpenDropdownEvent = this.systemEventService.subscribe(CMS_EVENT_OPEN_WORKFLOW_INBOX_DROPDOWN, () => this.openDropdown());
        this.unRegisterWorkflowCreatedEvent = this.systemEventService.subscribe(cmscommons.WORKFLOW_CREATED_EVENT, () => this.loadInboxTasks('', this.pageSize, 0));
        this.unRegWorkflowTasksMenuOpenedEvent = this.systemEventService.subscribe(WORKFLOW_TASKS_MENU_OPENED_EVENT, () => this.hideDropdown());
        this.workflowTasksPollingService.startPolling();
    }
    ngOnDestroy() {
        this.workflowTasksPollingService.stopPolling();
        this.unRegisterOpenDropdownEvent();
        this.unRegisterWorkflowCreatedEvent();
        this.unRegWorkflowTasksMenuOpenedEvent();
    }
    loadInboxTasks(mask, pageSize, currentPage) {
        return __awaiter(this, void 0, void 0, function* () {
            const page = yield this.workflowFacade.getWorkflowInboxTasks({
                currentPage,
                mask,
                pageSize
            });
            this.tasksNotReady = false;
            this.totalNumberOfTasks = page.pagination.totalCount;
            this.workflowFacade.updateWorkflowTasksCount(this.totalNumberOfTasks);
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
            return page;
        });
    }
    onInboxTasksLoaded(workflowTasks) {
        this.workflowTasks = workflowTasks;
    }
    onDropdownToggle(isOpen) {
        if (isOpen) {
            this.workflowTasksPollingService.stopPolling();
            return;
        }
        this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.HEADER_TOOL, 'Inbox');
        this.workflowTasksPollingService.startPolling();
        this.tasksNotReady = true;
    }
    trackByIndex(index) {
        return index;
    }
    openDropdown() {
        this.actionItem.isOpen = true;
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
    }
    hideDropdown() {
        this.actionItem.isOpen = false;
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
    }
};
WorkflowInboxComponent.$inject = ["workflowFacade", "systemEventService", "workflowTasksPollingService", "userTrackingService", "actionItem", "cdr"];
/* @ngInject */ WorkflowInboxComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-workflow-inbox',
        template: `<fd-popover class="toolbar-action se-workflow-inbox-container dropdown" [class.open]="actionItem.isOpen" [(isOpen)]="actionItem.isOpen" (isOpenChange)="onDropdownToggle(isOpen)" [closeOnOutsideClick]="true" [triggers]="['click']" [placement]="'bottom-' + actionItem.dropdownPosition"><fd-popover-control class="se-workflow-inbox-toggle-control"><button type="button" class="se-workflow-inbox-toggle toolbar-action--button--compact" [attr.aria-pressed]="actionItem.isOpen"><span class="se-toolbar-actions__icon sap-icon--task"></span><se-workflow-inbox-badge></se-workflow-inbox-badge></button></fd-popover-control><fd-popover-body><div [ngClass]="{
                'se-toolbar__dropdown--right': actionItem.dropdownPosition === 'right',
                'se-toolbar__dropdown--center': actionItem.dropdownPosition === 'center',
                'se-toolbar__dropdown--left': actionItem.dropdownPosition === 'left'
            }" class="toolbar-action--include--compact"><div *ngIf="actionItem.isOpen" class="se-workflow-inbox"><div class="se-workflow-inbox"><div class="se-workflow-inbox-header"><div class="se-workflow-inbox-header__title" [translate]="'se.cms.workflow.toolbar.inbox'"></div></div><div class="se-workflow-inbox-tasks se-cms-dev-workflow-inbox-tasks fd-panel__body"><div *ngIf="!tasksNotReady && totalNumberOfTasks === 0" class="se-workflow-inbox-tasks__no-tasks"><img src="static-resources/images/Inbox.svg" alt="empty-inbox"/> <span class="se-workflow-inbox__empty-inbox-message" [translate]="'se.cms.workflow.toolbar.inbox.emptyinbox.message'"></span> <span class="se-workflow-inbox__empty-inbox-message-alt" [translate]="'se.cms.workflow.toolbar.inbox.emptyinbox.message.alt'"></span></div><se-infinite-scrolling class="se-version-panel__infinite-scroll se-infinite-scrolling--narrowed" [pageSize]="pageSize" [fetchPage]="fetchPageOfInboxTasks" (itemsChange)="onInboxTasksLoaded($event)"><div *ngFor="let task of workflowTasks; let i = index; let last = last; trackBy: trackByIndex" class="se-workflow-inbox-task se-cms-dev-workflow-inbox-task"><se-workflow-inbox-task id="workflow-inbox-task-{{i}}" [class.se-workflow-inbox-task-last]="last" [task]="task"></se-workflow-inbox-task></div></se-infinite-scrolling></div></div></div></div></fd-popover-body></fd-popover>`,
        styles: [`.se-workflow-inbox-toggle{outline:0}.se-workflow-inbox-header{padding:20px;display:flex;flex-direction:row;align-items:center;justify-content:space-between;border-bottom:1px solid #d9d9d9;height:53px;padding-top:15px;height:48px;font-size:1.1428571429rem;line-height:1.25;font-weight:400;color:#32363a;border-bottom:1px solid #d9d9d9;padding:10px 0 15px 20px;height:46px}.se-workflow-inbox-header:first-child{font-size:1.1428571429rem;line-height:1.25;font-weight:400;color:#32363a}.se-workflow-inbox-tasks{padding:16px 0 8px;width:280px}.se-workflow-inbox-tasks__no-tasks{display:flex;flex-direction:column;align-items:center}.se-workflow-inbox__empty-inbox-message{color:#51555a;padding:8px 0 4px}.se-workflow-inbox__empty-inbox-message-alt{font-size:13px;color:#6a6d70;padding-bottom:30px}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(4, core.Inject(smarteditcommons.TOOLBAR_ITEM)),
    __metadata("design:paramtypes", [WorkflowFacade,
        smarteditcommons.SystemEventService,
        smarteditcommons.WorkflowTasksPollingService,
        smarteditcommons.UserTrackingService, Object, core.ChangeDetectorRef])
], /* @ngInject */ WorkflowInboxComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageWorkflowMenuTasksTabComponent", {
    selector: 'se-page-workflow-menu-tasks-tab',
    template: `
        <div class="se-page-workflow-tasks-wrapper">
            <div *ngFor="let action of actions">
                <div class="se-page-workflow-task fd-panel">
                    <div>
                        <se-workflow-action-item
                            [workflow]="workflow"
                            [workflowAction]="action"
                            [canMakeDecisions]="canMakeDecisions"
                        ></se-workflow-action-item>
                    </div>
                </div>
                <br />
            </div>
        </div>
    `,
    styles: [`.se-page-workflow-tasks-wrapper{max-height:400px;overflow-y:scroll;padding:15px 15px 0 15px;width:100%}.se-page-workflow-tasks-wrapper .fd-panel{box-shadow:0 0 4px 0 rgba(0,0,0,.15);max-width:320px}`]
});
let PageWorkflowMenuTasksTabComponent = class PageWorkflowMenuTasksTabComponent {
};
__decorate([
    core.Input(),
    __metadata("design:type", Array)
], PageWorkflowMenuTasksTabComponent.prototype, "actions", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], PageWorkflowMenuTasksTabComponent.prototype, "workflow", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], PageWorkflowMenuTasksTabComponent.prototype, "canMakeDecisions", void 0);
PageWorkflowMenuTasksTabComponent = __decorate([
    core.Component({
        selector: 'se-page-workflow-menu-tasks-tab',
        template: `
        <div class="se-page-workflow-tasks-wrapper">
            <div *ngFor="let action of actions">
                <div class="se-page-workflow-task fd-panel">
                    <div>
                        <se-workflow-action-item
                            [workflow]="workflow"
                            [workflowAction]="action"
                            [canMakeDecisions]="canMakeDecisions"
                        ></se-workflow-action-item>
                    </div>
                </div>
                <br />
            </div>
        </div>
    `,
        styles: [`.se-page-workflow-tasks-wrapper{max-height:400px;overflow-y:scroll;padding:15px 15px 0 15px;width:100%}.se-page-workflow-tasks-wrapper .fd-panel{box-shadow:0 0 4px 0 rgba(0,0,0,.15);max-width:320px}`]
    })
], PageWorkflowMenuTasksTabComponent);

window.__smartedit__.addDecoratorPayload("Component", "WorkflowInboxBadgeComponent", {
    selector: 'se-workflow-inbox-badge',
    template: `<ng-container *ngIf="inboxCount$ | async as count"><div *ngIf="count > 0" aria-label="Notifications"><div class="fd-counter fd-counter--notification se-inbox-badge" aria-label="Unread count">{{ stringifyCount(count) }}</div></div></ng-container>`,
    styles: [`.se-inbox-badge{transform:none;top:-2px;left:22px;font-size:10px;border-radius:8px;padding:2px 4px}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ WorkflowInboxBadgeComponent = class /* @ngInject */ WorkflowInboxBadgeComponent {
    constructor(workflowService) {
        this.workflowService = workflowService;
    }
    ngOnInit() {
        this.inboxCount$ = this.workflowService.getTotalNumberOfActiveWorkflowTasks();
    }
    stringifyCount(count) {
        return count <= 99 ? String(count) : '99+';
    }
};
WorkflowInboxBadgeComponent.$inject = ["workflowService"];
/* @ngInject */ WorkflowInboxBadgeComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-workflow-inbox-badge',
        template: `<ng-container *ngIf="inboxCount$ | async as count"><div *ngIf="count > 0" aria-label="Notifications"><div class="fd-counter fd-counter--notification se-inbox-badge" aria-label="Unread count">{{ stringifyCount(count) }}</div></div></ng-container>`,
        styles: [`.se-inbox-badge{transform:none;top:-2px;left:22px;font-size:10px;border-radius:8px;padding:2px 4px}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [smarteditcommons.WorkflowService])
], /* @ngInject */ WorkflowInboxBadgeComponent);

window.__smartedit__.addDecoratorPayload("Component", "WorkflowInboxTaskComponent", {
    selector: 'se-workflow-inbox-task',
    template: `<div class="se-workflow-inbox-task-header"><a href="#" (click)="onClick($event)">{{ taskName | async }}</a></div><div class="se-workflow-inbox-task-desc">{{ taskDescription | async }}</div><div class="se-workflow-inbox-task-body">{{ getTaskCreatedAgo() }}</div>`,
    styles: [`:host{white-space:normal}:host(.se-workflow-inbox-task-last) .se-workflow-inbox-task-body{border-bottom:none;margin-bottom:0}.se-workflow-inbox-task-header a{font-size:1rem;line-height:1.4285714286;font-weight:400;font-weight:700;text-decoration:none;margin-bottom:4px}.se-workflow-inbox-task-desc{font-size:1rem;line-height:1.4285714286;font-weight:400;color:#32363a}.se-workflow-inbox-task-body{font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;color:#74777a;text-transform:lowercase;margin:8px 0 20px;padding-bottom:12px;border-bottom:1px solid #d9d9d9}`],
    providers: [smarteditcommons.L10nPipe],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ WorkflowInboxTaskComponent = class /* @ngInject */ WorkflowInboxTaskComponent {
    constructor(cMSTimeService, workflowService, l10nPipe) {
        this.cMSTimeService = cMSTimeService;
        this.workflowService = workflowService;
        this.l10nPipe = l10nPipe;
    }
    ngOnInit() {
        this.taskName = this.getTaskName();
        this.taskDescription = this.getTaskDescription();
    }
    getTaskName() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.l10nPipe.transform(this.task.action.name).pipe(operators.take(1)).toPromise();
        });
    }
    getTaskDescription() {
        return __awaiter(this, void 0, void 0, function* () {
            const catalogName = yield this.l10nPipe
                .transform(this.task.attachments[0].catalogName)
                .pipe(operators.take(1))
                .toPromise();
            return `${catalogName} ${this.task.attachments[0].catalogVersion} | ${this.task.attachments[0].pageName}`;
        });
    }
    getTaskCreatedAgo() {
        return this.cMSTimeService.getTimeAgo(this.task.action.startedAgoInMillis);
    }
    onClick($event) {
        $event.preventDefault();
        this.workflowService.loadExperienceAndOpenPageWorkflowMenu(this.task);
    }
};
WorkflowInboxTaskComponent.$inject = ["cMSTimeService", "workflowService", "l10nPipe"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ WorkflowInboxTaskComponent.prototype, "task", void 0);
/* @ngInject */ WorkflowInboxTaskComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-workflow-inbox-task',
        template: `<div class="se-workflow-inbox-task-header"><a href="#" (click)="onClick($event)">{{ taskName | async }}</a></div><div class="se-workflow-inbox-task-desc">{{ taskDescription | async }}</div><div class="se-workflow-inbox-task-body">{{ getTaskCreatedAgo() }}</div>`,
        styles: [`:host{white-space:normal}:host(.se-workflow-inbox-task-last) .se-workflow-inbox-task-body{border-bottom:none;margin-bottom:0}.se-workflow-inbox-task-header a{font-size:1rem;line-height:1.4285714286;font-weight:400;font-weight:700;text-decoration:none;margin-bottom:4px}.se-workflow-inbox-task-desc{font-size:1rem;line-height:1.4285714286;font-weight:400;color:#32363a}.se-workflow-inbox-task-body{font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;color:#74777a;text-transform:lowercase;margin:8px 0 20px;padding-bottom:12px;border-bottom:1px solid #d9d9d9}`],
        providers: [smarteditcommons.L10nPipe],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [cmscommons.CMSTimeService,
        smarteditcommons.WorkflowService,
        smarteditcommons.L10nPipe])
], /* @ngInject */ WorkflowInboxTaskComponent);

window.__smartedit__.addDecoratorPayload("Component", "WorkflowItemMenuComponent", {
    selector: 'se-workflow-item-menu',
    template: `<se-popup-overlay class="popup-anchor" [ngClass]="{ 'popup-anchor--open': isMenuOpen }" [popupOverlay]="popupConfig" [popupOverlayTrigger]="isMenuOpen" (popupOverlayOnHide)="hideMenu()"><span *ngIf="menuItems.length > 0" (click)="toggleMenu()" class="workflow-item-menu__toggle-btn sap-icon--overflow"></span><div se-popup-overlay-body><div class="workflow-item-menu"><div class="workflow-item-menu__item" *ngFor="let dropdownItem of menuItems"><ng-container class="container" [ngSwitch]="dropdownItem.i18nKey"><div *ngSwitchCase="'se.cms.actionitem.page.workflow.description'" class="workflow-description"><div class="se-dropdown-item--label"><div class="workflow-description__label fd-has-type-1 fd-has-margin-bottom-tiny"><div [translate]="dropdownItem.i18nKey"></div><div *seHasOperationPermission="'se.edit.workflow.workflowMenu'"><a title="Edit" class="workflow-description__edit-btn sap-icon--edit fd-has-float-right" (click)="editDescription()"></a></div></div><div *ngIf="workflowInfo.description; else noDescription" class="workflow-description__text">{{ workflowInfo.description }}</div><ng-template #noDescription><div translate="se.cms.actionitem.page.workflow.no.description"></div></ng-template></div></div><div *ngSwitchCase="'se.cms.actionitem.page.workflow.cancel'" class="workflow-cancel-btn fd-has-color-status-3" [translate]="dropdownItem.i18nKey" (click)="cancelWorkflow()"></div></ng-container></div></div></div></se-popup-overlay>`,
    styles: [`.popup-anchor{display:flex;flex-direction:row;align-items:center;justify-content:center;font-size:1.1428571429rem;line-height:1.25;font-weight:400;padding-top:5px;width:32px;height:32px;border-radius:4px}.popup-anchor--open{background-color:#eeeeef}.workflow-item-menu{box-shadow:0 6px 12px rgba(0,0,0,.175);background-color:#fff;border-radius:4px!important;min-width:100px;width:fit-content;position:absolute;border:1px solid #d9d9d9;z-index:2000;top:96%;left:initial!important;right:0;transform:translate(5px,8px);right:-11px;top:-8px}.workflow-item-menu::before{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#d9d9d9;border-bottom-color:var(var(--fd-color-neutral-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-8px}.workflow-item-menu::after{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#fff;border-bottom-color:var(var(--fd-color-background-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-7px}.workflow-item-menu::after,.workflow-item-menu::before{right:10px}.workflow-item-menu::after,.workflow-item-menu::before{display:none}.workflow-description{min-width:225px;padding:20px}.workflow-description__label{color:#32363a;display:flex;justify-content:space-between}.workflow-description__label .sap-icon--edit{cursor:pointer}.workflow-description__label .sap-icon--edit:hover{text-decoration:none}.workflow-description__text{word-break:normal;word-spacing:normal;word-wrap:break-word;white-space:normal;color:#51555a}.workflow-cancel-btn{cursor:pointer;padding:12px 20px;border-top:1px solid #fafafa}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ WorkflowItemMenuComponent = class /* @ngInject */ WorkflowItemMenuComponent {
    constructor(systemEventService, workflowFacade, routingService, permissionService, cdr) {
        this.systemEventService = systemEventService;
        this.workflowFacade = workflowFacade;
        this.routingService = routingService;
        this.permissionService = permissionService;
        this.cdr = cdr;
        this.isMenuOpen = false;
        this.popupConfig = {
            halign: 'left',
            valign: 'bottom'
        };
        this.menuItems = [];
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.unRegWorkflowMenuOpenedEvent = this.systemEventService.subscribe(WORKFLOW_ITEM_MENU_OPENED_EVENT, (_eventId, eventData) => this.onWorkflowItemMenuOpen(eventData));
            this.menuItems = yield this.getPermittedButtons([
                {
                    i18nKey: 'se.cms.actionitem.page.workflow.description',
                    permissions: ['se.view.page.workflowMenu']
                },
                {
                    i18nKey: 'se.cms.actionitem.page.workflow.cancel',
                    permissions: ['se.cancel.page.workflowMenu']
                }
            ]);
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    ngOnDestroy() {
        this.unRegWorkflowMenuOpenedEvent();
    }
    toggleMenu() {
        this.isMenuOpen = !this.isMenuOpen;
        if (this.isMenuOpen && this.workflowInfo) {
            this.systemEventService.publishAsync(WORKFLOW_ITEM_MENU_OPENED_EVENT, {
                uid: this.workflowInfo.workflowCode
            });
        }
    }
    hideMenu() {
        this.isMenuOpen = false;
    }
    editDescription() {
        return __awaiter(this, void 0, void 0, function* () {
            this.hideMenu();
            const updatedWorkflow = yield this.workflowFacade.editWorkflow(this.workflowInfo);
            this.workflowInfo.description = updatedWorkflow.description;
        });
    }
    cancelWorkflow() {
        return __awaiter(this, void 0, void 0, function* () {
            this.hideMenu();
            yield this.workflowFacade.cancelWorflow(this.workflowInfo);
            this.routingService.reload();
        });
    }
    onWorkflowItemMenuOpen(eventData) {
        if (this.workflowInfo.workflowCode !== eventData.uid) {
            this.hideMenu();
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        }
    }
    getPermittedButtons(menuItemsConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const buttonsPermissions = menuItemsConfig.map((menuItem) => Promise.resolve(this.permissionService.isPermitted([
                {
                    names: menuItem.permissions
                }
            ])));
            const permissions = yield Promise.all(buttonsPermissions);
            return menuItemsConfig.filter((_menuItem, index) => permissions[index]);
        });
    }
};
WorkflowItemMenuComponent.$inject = ["systemEventService", "workflowFacade", "routingService", "permissionService", "cdr"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ WorkflowItemMenuComponent.prototype, "workflowInfo", void 0);
/* @ngInject */ WorkflowItemMenuComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-workflow-item-menu',
        template: `<se-popup-overlay class="popup-anchor" [ngClass]="{ 'popup-anchor--open': isMenuOpen }" [popupOverlay]="popupConfig" [popupOverlayTrigger]="isMenuOpen" (popupOverlayOnHide)="hideMenu()"><span *ngIf="menuItems.length > 0" (click)="toggleMenu()" class="workflow-item-menu__toggle-btn sap-icon--overflow"></span><div se-popup-overlay-body><div class="workflow-item-menu"><div class="workflow-item-menu__item" *ngFor="let dropdownItem of menuItems"><ng-container class="container" [ngSwitch]="dropdownItem.i18nKey"><div *ngSwitchCase="'se.cms.actionitem.page.workflow.description'" class="workflow-description"><div class="se-dropdown-item--label"><div class="workflow-description__label fd-has-type-1 fd-has-margin-bottom-tiny"><div [translate]="dropdownItem.i18nKey"></div><div *seHasOperationPermission="'se.edit.workflow.workflowMenu'"><a title="Edit" class="workflow-description__edit-btn sap-icon--edit fd-has-float-right" (click)="editDescription()"></a></div></div><div *ngIf="workflowInfo.description; else noDescription" class="workflow-description__text">{{ workflowInfo.description }}</div><ng-template #noDescription><div translate="se.cms.actionitem.page.workflow.no.description"></div></ng-template></div></div><div *ngSwitchCase="'se.cms.actionitem.page.workflow.cancel'" class="workflow-cancel-btn fd-has-color-status-3" [translate]="dropdownItem.i18nKey" (click)="cancelWorkflow()"></div></ng-container></div></div></div></se-popup-overlay>`,
        styles: [`.popup-anchor{display:flex;flex-direction:row;align-items:center;justify-content:center;font-size:1.1428571429rem;line-height:1.25;font-weight:400;padding-top:5px;width:32px;height:32px;border-radius:4px}.popup-anchor--open{background-color:#eeeeef}.workflow-item-menu{box-shadow:0 6px 12px rgba(0,0,0,.175);background-color:#fff;border-radius:4px!important;min-width:100px;width:fit-content;position:absolute;border:1px solid #d9d9d9;z-index:2000;top:96%;left:initial!important;right:0;transform:translate(5px,8px);right:-11px;top:-8px}.workflow-item-menu::before{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#d9d9d9;border-bottom-color:var(var(--fd-color-neutral-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-8px}.workflow-item-menu::after{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#fff;border-bottom-color:var(var(--fd-color-background-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-7px}.workflow-item-menu::after,.workflow-item-menu::before{right:10px}.workflow-item-menu::after,.workflow-item-menu::before{display:none}.workflow-description{min-width:225px;padding:20px}.workflow-description__label{color:#32363a;display:flex;justify-content:space-between}.workflow-description__label .sap-icon--edit{cursor:pointer}.workflow-description__label .sap-icon--edit:hover{text-decoration:none}.workflow-description__text{word-break:normal;word-spacing:normal;word-wrap:break-word;white-space:normal;color:#51555a}.workflow-cancel-btn{cursor:pointer;padding:12px 20px;border-top:1px solid #fafafa}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [smarteditcommons.SystemEventService,
        WorkflowFacade,
        smarteditcommons.SmarteditRoutingService,
        smarteditcommons.IPermissionService,
        core.ChangeDetectorRef])
], /* @ngInject */ WorkflowItemMenuComponent);

window.__smartedit__.addDecoratorPayload("Component", "WorkflowActionCommentComponent", {
    selector: 'se-workflow-action-comment',
    template: `<ng-container *ngIf="isDecisionComment; then decisionComment; else generalComment"></ng-container><ng-template #decisionComment><div class="se-workflow-action-comment"><div class="fd-tile"><div class="fd-tile__content"><h2 class="fd-tile__title se-workflow-action-comment__header sap-icon--workflow-tasks sap-icon--m" [class.sap-icon--flip-h]="!isIncomingDecision()">{{ actionComment.decisionName }}</h2><p class="fd-has-type-minus-1">{{ actionComment.authorName }} | {{ createdAgo }}</p><p *ngIf="!!actionComment.text"><strong>{{'se.cms.page.workflow.action.item.comment.header' | translate}}:</strong><ng-container *ngTemplateOutlet="comment"></ng-container></p></div></div></div></ng-template><ng-template #generalComment><div class="se-workflow-action-comment"><div class="fd-tile"><div class="fd-tile__content"><h2 class="fd-panel__title">{{'se.cms.page.workflow.action.item.comment.header' | translate}}</h2><p>{{ createdAgo }}</p><p class="se-workflow-action-comment__author">{{ actionComment.authorName }}</p><ng-container *ngTemplateOutlet="comment"></ng-container></div></div></div></ng-template><ng-template #comment><se-more-text class="se-workflow-action-comment__body" [ellipsis]="'...'" [text]="actionComment.text"></se-more-text></ng-template>`,
    styles: [`/*!
 * Fundamental Library Styles v0.4.1
 * Copyright (c) 2020 SAP SE or an SAP affiliate company.
 * Licensed under Apache License 2.0 (https://github.com/SAP/fundamental-styles/blob/master/LICENSE)
 *//*!
.fd-button-split+()
    .fd-button
*/.fd-button-split{font-size:.875rem;font-size:var(--sapFontSize,.875rem);line-height:1.42857;color:#32363a;color:var(--sapTextColor,#32363a);font-family:"72","72full",Arial,Helvetica,sans-serif;font-family:var(--sapFontFamily, "72", "72full", Arial, Helvetica, sans-serif);font-weight:400;-webkit-font-smoothing:antialiased;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0;margin:0;border:0;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;vertical-align:middle;position:relative}.fd-button-split:after,.fd-button-split:before{-webkit-box-sizing:inherit;box-sizing:inherit;font-size:inherit}.fd-button-split :first-child{margin:0;border-top-right-radius:0;border-bottom-right-radius:0}.fd-button-split :nth-child(2){margin:0;border-top-left-radius:0;border-bottom-left-radius:0;border-left-width:0}.fd-button-split[dir=rtl] :first-child,[dir=rtl] .fd-button-split :first-child{border-top-left-radius:0;border-bottom-left-radius:0;border-top-right-radius:.25rem;border-top-right-radius:var(--sapButton_BorderCornerRadius,.25rem);border-bottom-right-radius:.25rem;border-bottom-right-radius:var(--sapButton_BorderCornerRadius,.25rem)}.fd-button-split[dir=rtl] :nth-child(2),[dir=rtl] .fd-button-split :nth-child(2){border-top-left-radius:.25rem;border-top-left-radius:var(--sapButton_BorderCornerRadius,.25rem);border-bottom-left-radius:.25rem;border-bottom-left-radius:var(--sapButton_BorderCornerRadius,.25rem);border-top-right-radius:0;border-bottom-right-radius:0;border-left-width:.0625rem;border-left-width:var(--sapButton_BorderWidth,.0625rem);border-right-width:0}.fd-button-split [class*="--emphasized"]:first-child{margin-right:1px}.fd-button-split [class*="--emphasized"][dir=rtl]:first-child,[dir=rtl] .fd-button-split [class*="--emphasized"]:first-child{margin-right:0;margin-left:1px}.se-workflow-action-comment{margin:20px 15px 10px 45px;border-style:solid;border-width:1px;border-color:#eeeeef;border-radius:3px;position:relative}.se-workflow-action-comment::before{height:0;width:0;border-style:solid;border-width:6.5px 8px 6.5px 0;border-bottom-color:transparent;border-right-color:#eeeeef;border-top-color:transparent;content:"";position:absolute;top:14px;left:-9px}.se-workflow-action-comment::after{height:0;width:0;border-style:solid;border-width:6.5px 8px 6.5px 0;border-bottom-color:transparent;border-right-color:#fff;border-top-color:transparent;content:"";position:absolute;top:14px;left:-7px}.se-workflow-action-comment__header{position:relative;font-weight:700;font-size:13px;margin-bottom:3px!important}.se-workflow-action-comment__header:before{position:absolute;top:-8px;left:-56px;font-size:18px;background:#fff;padding:8px}.se-workflow-action-comment__header.sap-icon--flip-h::before{transform:scaleX(-1)}.se-workflow-action-comment__author{margin-bottom:25px}.se-workflow-action-comment__body{overflow-wrap:anywhere}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ WorkflowActionCommentComponent = class /* @ngInject */ WorkflowActionCommentComponent {
    constructor(cMSTimeService) {
        this.cMSTimeService = cMSTimeService;
    }
    ngOnInit() {
        this.isDecisionComment = !!this.actionComment.decisionName;
    }
    get createdAgo() {
        if (!!this.actionComment.createdAgoInMillis) {
            return this.cMSTimeService.getTimeAgo(this.actionComment.createdAgoInMillis);
        }
        return null;
    }
    isIncomingDecision() {
        return !(this.actionComment.originalActionCode === this.workflowAction.code);
    }
};
WorkflowActionCommentComponent.$inject = ["cMSTimeService"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ WorkflowActionCommentComponent.prototype, "actionComment", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ WorkflowActionCommentComponent.prototype, "workflowAction", void 0);
/* @ngInject */ WorkflowActionCommentComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-workflow-action-comment',
        template: `<ng-container *ngIf="isDecisionComment; then decisionComment; else generalComment"></ng-container><ng-template #decisionComment><div class="se-workflow-action-comment"><div class="fd-tile"><div class="fd-tile__content"><h2 class="fd-tile__title se-workflow-action-comment__header sap-icon--workflow-tasks sap-icon--m" [class.sap-icon--flip-h]="!isIncomingDecision()">{{ actionComment.decisionName }}</h2><p class="fd-has-type-minus-1">{{ actionComment.authorName }} | {{ createdAgo }}</p><p *ngIf="!!actionComment.text"><strong>{{'se.cms.page.workflow.action.item.comment.header' | translate}}:</strong><ng-container *ngTemplateOutlet="comment"></ng-container></p></div></div></div></ng-template><ng-template #generalComment><div class="se-workflow-action-comment"><div class="fd-tile"><div class="fd-tile__content"><h2 class="fd-panel__title">{{'se.cms.page.workflow.action.item.comment.header' | translate}}</h2><p>{{ createdAgo }}</p><p class="se-workflow-action-comment__author">{{ actionComment.authorName }}</p><ng-container *ngTemplateOutlet="comment"></ng-container></div></div></div></ng-template><ng-template #comment><se-more-text class="se-workflow-action-comment__body" [ellipsis]="'...'" [text]="actionComment.text"></se-more-text></ng-template>`,
        styles: [`/*!
 * Fundamental Library Styles v0.4.1
 * Copyright (c) 2020 SAP SE or an SAP affiliate company.
 * Licensed under Apache License 2.0 (https://github.com/SAP/fundamental-styles/blob/master/LICENSE)
 *//*!
.fd-button-split+()
    .fd-button
*/.fd-button-split{font-size:.875rem;font-size:var(--sapFontSize,.875rem);line-height:1.42857;color:#32363a;color:var(--sapTextColor,#32363a);font-family:"72","72full",Arial,Helvetica,sans-serif;font-family:var(--sapFontFamily, "72", "72full", Arial, Helvetica, sans-serif);font-weight:400;-webkit-font-smoothing:antialiased;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0;margin:0;border:0;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;vertical-align:middle;position:relative}.fd-button-split:after,.fd-button-split:before{-webkit-box-sizing:inherit;box-sizing:inherit;font-size:inherit}.fd-button-split :first-child{margin:0;border-top-right-radius:0;border-bottom-right-radius:0}.fd-button-split :nth-child(2){margin:0;border-top-left-radius:0;border-bottom-left-radius:0;border-left-width:0}.fd-button-split[dir=rtl] :first-child,[dir=rtl] .fd-button-split :first-child{border-top-left-radius:0;border-bottom-left-radius:0;border-top-right-radius:.25rem;border-top-right-radius:var(--sapButton_BorderCornerRadius,.25rem);border-bottom-right-radius:.25rem;border-bottom-right-radius:var(--sapButton_BorderCornerRadius,.25rem)}.fd-button-split[dir=rtl] :nth-child(2),[dir=rtl] .fd-button-split :nth-child(2){border-top-left-radius:.25rem;border-top-left-radius:var(--sapButton_BorderCornerRadius,.25rem);border-bottom-left-radius:.25rem;border-bottom-left-radius:var(--sapButton_BorderCornerRadius,.25rem);border-top-right-radius:0;border-bottom-right-radius:0;border-left-width:.0625rem;border-left-width:var(--sapButton_BorderWidth,.0625rem);border-right-width:0}.fd-button-split [class*="--emphasized"]:first-child{margin-right:1px}.fd-button-split [class*="--emphasized"][dir=rtl]:first-child,[dir=rtl] .fd-button-split [class*="--emphasized"]:first-child{margin-right:0;margin-left:1px}.se-workflow-action-comment{margin:20px 15px 10px 45px;border-style:solid;border-width:1px;border-color:#eeeeef;border-radius:3px;position:relative}.se-workflow-action-comment::before{height:0;width:0;border-style:solid;border-width:6.5px 8px 6.5px 0;border-bottom-color:transparent;border-right-color:#eeeeef;border-top-color:transparent;content:"";position:absolute;top:14px;left:-9px}.se-workflow-action-comment::after{height:0;width:0;border-style:solid;border-width:6.5px 8px 6.5px 0;border-bottom-color:transparent;border-right-color:#fff;border-top-color:transparent;content:"";position:absolute;top:14px;left:-7px}.se-workflow-action-comment__header{position:relative;font-weight:700;font-size:13px;margin-bottom:3px!important}.se-workflow-action-comment__header:before{position:absolute;top:-8px;left:-56px;font-size:18px;background:#fff;padding:8px}.se-workflow-action-comment__header.sap-icon--flip-h::before{transform:scaleX(-1)}.se-workflow-action-comment__author{margin-bottom:25px}.se-workflow-action-comment__body{overflow-wrap:anywhere}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [cmscommons.CMSTimeService])
], /* @ngInject */ WorkflowActionCommentComponent);

const PAGE_APPROVAL_PAGE_APPROVED_ID = 'PageApprovalPageApproved';
window.__smartedit__.addDecoratorPayload("Component", "WorkflowActionItemComponent", {
    selector: 'se-workflow-action-item',
    template: `<div class="se-workflow-action-item" [ngClass]="getWorkflowActionStatusClass()"><se-collapsible-container class="se-catalog-details__collapse se-collapsible-container--noshadow fd-panel" [id]="workflowAction.code" (getApi)="setCollapsibleContainerApi($event)"><se-collapsible-container-header><div class="fd-panel__header"><div class="fd-panel__head"><h1 class="fd-panel__title">{{ workflowAction.name | seL10n | async }}</h1><p class="fd-panel__description">{{ getReadableStatus() | translate }} {{ getActiveSince() }}</p></div></div><div class="fd-panel__body">{{ workflowAction.description | seL10n | async }}<div *ngIf="canShowDecisionButtons()" class="se-workflow-action-item__decision-buttons fd-dropdown"><div class="fd-popover"><div class="fd-popover__control"><div [ngClass]="{ 'fd-button-split': workflowAction.decisions.length > 1 }"><button class="se-workflow-action-item__decision-button fd-button--compact" [id]="workflowAction.code + '-decision-button'" (click)="onMainButtonClick($event, workflowAction.decisions[0])" type="button">{{ workflowAction.decisions[0].name | seL10n | async }}</button><se-popup-overlay [popupOverlay]="{
                                        halign: 'right',
                                        valign: 'bottom'
                                    }" [popupOverlayTrigger]="isMenuOpen" (popupOverlayOnHide)="onMenuHide()"><button *ngIf="workflowAction.decisions.length > 1" [id]="workflowAction.code + '-decision-split-button'" class="fd-button--compact menu-button sap-icon--slim-arrow-down" (click)="onSplitButtonClick($event)"></button><div se-popup-overlay-body class="fd-popover__body fd-popover__body--right fd-popover__body--no-arrow se-workflow-action-item__decision-list"><nav class="fd-menu"><ul class="fd-menu__list"><li *ngFor="let decision of workflowAction.decisions"><a class="fd-menu__item se-workflow-action-item__decision" (click)="onMainButtonClick($event, decision)">{{ decision.name | seL10n | async }}</a></li></ul></nav></div></se-popup-overlay></div></div></div></div></div></se-collapsible-container-header><se-collapsible-container-content><div class="se-workflow-action-item__content" *ngIf="canShowComments()"><span *ngIf="!hasComments" class="se-workflow-action-item__comment-list fd-has-font-style-italic fd-has-color-text-4" [translate]="'se.cms.actionitem.page.workflow.action.no.comments.available'"></span><se-infinite-scrolling [pageSize]="pageSize" [fetchPage]="fetchPageOfComments" (itemsChange)="onCommentsLoaded($event)"><div *ngFor="let actionComment of workflowActionComments; trackBy: trackByIndex"><se-workflow-action-comment [workflowAction]="workflowAction" [actionComment]="actionComment"></se-workflow-action-comment></div></se-infinite-scrolling></div></se-collapsible-container-content></se-collapsible-container><fd-popover [isOpen]="showApprovalInfo" [closeOnOutsideClick]="false"><fd-popover-body><div class="se-workflow-approval-info">{{ approvalInfo }}</div></fd-popover-body></fd-popover></div>`,
    styles: [`/*!
 * Fundamental Library Styles v0.4.1
 * Copyright (c) 2020 SAP SE or an SAP affiliate company.
 * Licensed under Apache License 2.0 (https://github.com/SAP/fundamental-styles/blob/master/LICENSE)
 *//*!
.fd-button-split+()
    .fd-button
*/.fd-button-split{font-size:.875rem;font-size:var(--sapFontSize,.875rem);line-height:1.42857;color:#32363a;color:var(--sapTextColor,#32363a);font-family:"72","72full",Arial,Helvetica,sans-serif;font-family:var(--sapFontFamily, "72", "72full", Arial, Helvetica, sans-serif);font-weight:400;-webkit-font-smoothing:antialiased;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0;margin:0;border:0;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;vertical-align:middle;position:relative}.fd-button-split:after,.fd-button-split:before{-webkit-box-sizing:inherit;box-sizing:inherit;font-size:inherit}.fd-button-split :first-child{margin:0;border-top-right-radius:0;border-bottom-right-radius:0}.fd-button-split :nth-child(2){margin:0;border-top-left-radius:0;border-bottom-left-radius:0;border-left-width:0}.fd-button-split[dir=rtl] :first-child,[dir=rtl] .fd-button-split :first-child{border-top-left-radius:0;border-bottom-left-radius:0;border-top-right-radius:.25rem;border-top-right-radius:var(--sapButton_BorderCornerRadius,.25rem);border-bottom-right-radius:.25rem;border-bottom-right-radius:var(--sapButton_BorderCornerRadius,.25rem)}.fd-button-split[dir=rtl] :nth-child(2),[dir=rtl] .fd-button-split :nth-child(2){border-top-left-radius:.25rem;border-top-left-radius:var(--sapButton_BorderCornerRadius,.25rem);border-bottom-left-radius:.25rem;border-bottom-left-radius:var(--sapButton_BorderCornerRadius,.25rem);border-top-right-radius:0;border-bottom-right-radius:0;border-left-width:.0625rem;border-left-width:var(--sapButton_BorderWidth,.0625rem);border-right-width:0}.fd-button-split [class*="--emphasized"]:first-child{margin-right:1px}.fd-button-split [class*="--emphasized"][dir=rtl]:first-child,[dir=rtl] .fd-button-split [class*="--emphasized"]:first-child{margin-right:0;margin-left:1px}se-workflow-action-item .se-workflow-action-item{border-left:6px solid #fff;border-radius:4px 0 0 4px}se-workflow-action-item .se-workflow-action-item--started{border-left:6px solid #e9730c}se-workflow-action-item .se-workflow-action-item--completed{border-left:6px solid #0a7e3e}se-workflow-action-item .se-workflow-action-item__decision-buttons{margin:10px -30px 10px 0;text-align:right}se-workflow-action-item .se-workflow-action-item__decision-buttons .fd-button-split .menu-button{border-left:0;border-top-left-radius:0;border-bottom-left-radius:0;border-top-right-radius:4px;border-bottom-right-radius:4px}se-workflow-action-item .se-workflow-action-item__decision-buttons .fd-button-split .menu-button:focus{box-shadow:none}se-workflow-action-item .se-workflow-action-item__content{min-height:30px}se-workflow-action-item .se-workflow-action-item__content-status{float:left;overflow:hidden}se-workflow-action-item .se-workflow-action-item__content se-infinite-scrolling .se-infinite-scrolling__container{max-height:none;overflow-y:auto;position:relative;margin-top:-20px;width:100%}se-workflow-action-item .se-workflow-action-item__content se-infinite-scrolling .se-infinite-scrolling__container::before{content:"";height:100%;border-left:1px solid #eeeeef;position:absolute;left:20px;top:40px;height:calc(100% - 120px)}se-workflow-action-item .se-workflow-action-item__comment-list{margin-left:5%;margin-top:5%;margin-bottom:5%}se-workflow-action-item .se-workflow-action-item__decision-list{min-width:160px;right:-38px;background:#fff}se-workflow-action-item .se-workflow-action-item__decision-list .fd-menu__list{text-align:left}se-workflow-action-item .se-workflow-action-item__decision:hover{text-decoration:none}se-workflow-action-item se-collapsible-container-header .fd-panel__body,se-workflow-action-item se-collapsible-container-header .fd-panel__header{border-bottom:none;padding:10px 16px;display:flex;flex-direction:column;align-items:flex-start;white-space:pre-wrap}se-workflow-action-item se-collapsible-container-header .fd-panel_body{color:#32363a;padding-top:0}se-workflow-action-item se-collapsible-container-header .fd-panel__title{margin-top:0;font-size:13px;font-weight:700}se-workflow-action-item .se-workflow-approval-info{width:320px;white-space:normal;padding:16px}`],
    encapsulation: core.ViewEncapsulation.None,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ WorkflowActionItemComponent = class /* @ngInject */ WorkflowActionItemComponent {
    constructor(workflowFacade, cMSTimeService, systemEventService, routingService, cdr, workflowService) {
        this.workflowFacade = workflowFacade;
        this.cMSTimeService = cMSTimeService;
        this.systemEventService = systemEventService;
        this.routingService = routingService;
        this.cdr = cdr;
        this.workflowService = workflowService;
        this.isMenuOpen = false;
        this.hasComments = true;
        this.pageSize = 10;
        this.showApprovalInfo = false;
        this.fetchPageOfComments = (mask, pageSize, currentPage) => this.loadCommentsAndSetHasCommentsFlag(mask, pageSize, currentPage);
    }
    ngOnInit() {
        this.unRegWorkflowMenuOpenedEvent = this.systemEventService.subscribe(WORKFLOW_ITEM_MENU_OPENED_EVENT, (eventId, eventData) => this.onOtherMenuOpening(eventId, eventData));
    }
    ngOnDestroy() {
        this.unRegWorkflowMenuOpenedEvent();
    }
    onCommentsLoaded(comments) {
        this.workflowActionComments = comments;
    }
    setCollapsibleContainerApi($api) {
        this.collapsibleContainerApi = $api;
    }
    getWorkflowActionStatusClass() {
        switch (this.workflowAction.status.toLowerCase()) {
            case smarteditcommons.WorkflowActionStatus.IN_PROGRESS:
                return 'se-workflow-action-item--started';
            case smarteditcommons.WorkflowActionStatus.COMPLETED:
                return 'se-workflow-action-item--completed';
            default:
                return null;
        }
    }
    getReadableStatus() {
        switch (this.workflowAction.status.toLowerCase()) {
            case smarteditcommons.WorkflowActionStatus.IN_PROGRESS:
                return 'se.cms.actionitem.page.workflow.action.status.started';
            case smarteditcommons.WorkflowActionStatus.PENDING:
                return 'se.cms.actionitem.page.workflow.action.status.not.started';
            default:
                return this.workflowAction.status;
        }
    }
    getActiveSince() {
        if (!!this.workflowAction.startedAgoInMillis) {
            return this.cMSTimeService.getTimeAgo(this.workflowAction.startedAgoInMillis);
        }
        return null;
    }
    canShowDecisionButtons() {
        return (this.canMakeDecisions &&
            this.workflowAction.isCurrentUserParticipant &&
            this.workflowAction.decisions.length > 0);
    }
    canShowComments() {
        const isContainerExpanded = this.collapsibleContainerApi && this.collapsibleContainerApi.isExpanded();
        return (isContainerExpanded ||
            (this.workflowActionComments && this.workflowActionComments.length > 0));
    }
    onMainButtonClick($event, decision) {
        return __awaiter(this, void 0, void 0, function* () {
            $event.preventDefault();
            $event.stopPropagation();
            this.isMenuOpen = false;
            if (decision.code === PAGE_APPROVAL_PAGE_APPROVED_ID) {
                const pageHasUnavailableDependencies = yield this.workflowService.pageHasUnavailableDependencies();
                if (pageHasUnavailableDependencies) {
                    this.showApprovalInfo = !this.showApprovalInfo;
                    this.approvalInfo = yield this.workflowService.fetchPageTranslatedApprovalInfo();
                    if (!this.cdr.destroyed) {
                        this.cdr.detectChanges();
                    }
                    return;
                }
            }
            this.makeDecision(decision).then(() => {
                this.routingService.reload();
            });
        });
    }
    onSplitButtonClick($event) {
        $event.preventDefault();
        $event.stopPropagation();
        this.isMenuOpen = !this.isMenuOpen;
        if (this.isMenuOpen) {
            this.systemEventService.publishAsync(WORKFLOW_ITEM_MENU_OPENED_EVENT, {
                code: this.workflowAction.code
            });
        }
    }
    onMenuHide() {
        this.isMenuOpen = false;
    }
    trackByIndex(index) {
        return index;
    }
    loadCommentsAndSetHasCommentsFlag(mask, pageSize, currentPage) {
        return __awaiter(this, void 0, void 0, function* () {
            const page = yield this.loadComments(mask, pageSize, currentPage);
            this.hasComments = page.pagination.totalCount > 0;
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
            return page;
        });
    }
    loadComments(mask, pageSize, currentPage) {
        return this.workflowFacade.getCommentsForWorkflowAction(this.workflow.workflowCode, this.workflowAction.code, {
            mask,
            pageSize,
            currentPage
        });
    }
    makeDecision(decision) {
        this.systemEventService.publish(WORKFLOW_DECISION_SELECTED_EVENT);
        return this.workflowFacade.makeDecision(this.workflow.workflowCode, this.workflowAction, decision);
    }
    onOtherMenuOpening(_eventId, eventData) {
        if (this.workflowAction.code !== eventData.code) {
            this.isMenuOpen = false;
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        }
    }
};
WorkflowActionItemComponent.$inject = ["workflowFacade", "cMSTimeService", "systemEventService", "routingService", "cdr", "workflowService"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ WorkflowActionItemComponent.prototype, "workflow", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ WorkflowActionItemComponent.prototype, "workflowAction", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], /* @ngInject */ WorkflowActionItemComponent.prototype, "canMakeDecisions", void 0);
/* @ngInject */ WorkflowActionItemComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-workflow-action-item',
        template: `<div class="se-workflow-action-item" [ngClass]="getWorkflowActionStatusClass()"><se-collapsible-container class="se-catalog-details__collapse se-collapsible-container--noshadow fd-panel" [id]="workflowAction.code" (getApi)="setCollapsibleContainerApi($event)"><se-collapsible-container-header><div class="fd-panel__header"><div class="fd-panel__head"><h1 class="fd-panel__title">{{ workflowAction.name | seL10n | async }}</h1><p class="fd-panel__description">{{ getReadableStatus() | translate }} {{ getActiveSince() }}</p></div></div><div class="fd-panel__body">{{ workflowAction.description | seL10n | async }}<div *ngIf="canShowDecisionButtons()" class="se-workflow-action-item__decision-buttons fd-dropdown"><div class="fd-popover"><div class="fd-popover__control"><div [ngClass]="{ 'fd-button-split': workflowAction.decisions.length > 1 }"><button class="se-workflow-action-item__decision-button fd-button--compact" [id]="workflowAction.code + '-decision-button'" (click)="onMainButtonClick($event, workflowAction.decisions[0])" type="button">{{ workflowAction.decisions[0].name | seL10n | async }}</button><se-popup-overlay [popupOverlay]="{
                                        halign: 'right',
                                        valign: 'bottom'
                                    }" [popupOverlayTrigger]="isMenuOpen" (popupOverlayOnHide)="onMenuHide()"><button *ngIf="workflowAction.decisions.length > 1" [id]="workflowAction.code + '-decision-split-button'" class="fd-button--compact menu-button sap-icon--slim-arrow-down" (click)="onSplitButtonClick($event)"></button><div se-popup-overlay-body class="fd-popover__body fd-popover__body--right fd-popover__body--no-arrow se-workflow-action-item__decision-list"><nav class="fd-menu"><ul class="fd-menu__list"><li *ngFor="let decision of workflowAction.decisions"><a class="fd-menu__item se-workflow-action-item__decision" (click)="onMainButtonClick($event, decision)">{{ decision.name | seL10n | async }}</a></li></ul></nav></div></se-popup-overlay></div></div></div></div></div></se-collapsible-container-header><se-collapsible-container-content><div class="se-workflow-action-item__content" *ngIf="canShowComments()"><span *ngIf="!hasComments" class="se-workflow-action-item__comment-list fd-has-font-style-italic fd-has-color-text-4" [translate]="'se.cms.actionitem.page.workflow.action.no.comments.available'"></span><se-infinite-scrolling [pageSize]="pageSize" [fetchPage]="fetchPageOfComments" (itemsChange)="onCommentsLoaded($event)"><div *ngFor="let actionComment of workflowActionComments; trackBy: trackByIndex"><se-workflow-action-comment [workflowAction]="workflowAction" [actionComment]="actionComment"></se-workflow-action-comment></div></se-infinite-scrolling></div></se-collapsible-container-content></se-collapsible-container><fd-popover [isOpen]="showApprovalInfo" [closeOnOutsideClick]="false"><fd-popover-body><div class="se-workflow-approval-info">{{ approvalInfo }}</div></fd-popover-body></fd-popover></div>`,
        styles: [`/*!
 * Fundamental Library Styles v0.4.1
 * Copyright (c) 2020 SAP SE or an SAP affiliate company.
 * Licensed under Apache License 2.0 (https://github.com/SAP/fundamental-styles/blob/master/LICENSE)
 *//*!
.fd-button-split+()
    .fd-button
*/.fd-button-split{font-size:.875rem;font-size:var(--sapFontSize,.875rem);line-height:1.42857;color:#32363a;color:var(--sapTextColor,#32363a);font-family:"72","72full",Arial,Helvetica,sans-serif;font-family:var(--sapFontFamily, "72", "72full", Arial, Helvetica, sans-serif);font-weight:400;-webkit-font-smoothing:antialiased;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0;margin:0;border:0;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;vertical-align:middle;position:relative}.fd-button-split:after,.fd-button-split:before{-webkit-box-sizing:inherit;box-sizing:inherit;font-size:inherit}.fd-button-split :first-child{margin:0;border-top-right-radius:0;border-bottom-right-radius:0}.fd-button-split :nth-child(2){margin:0;border-top-left-radius:0;border-bottom-left-radius:0;border-left-width:0}.fd-button-split[dir=rtl] :first-child,[dir=rtl] .fd-button-split :first-child{border-top-left-radius:0;border-bottom-left-radius:0;border-top-right-radius:.25rem;border-top-right-radius:var(--sapButton_BorderCornerRadius,.25rem);border-bottom-right-radius:.25rem;border-bottom-right-radius:var(--sapButton_BorderCornerRadius,.25rem)}.fd-button-split[dir=rtl] :nth-child(2),[dir=rtl] .fd-button-split :nth-child(2){border-top-left-radius:.25rem;border-top-left-radius:var(--sapButton_BorderCornerRadius,.25rem);border-bottom-left-radius:.25rem;border-bottom-left-radius:var(--sapButton_BorderCornerRadius,.25rem);border-top-right-radius:0;border-bottom-right-radius:0;border-left-width:.0625rem;border-left-width:var(--sapButton_BorderWidth,.0625rem);border-right-width:0}.fd-button-split [class*="--emphasized"]:first-child{margin-right:1px}.fd-button-split [class*="--emphasized"][dir=rtl]:first-child,[dir=rtl] .fd-button-split [class*="--emphasized"]:first-child{margin-right:0;margin-left:1px}se-workflow-action-item .se-workflow-action-item{border-left:6px solid #fff;border-radius:4px 0 0 4px}se-workflow-action-item .se-workflow-action-item--started{border-left:6px solid #e9730c}se-workflow-action-item .se-workflow-action-item--completed{border-left:6px solid #0a7e3e}se-workflow-action-item .se-workflow-action-item__decision-buttons{margin:10px -30px 10px 0;text-align:right}se-workflow-action-item .se-workflow-action-item__decision-buttons .fd-button-split .menu-button{border-left:0;border-top-left-radius:0;border-bottom-left-radius:0;border-top-right-radius:4px;border-bottom-right-radius:4px}se-workflow-action-item .se-workflow-action-item__decision-buttons .fd-button-split .menu-button:focus{box-shadow:none}se-workflow-action-item .se-workflow-action-item__content{min-height:30px}se-workflow-action-item .se-workflow-action-item__content-status{float:left;overflow:hidden}se-workflow-action-item .se-workflow-action-item__content se-infinite-scrolling .se-infinite-scrolling__container{max-height:none;overflow-y:auto;position:relative;margin-top:-20px;width:100%}se-workflow-action-item .se-workflow-action-item__content se-infinite-scrolling .se-infinite-scrolling__container::before{content:"";height:100%;border-left:1px solid #eeeeef;position:absolute;left:20px;top:40px;height:calc(100% - 120px)}se-workflow-action-item .se-workflow-action-item__comment-list{margin-left:5%;margin-top:5%;margin-bottom:5%}se-workflow-action-item .se-workflow-action-item__decision-list{min-width:160px;right:-38px;background:#fff}se-workflow-action-item .se-workflow-action-item__decision-list .fd-menu__list{text-align:left}se-workflow-action-item .se-workflow-action-item__decision:hover{text-decoration:none}se-workflow-action-item se-collapsible-container-header .fd-panel__body,se-workflow-action-item se-collapsible-container-header .fd-panel__header{border-bottom:none;padding:10px 16px;display:flex;flex-direction:column;align-items:flex-start;white-space:pre-wrap}se-workflow-action-item se-collapsible-container-header .fd-panel_body{color:#32363a;padding-top:0}se-workflow-action-item se-collapsible-container-header .fd-panel__title{margin-top:0;font-size:13px;font-weight:700}se-workflow-action-item .se-workflow-approval-info{width:320px;white-space:normal;padding:16px}`],
        encapsulation: core.ViewEncapsulation.None,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [WorkflowFacade,
        cmscommons.CMSTimeService,
        smarteditcommons.SystemEventService,
        smarteditcommons.SmarteditRoutingService,
        core.ChangeDetectorRef,
        smarteditcommons.WorkflowService])
], /* @ngInject */ WorkflowActionItemComponent);

let WorkflowModule = class WorkflowModule {
};
WorkflowModule = __decorate([
    core.NgModule({
        imports: [
            smarteditcommons.TranslationModule.forChild(),
            common.CommonModule,
            core$2.PopoverModule,
            smarteditcommons.InfiniteScrollingModule,
            smarteditcommons.MoreTextModule,
            smarteditcommons.CollapsibleContainerModule,
            smarteditcommons.PopupOverlayModule,
            smarteditcommons.TooltipModule,
            smarteditcommons.DropdownMenuModule,
            smarteditcommons.HasOperationPermissionDirectiveModule,
            smarteditcommons.SpinnerModule,
            smarteditcommons.TabsModule,
            smarteditcommons.L10nPipeModule,
            smarteditcommons.FundamentalsModule
        ],
        declarations: [
            WorkflowInboxSingleTaskAnnouncementComponent,
            WorkflowInboxMultipleTasksAnnouncementComponent,
            WorkflowInboxTaskComponent,
            WorkflowInboxBadgeComponent,
            WorkflowInboxComponent,
            WorkflowActionCommentComponent,
            WorkflowActionItemComponent,
            PageDisplayStatusComponent,
            PageDisplayStatusWrapperComponent,
            PageStatusComponent,
            PageApprovalSelectorComponent,
            WorkflowItemMenuComponent,
            PageWorkflowMenuComponent,
            PageWorkflowMenuCurrentTasksTabComponent,
            PageWorkflowMenuAllTasksTabComponent,
            PageWorkflowMenuTasksTabComponent,
            PageInWorkflowNotificationComponent
        ],
        entryComponents: [
            WorkflowInboxSingleTaskAnnouncementComponent,
            WorkflowInboxMultipleTasksAnnouncementComponent,
            WorkflowInboxTaskComponent,
            WorkflowInboxBadgeComponent,
            WorkflowInboxComponent,
            WorkflowActionCommentComponent,
            WorkflowActionItemComponent,
            PageDisplayStatusComponent,
            PageDisplayStatusWrapperComponent,
            PageStatusComponent,
            PageApprovalSelectorComponent,
            WorkflowItemMenuComponent,
            PageWorkflowMenuComponent,
            PageWorkflowMenuCurrentTasksTabComponent,
            PageWorkflowMenuAllTasksTabComponent,
            PageWorkflowMenuTasksTabComponent,
            PageInWorkflowNotificationComponent
        ],
        exports: [PageDisplayStatusComponent],
        providers: [
            WorkflowInboxAnnouncementService,
            WorkflowFacade,
            smarteditcommons.moduleUtils.bootstrap((crossFrameEventService, pageInfoService, workflowService, notificationService, smarteditRoutingService, 
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            workflowInboxAnnouncementService // initializes subscriber for tasks pooling service
            ) => {
                const NOTIFICATION_ID = 'PAGE_IN_WORKFLOW_NOTIFICATION_ID';
                crossFrameEventService.subscribe(smarteditcommons.EVENTS.PAGE_CHANGE, () => {
                    // Using pageInfoService.getPageUUID instead of pageService.getCurrentPageInfo because pageInfoService uses information from the DOM
                    // instead of fetching from the backend and hence preventing any race condition while clearing the cache.
                    pageInfoService.getPageUUID().then((pageUuid) => {
                        workflowService
                            .getActiveWorkflowForPageUuid(pageUuid)
                            .then((workflow) => {
                            if (workflow !== null && !workflow.isAvailableForCurrentPrincipal) {
                                notificationService.pushNotification({
                                    id: NOTIFICATION_ID,
                                    componentName: PageInWorkflowNotificationComponent.name
                                });
                            }
                            else {
                                notificationService.removeNotification(NOTIFICATION_ID);
                            }
                        });
                    });
                });
                smarteditRoutingService.routeChangeSuccess().subscribe((event) => {
                    const url = smarteditRoutingService.getCurrentUrlFromEvent(event);
                    if (url !== `/${smarteditcommons.NG_ROUTE_PREFIX}${smarteditcommons.STORE_FRONT_CONTEXT}`) {
                        notificationService.removeNotification(NOTIFICATION_ID);
                    }
                });
            }, [
                smarteditcommons.CrossFrameEventService,
                smarteditcommons.IPageInfoService,
                smarteditcommons.WorkflowService,
                smarteditcommons.INotificationService,
                smarteditcommons.SmarteditRoutingService,
                WorkflowInboxAnnouncementService
            ])
        ]
    })
], WorkflowModule);

var CatalogHomepageDetailsStatus;
(function (CatalogHomepageDetailsStatus) {
    CatalogHomepageDetailsStatus["PENDING"] = "PENDING";
    CatalogHomepageDetailsStatus["NO_HOMEPAGE"] = "NO_HOMEPAGE";
    CatalogHomepageDetailsStatus["LOCAL"] = "LOCAL";
    CatalogHomepageDetailsStatus["OLD"] = "OLD";
    CatalogHomepageDetailsStatus["PARENT"] = "PARENT";
})(CatalogHomepageDetailsStatus || (CatalogHomepageDetailsStatus = {}));
window.__smartedit__.addDecoratorPayload("Component", "NewPageDisplayConditionComponent", {
    selector: 'se-new-page-display-condition',
    template: `<div *ngIf="isReady"><div class="form-group"><label for="page-condition-selector-id" class="se-control-label" translate="se.cms.page.condition.selection.label"></label><se-select id="page-condition-selector-id" [model]="conditionSelected.label" (modelChange)="onConditionChange($event)" [fetchStrategy]="conditionSelectorFetchStrategy" [onChange]="onDataChange" [searchEnabled]="false"></se-select><span class="se-form-help-message"><span [translate]="conditionSelected.description"></span></span></div><div *ngIf="showPrimarySelector()" class="form-group"><label for="page-condition-primary-selector-id" class="se-control-label" translate="se.cms.page.condition.primary.association.label"></label><se-select id="page-condition-primary-selector-id" [model]="primarySelectedModel" (modelChange)="primarySelectedModelOnChange($event)" [fetchStrategy]="primaryPageChoicesFetchStrategy" [onChange]="onDataChange"></se-select><span *ngIf="primarySelected?.label" class="se-form-help-message"><span>{{ 'se.cms.page.label.label' | translate }}: {{ primarySelected.label }}</span></span></div><div *ngIf="showHomePageWidget()"><div class="fd-form__item"><input type="checkbox" id="set-homepage-checkbox" class="se-component-item--details se-component-homepage__checkbox-input fd-form__control" name="clone-on-drop" (ngModelChange)="onHomePageChange($event)" [ngModel]="homepage"/> <label class="se-control-label se-component-homepage--label fd-form__label" for="set-homepage-checkbox" translate="se.cms.display.conditions.homepage.set"></label></div><label class="se-control-label se-component-homepage--label" for="set-homepage-checkbox" *ngIf="showReplaceLabel">{{ "se.cms.display.conditions.homepage.replace" | translate: { currentHomepage: currentHomePageName } }}</label></div></div>`,
    styles: [`.se-component-homepage__checkbox-input{margin:0 4px 0 0;outline:0;box-shadow:none}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    providers: [smarteditcommons.L10nPipe]
});
let /* @ngInject */ NewPageDisplayConditionComponent = class /* @ngInject */ NewPageDisplayConditionComponent {
    constructor(urlService, homepageService, displayConditionsFacade, translateService, pageService, logService, pageDisplayConditions, l10n, cdr) {
        this.urlService = urlService;
        this.homepageService = homepageService;
        this.displayConditionsFacade = displayConditionsFacade;
        this.translateService = translateService;
        this.pageService = pageService;
        this.logService = logService;
        this.pageDisplayConditions = pageDisplayConditions;
        this.l10n = l10n;
        this.cdr = cdr;
        this.conditions = null;
        this.homepage = false;
        this.homepageDetails = {
            status: CatalogHomepageDetailsStatus.PENDING
        };
        this.isReady = false;
        this.primarySelected = null;
        this.primarySelectedModel = null;
        this.showReplaceLabel = false;
    }
    ngOnInit() {
        this.onDataChange = () => this.dataChanged();
        this.conditionSelected = {};
        this.conditionSelectorFetchStrategy = {
            fetchAll: () => Promise.resolve((this.conditions || []).map((condition) => ({
                id: condition.label,
                label: condition.label
            })))
        };
        this.initialConditionSelectedKey =
            this.initialConditionSelectedKey || 'page.displaycondition.primary';
        this.primaryPageChoicesFetchStrategy = {
            fetchEntity: () => Promise.resolve({
                id: this.primarySelected.uid,
                label: this.primarySelected.name || this.primarySelected.label
            }),
            fetchPage: (search, pageSize, currentPage) => this.displayConditionsFacade.getPrimaryPagesForPageType(this.pageTypeCode, this.uriContext, {
                search,
                pageSize,
                currentPage
            })
        };
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            const hasPageTypeCodeChanged = !!changes.pageTypeCode &&
                changes.pageTypeCode.currentValue != changes.pageTypeCode.previousValue;
            const hasTargetCatalogVersionChanged = !!changes.targetCatalogVersion &&
                !lodash.isEqual(changes.targetCatalogVersion.currentValue, changes.targetCatalogVersion.previousValue);
            if (hasPageTypeCodeChanged || hasTargetCatalogVersionChanged) {
                if (!this.targetCatalogVersion ||
                    this.isUriContextEqualToCatalogVersion(this.uriContext, this.targetCatalogVersion)) {
                    yield this.getSelectedPrimaryPageAndDisplayCondition();
                }
                else {
                    this.getOnlyPrimaryDisplayCondition();
                }
                const context = this.targetCatalogVersion === undefined
                    ? this.uriContext
                    : this.urlService.buildUriContext(this.targetCatalogVersion.siteId, this.targetCatalogVersion.catalogId, this.targetCatalogVersion.version);
                const homepageDetails = yield this.homepageService.getHomepageDetailsForContext(context);
                this.homepageDetails = homepageDetails;
                yield this.updateHomepageUiProperties();
            }
            else {
                yield this.updateHomepageUiProperties();
            }
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    showPrimarySelector() {
        return !(this.conditionSelected && this.conditionSelected.isPrimary);
    }
    onConditionChange(selectedConditionLabel) {
        this.conditionSelected = this.conditions.find((condition) => condition.label === selectedConditionLabel);
    }
    onHomePageChange(isHomepage) {
        this.homepage = isHomepage;
        this.dataChanged();
    }
    showHomePageWidget() {
        return this.isPrimaryContentPage();
    }
    primarySelectedModelOnChange(uid) {
        return __awaiter(this, void 0, void 0, function* () {
            const page = yield this.pageService.getPageById(uid);
            this.setPrimarySelected(page);
            this.dataChanged();
        });
    }
    dataChanged() {
        if (!this.isPrimaryContentPage()) {
            this.homepage = undefined;
        }
        this.updateHomepageUiProperties();
        if (this.resultFn) {
            this.resultFn(this.getResults());
        }
    }
    isPrimaryContentPage() {
        var _a;
        return ((_a = this.conditionSelected) === null || _a === void 0 ? void 0 : _a.isPrimary) && this.pageTypeCode === 'ContentPage';
    }
    updateHomepageUiProperties() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.homepage) {
                switch (this.homepageDetails.status) {
                    case CatalogHomepageDetailsStatus.NO_HOMEPAGE:
                        this.homepageService.sendEventHideReplaceParentHomePageInfo();
                        this.showReplaceLabel = false;
                        break;
                    case CatalogHomepageDetailsStatus.PARENT:
                        const [parentCatalogName, targetCatalogName] = yield this.getTranslatedNames(this.homepageDetails.parentCatalogName, this.homepageDetails.targetCatalogName);
                        this.homepageService.sendEventShowReplaceParentHomePageInfo({
                            description: this.translateService.instant('se.cms.display.conditions.homepage.replace.parent.info.header', {
                                parentCatalogName,
                                parentCatalogVersion: this.homepageDetails.parentCatalogVersion,
                                targetCatalogName,
                                targetCatalogVersion: this.homepageDetails.targetCatalogVersion
                            })
                        });
                        this.showReplaceLabel = false;
                        break;
                    case CatalogHomepageDetailsStatus.LOCAL:
                        this.homepageService.sendEventHideReplaceParentHomePageInfo();
                        this.currentHomePageName = this.homepageDetails.currentHomepageName;
                        this.showReplaceLabel = true;
                        break;
                }
            }
            else {
                this.homepageService.sendEventHideReplaceParentHomePageInfo();
                this.showReplaceLabel = false;
            }
        });
    }
    getTranslatedNames(name, secondName) {
        return Promise.all([
            this.l10n.transform(name).pipe(operators.take(1)).toPromise(),
            this.l10n.transform(secondName).pipe(operators.take(1)).toPromise()
        ]);
    }
    getResults() {
        const result = {
            homepage: this.homepage,
            isPrimary: this.conditionSelected && this.conditionSelected.isPrimary,
            primaryPage: null
        };
        if (this.conditionSelected && !this.conditionSelected.isPrimary) {
            result.primaryPage = this.primarySelected;
        }
        return result;
    }
    getSelectedPrimaryPageAndDisplayCondition() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pageTypeCode) {
                try {
                    if (this.pageUuid) {
                        const page = yield this.pageService.getPageByUuid(this.pageUuid);
                        const primaryPage = yield (!page.defaultPage
                            ? this.pageService.getPrimaryPage(page.uid)
                            : page);
                        this.setPrimarySelected(primaryPage);
                    }
                }
                catch (error) {
                    this.logService.error(error);
                }
                finally {
                    this.getAllPrimaryDisplayCondition();
                }
            }
            else {
                this.getAllPrimaryDisplayCondition();
            }
        });
    }
    getAllPrimaryDisplayCondition() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.pageDisplayConditions.getNewPageConditions(this.pageTypeCode, this.uriContext);
                if (!response.length) {
                    return;
                }
                this.conditions = response;
                this.conditionSelected = this.conditions[0];
                if (this.conditions.length > 1) {
                    this.conditionSelected = this.conditions.find((condition) => condition.label === this.initialConditionSelectedKey);
                }
                this.isReady = true;
            }
            catch (error) {
                this.logService.error(error);
            }
            finally {
                if (this.targetCatalogVersion &&
                    !this.isUriContextEqualToCatalogVersion(this.uriContext, this.targetCatalogVersion)) {
                    this.getOnlyPrimaryDisplayCondition();
                }
                else {
                    this.dataChanged();
                }
            }
        });
    }
    getOnlyPrimaryDisplayCondition() {
        this.conditions = [
            {
                description: 'page.displaycondition.primary.description',
                isPrimary: true,
                label: 'page.displaycondition.primary'
            }
        ];
        this.conditionSelected = this.conditions[0];
        this.isReady = true;
        this.dataChanged();
    }
    isUriContextEqualToCatalogVersion(uriContext, catalogVersion) {
        return (uriContext &&
            catalogVersion &&
            catalogVersion.siteId === uriContext.CURRENT_CONTEXT_SITE_ID &&
            catalogVersion.catalogId === uriContext.CURRENT_CONTEXT_CATALOG &&
            catalogVersion.version === uriContext.CURRENT_CONTEXT_CATALOG_VERSION);
    }
    setPrimarySelected(page) {
        this.primarySelected = page;
        this.primarySelectedModel = page.uid;
    }
};
NewPageDisplayConditionComponent.$inject = ["urlService", "homepageService", "displayConditionsFacade", "translateService", "pageService", "logService", "pageDisplayConditions", "l10n", "cdr"];
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ NewPageDisplayConditionComponent.prototype, "pageTypeCode", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ NewPageDisplayConditionComponent.prototype, "uriContext", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ NewPageDisplayConditionComponent.prototype, "resultFn", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ NewPageDisplayConditionComponent.prototype, "pageUuid", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ NewPageDisplayConditionComponent.prototype, "initialConditionSelectedKey", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ NewPageDisplayConditionComponent.prototype, "targetCatalogVersion", void 0);
/* @ngInject */ NewPageDisplayConditionComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-new-page-display-condition',
        template: `<div *ngIf="isReady"><div class="form-group"><label for="page-condition-selector-id" class="se-control-label" translate="se.cms.page.condition.selection.label"></label><se-select id="page-condition-selector-id" [model]="conditionSelected.label" (modelChange)="onConditionChange($event)" [fetchStrategy]="conditionSelectorFetchStrategy" [onChange]="onDataChange" [searchEnabled]="false"></se-select><span class="se-form-help-message"><span [translate]="conditionSelected.description"></span></span></div><div *ngIf="showPrimarySelector()" class="form-group"><label for="page-condition-primary-selector-id" class="se-control-label" translate="se.cms.page.condition.primary.association.label"></label><se-select id="page-condition-primary-selector-id" [model]="primarySelectedModel" (modelChange)="primarySelectedModelOnChange($event)" [fetchStrategy]="primaryPageChoicesFetchStrategy" [onChange]="onDataChange"></se-select><span *ngIf="primarySelected?.label" class="se-form-help-message"><span>{{ 'se.cms.page.label.label' | translate }}: {{ primarySelected.label }}</span></span></div><div *ngIf="showHomePageWidget()"><div class="fd-form__item"><input type="checkbox" id="set-homepage-checkbox" class="se-component-item--details se-component-homepage__checkbox-input fd-form__control" name="clone-on-drop" (ngModelChange)="onHomePageChange($event)" [ngModel]="homepage"/> <label class="se-control-label se-component-homepage--label fd-form__label" for="set-homepage-checkbox" translate="se.cms.display.conditions.homepage.set"></label></div><label class="se-control-label se-component-homepage--label" for="set-homepage-checkbox" *ngIf="showReplaceLabel">{{ "se.cms.display.conditions.homepage.replace" | translate: { currentHomepage: currentHomePageName } }}</label></div></div>`,
        styles: [`.se-component-homepage__checkbox-input{margin:0 4px 0 0;outline:0;box-shadow:none}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush,
        providers: [smarteditcommons.L10nPipe]
    }),
    __metadata("design:paramtypes", [smarteditcommons.IUrlService,
        exports.HomepageService,
        DisplayConditionsFacade,
        core$1.TranslateService,
        smarteditcommons.IPageService,
        smarteditcommons.LogService,
        exports.PageDisplayConditionsService,
        smarteditcommons.L10nPipe,
        core.ChangeDetectorRef])
], /* @ngInject */ NewPageDisplayConditionComponent);

window.__smartedit__.addDecoratorPayload("Component", "SelectPageTemplateComponent", {
    selector: 'se-select-page-template',
    template: `<div class="se-page-type-step-template"><div class="se-add-page__sub-header"><div class="se-add-page__sub-header-title">{{ 'se.cms.addpagewizard.pagetemplate.description' | translate }}</div><div class="se-input-group se-page-type-step-template-list-search"><input type="text" class="se-input-group__input-area ySEPage-list-search-input" placeholder="{{ 'se.cms.pagewizard.templatestep.searchplaceholder' | translate }}" [ngModel]="searchString" (ngModelChange)="onSearchChange($event)" name="query"/> <span class="sap-icon--search se-input-group__addon"></span><div *ngIf="searchString" class="se-input-group__addon se-input-group__clear-btn" (click)="clearSearch()"><span class="sap-icon--decline"></span></div></div></div><div class="se-add-page__list fd-menu" *ngIf="pageTemplates.length > 0"><div *ngFor="let template of filteredPageTemplates" [ngClass]="{ 'is-selected': isSelected(template)}" (click)="templateSelected(template)" class="se-add-page__item se-add-page__item--page-template fd-menu__item"><div class="se-add-page__item-title">{{ template.name }}</div></div></div></div>`,
    styles: [`.se-add-page__sub-header{padding-bottom:16px;color:#51555a}.se-add-page__sub-header-title{margin-bottom:8px}.se-add-page__list.fd-menu{border-top:1px solid #d9d9d9;padding:0}.se-add-page__item{cursor:pointer}.se-add-page__item--page-template{height:48px;display:flex;flex-direction:row;align-items:center}.se-add-page__item-title{font-weight:700}.se-add-page__item-description{white-space:normal}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ SelectPageTemplateComponent = class /* @ngInject */ SelectPageTemplateComponent {
    constructor(pageTemplateService, cdr) {
        this.pageTemplateService = pageTemplateService;
        this.cdr = cdr;
        this.searchString = '';
        this.onTemplateSelected = new core.EventEmitter();
        this.cache = {};
        this.pageTemplates = [];
    }
    ngOnChanges(changes) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = changes.pageTypeCode) === null || _a === void 0 ? void 0 : _a.currentValue) {
                yield this.onInputUpdated();
                this.setDefaultFilteredPageTemplates();
                if (!this.cdr.destroyed) {
                    this.cdr.detectChanges();
                }
            }
        });
    }
    templateSelected(pageTemplate) {
        this.selectedTemplate = pageTemplate;
        this.onTemplateSelected.emit(pageTemplate);
    }
    isSelected(pageTemplate) {
        var _a;
        return pageTemplate.uid === ((_a = this.selectedTemplate) === null || _a === void 0 ? void 0 : _a.uid);
    }
    clearSearch() {
        this.searchString = '';
        this.setDefaultFilteredPageTemplates();
    }
    onSearchChange(value) {
        this.searchString = value;
        this.filterByQuery(this.searchString);
    }
    onInputUpdated() {
        return __awaiter(this, void 0, void 0, function* () {
            this.clearSearch();
            this.selectedTemplate = null;
            return this.setPageTemplates();
        });
    }
    setPageTemplates() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.cache[this.pageTypeCode]) {
                this.pageTemplates = this.cache[this.pageTypeCode];
                return;
            }
            this.pageTemplates = [];
            const pageTemplates = yield this.pageTemplateService.getPageTemplatesForType(this.uriContext, this.pageTypeCode);
            this.cache[this.pageTypeCode] = pageTemplates.templates;
            this.pageTemplates = this.cache[this.pageTypeCode];
        });
    }
    filterByQuery(query) {
        if (!query) {
            this.setDefaultFilteredPageTemplates();
            return;
        }
        this.filteredPageTemplates = this.pageTemplates.filter((template) => {
            const terms = query.split(' ');
            return terms.every((term) => template.name.toLowerCase().includes(term.toLowerCase()));
        });
    }
    setDefaultFilteredPageTemplates() {
        this.filteredPageTemplates = [...this.pageTemplates];
    }
};
SelectPageTemplateComponent.$inject = ["pageTemplateService", "cdr"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ SelectPageTemplateComponent.prototype, "uriContext", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ SelectPageTemplateComponent.prototype, "pageTypeCode", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ SelectPageTemplateComponent.prototype, "onTemplateSelected", void 0);
/* @ngInject */ SelectPageTemplateComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-select-page-template',
        template: `<div class="se-page-type-step-template"><div class="se-add-page__sub-header"><div class="se-add-page__sub-header-title">{{ 'se.cms.addpagewizard.pagetemplate.description' | translate }}</div><div class="se-input-group se-page-type-step-template-list-search"><input type="text" class="se-input-group__input-area ySEPage-list-search-input" placeholder="{{ 'se.cms.pagewizard.templatestep.searchplaceholder' | translate }}" [ngModel]="searchString" (ngModelChange)="onSearchChange($event)" name="query"/> <span class="sap-icon--search se-input-group__addon"></span><div *ngIf="searchString" class="se-input-group__addon se-input-group__clear-btn" (click)="clearSearch()"><span class="sap-icon--decline"></span></div></div></div><div class="se-add-page__list fd-menu" *ngIf="pageTemplates.length > 0"><div *ngFor="let template of filteredPageTemplates" [ngClass]="{ 'is-selected': isSelected(template)}" (click)="templateSelected(template)" class="se-add-page__item se-add-page__item--page-template fd-menu__item"><div class="se-add-page__item-title">{{ template.name }}</div></div></div></div>`,
        styles: [`.se-add-page__sub-header{padding-bottom:16px;color:#51555a}.se-add-page__sub-header-title{margin-bottom:8px}.se-add-page__list.fd-menu{border-top:1px solid #d9d9d9;padding:0}.se-add-page__item{cursor:pointer}.se-add-page__item--page-template{height:48px;display:flex;flex-direction:row;align-items:center}.se-add-page__item-title{font-weight:700}.se-add-page__item-description{white-space:normal}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [exports.PageTemplateService, core.ChangeDetectorRef])
], /* @ngInject */ SelectPageTemplateComponent);

window.__smartedit__.addDecoratorPayload("Component", "SelectPageTypeComponent", {
    selector: 'se-select-page-type',
    template: `<div><div class="se-add-page__sub-header">{{ 'se.cms.addpagewizard.pagetype.description' | translate }}</div><div class="se-add-page__list fd-menu" *ngIf="pageTypes.length > 0"><div class="se-add-page__item fd-menu__item" *ngFor="let pageType of pageTypes" [ngClass]="{ 'is-selected': isSelected(pageType)}" (click)="selectType(pageType)"><div class="se-add-page__item-title">{{ pageType.name | seL10n | async }}</div><div class="se-add-page__item-description">{{ pageType.description | seL10n | async }}</div></div></div></div>`,
    styles: [`.se-add-page__sub-header{padding-bottom:16px;color:#51555a}.se-add-page__sub-header-title{margin-bottom:8px}.se-add-page__list.fd-menu{border-top:1px solid #d9d9d9;padding:0}.se-add-page__item{cursor:pointer}.se-add-page__item--page-template{height:48px;display:flex;flex-direction:row;align-items:center}.se-add-page__item-title{font-weight:700}.se-add-page__item-description{white-space:normal}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ SelectPageTypeComponent = class /* @ngInject */ SelectPageTypeComponent {
    constructor(pageTypeService, typePermissionsRestService, cdr) {
        this.pageTypeService = pageTypeService;
        this.typePermissionsRestService = typePermissionsRestService;
        this.cdr = cdr;
        this.onTypeSelected = new core.EventEmitter();
        this.pageTypes = [];
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loadPageTypes();
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    selectType(pageType) {
        this.onTypeSelected.emit(pageType);
    }
    isSelected(pageType) {
        return pageType.code === this.pageTypeCode;
    }
    loadPageTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            const pageTypes = yield this.pageTypeService.getPageTypes();
            const allPageTypeCodes = pageTypes.map((pageType) => pageType.code);
            const createPermissionResult = yield this.typePermissionsRestService.hasCreatePermissionForTypes(allPageTypeCodes);
            this.pageTypes = pageTypes.filter((pageType) => createPermissionResult[pageType.code]);
        });
    }
};
SelectPageTypeComponent.$inject = ["pageTypeService", "typePermissionsRestService", "cdr"];
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ SelectPageTypeComponent.prototype, "pageTypeCode", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ SelectPageTypeComponent.prototype, "onTypeSelected", void 0);
/* @ngInject */ SelectPageTypeComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-select-page-type',
        template: `<div><div class="se-add-page__sub-header">{{ 'se.cms.addpagewizard.pagetype.description' | translate }}</div><div class="se-add-page__list fd-menu" *ngIf="pageTypes.length > 0"><div class="se-add-page__item fd-menu__item" *ngFor="let pageType of pageTypes" [ngClass]="{ 'is-selected': isSelected(pageType)}" (click)="selectType(pageType)"><div class="se-add-page__item-title">{{ pageType.name | seL10n | async }}</div><div class="se-add-page__item-description">{{ pageType.description | seL10n | async }}</div></div></div></div>`,
        styles: [`.se-add-page__sub-header{padding-bottom:16px;color:#51555a}.se-add-page__sub-header-title{margin-bottom:8px}.se-add-page__list.fd-menu{border-top:1px solid #d9d9d9;padding:0}.se-add-page__item{cursor:pointer}.se-add-page__item--page-template{height:48px;display:flex;flex-direction:row;align-items:center}.se-add-page__item-title{font-weight:700}.se-add-page__item-description{white-space:normal}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [PageTypeService,
        cmscommons.TypePermissionsRestService,
        core.ChangeDetectorRef])
], /* @ngInject */ SelectPageTypeComponent);

window.__smartedit__.addDecoratorPayload("Component", "SelectTargetCatalogVersionComponent", {
    selector: 'se-select-target-catalog-version',
    template: `<div class="target-catalog-version-selector-wrapper form-group"><label for="se-catalog-version-selector-dropdown" class="se-control-label" translate="se.cms.clonepagewizard.options.targetcatalogversion.label"></label><se-select *ngIf="!!catalogVersions.length" id="se-catalog-version-selector-dropdown" [(model)]="selectedCatalogVersion" [fetchStrategy]="catalogVersionSelectorFetchStrategy" [onChange]="onSelectionChange" [searchEnabled]="false" (getApi)="setSelectApi($event)"></se-select><div *ngIf="catalogVersionContainsPageWithSameLabel"><span class="help-block" translate="se.cms.clonepagewizard.options.targetcatalogversion.label.exists.message"></span></div></div>`,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ SelectTargetCatalogVersionComponent = class /* @ngInject */ SelectTargetCatalogVersionComponent {
    constructor(pageFacade, catalogVersionRestService, catalogService, pageService, cdr) {
        this.pageFacade = pageFacade;
        this.catalogVersionRestService = catalogVersionRestService;
        this.catalogService = catalogService;
        this.pageService = pageService;
        this.cdr = cdr;
        this.catalogVersions = [];
        this.selectedCatalogVersion = null;
        this.catalogVersionContainsPageWithSameLabel = false;
        this.onTargetCatalogVersionSelected = new core.EventEmitter();
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.catalogVersionSelectorFetchStrategy = {
                fetchAll: () => Promise.resolve((this.catalogVersions || []).map((catalogVersion) => ({
                    id: catalogVersion.uuid,
                    label: catalogVersion.name
                })))
            };
            this.onSelectionChange = () => this.selectionChangeHandler();
            yield this.setupCatalogVersions();
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    setSelectApi(api) {
        this.selectApi = api;
    }
    setupCatalogVersions() {
        return __awaiter(this, void 0, void 0, function* () {
            const targets = yield this.catalogVersionRestService.getCloneableTargets(this.uriContext);
            const catalogVersions = targets.versions;
            if (!lodash.isEmpty(catalogVersions)) {
                const uuid = yield this.catalogService.getCatalogVersionUUid(this.uriContext);
                const currentCatalogVersion = catalogVersions.find((catalogVersion) => catalogVersion.uuid === uuid);
                if (currentCatalogVersion) {
                    this.selectedCatalogVersion = currentCatalogVersion.uuid;
                }
                else {
                    this.selectedCatalogVersion = catalogVersions[0].uuid;
                }
                this.catalogVersions = catalogVersions;
            }
        });
    }
    selectionChangeHandler() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.selectedCatalogVersion) {
                return;
            }
            const catalogVersion = yield this.catalogService.getCatalogVersionByUuid(this.selectedCatalogVersion);
            this.onTargetCatalogVersionSelected.emit(catalogVersion);
            if (this.pageTypeCode === 'ContentPage') {
                this.catalogVersionContainsPageWithSameLabel = yield this.determineContentPageWithLabelExists(catalogVersion);
            }
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
            this.updateSelectValidationState();
        });
    }
    determineContentPageWithLabelExists(catalogVersion) {
        return this.pageFacade.contentPageWithLabelExists(this.pageLabel, catalogVersion.catalogId, catalogVersion.version);
    }
    updateSelectValidationState() {
        if (!this.selectApi) {
            return;
        }
        if (this.catalogVersionContainsPageWithSameLabel) {
            this.selectApi.setValidationState(smarteditcommons.VALIDATION_MESSAGE_TYPES.WARNING);
        }
        else {
            this.selectApi.resetValidationState();
        }
    }
};
SelectTargetCatalogVersionComponent.$inject = ["pageFacade", "catalogVersionRestService", "catalogService", "pageService", "cdr"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ SelectTargetCatalogVersionComponent.prototype, "uriContext", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ SelectTargetCatalogVersionComponent.prototype, "pageTypeCode", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ SelectTargetCatalogVersionComponent.prototype, "pageLabel", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ SelectTargetCatalogVersionComponent.prototype, "onTargetCatalogVersionSelected", void 0);
/* @ngInject */ SelectTargetCatalogVersionComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-select-target-catalog-version',
        template: `<div class="target-catalog-version-selector-wrapper form-group"><label for="se-catalog-version-selector-dropdown" class="se-control-label" translate="se.cms.clonepagewizard.options.targetcatalogversion.label"></label><se-select *ngIf="!!catalogVersions.length" id="se-catalog-version-selector-dropdown" [(model)]="selectedCatalogVersion" [fetchStrategy]="catalogVersionSelectorFetchStrategy" [onChange]="onSelectionChange" [searchEnabled]="false" (getApi)="setSelectApi($event)"></se-select><div *ngIf="catalogVersionContainsPageWithSameLabel"><span class="help-block" translate="se.cms.clonepagewizard.options.targetcatalogversion.label.exists.message"></span></div></div>`,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [PageFacade,
        CatalogVersionRestService,
        smarteditcommons.ICatalogService,
        smarteditcommons.IPageService,
        core.ChangeDetectorRef])
], /* @ngInject */ SelectTargetCatalogVersionComponent);

class ClonePageBuilder {
    constructor(restrictionsStepHandler, basePageUUID, uriContext, contextAwarePageStructureService, typeStructureRestService, cmsitemsRestService, catalogService, pageInfoService) {
        this.restrictionsStepHandler = restrictionsStepHandler;
        this.basePageUUID = basePageUUID;
        this.uriContext = uriContext;
        this.contextAwarePageStructureService = contextAwarePageStructureService;
        this.typeStructureRestService = typeStructureRestService;
        this.cmsitemsRestService = cmsitemsRestService;
        this.catalogService = catalogService;
        this.pageInfoService = pageInfoService;
        this.basePage = {};
        this.pageData = {};
        this.pageInfoStructure = {};
        this.basePageInfoAvailable = false;
        this.componentCloneOption = '';
    }
    getPageTypeCode() {
        return this.pageData.typeCode;
    }
    getPageTemplate() {
        return this.pageData.template;
    }
    getPageLabel() {
        return this.pageData.label;
    }
    getBasePageUuid() {
        return this.basePage.uuid;
    }
    getPageInfo() {
        return this.pageData;
    }
    getBasePageInfo() {
        return this.basePage;
    }
    getPageProperties() {
        return {
            type: this.pageData.type,
            typeCode: this.pageData.typeCode,
            template: this.pageData.template,
            onlyOneRestrictionMustApply: this.pageData.onlyOneRestrictionMustApply,
            catalogVersion: this.pageData.catalogVersion
        };
    }
    getPageInfoStructure() {
        return this.pageInfoStructure;
    }
    getPageRestrictions() {
        return this.pageData.restrictions || [];
    }
    getComponentCloneOption() {
        return this.componentCloneOption;
    }
    displayConditionSelected(displayConditionResult) {
        return __awaiter(this, void 0, void 0, function* () {
            const isPrimaryPage = displayConditionResult.isPrimary;
            this.pageData.defaultPage = isPrimaryPage;
            this.pageData.homepage = displayConditionResult.homepage;
            if (isPrimaryPage) {
                this.pageData.label = this.basePage.label;
                if (this.pageData.restrictions) {
                    delete this.pageData.restrictions;
                }
                this.restrictionsStepHandler.hideStep();
            }
            else {
                this.pageData.label = displayConditionResult.primaryPage
                    ? displayConditionResult.primaryPage.label
                    : '';
                this.restrictionsStepHandler.showStep();
            }
            this.pageData.uid = '';
            yield this.updatePageInfoFields();
        });
    }
    onTargetCatalogVersionSelected(targetCatalogVersion) {
        this.targetCatalogVersion = targetCatalogVersion;
        this.pageData.catalogVersion = targetCatalogVersion.uuid;
    }
    componentCloneOptionSelected(cloneOptionResult) {
        this.componentCloneOption = cloneOptionResult;
    }
    restrictionsSelected(onlyOneRestrictionMustApply, restrictions) {
        this.pageData.onlyOneRestrictionMustApply = onlyOneRestrictionMustApply;
        this.pageData.restrictions = restrictions;
    }
    getTargetCatalogVersion() {
        return this.targetCatalogVersion;
    }
    isBasePageInfoAvailable() {
        return this.basePageInfoAvailable;
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            const pageUUID = yield this.getPageUUID(this.basePageUUID);
            const uuid = yield this.catalogService.getCatalogVersionUUid(this.uriContext);
            const page = yield this.cmsitemsRestService.getById(pageUUID);
            this.basePage = lodash.cloneDeep(page);
            this.pageData = lodash.cloneDeep(this.basePage);
            this.pageData.catalogVersion = uuid;
            this.pageData.pageUuid = this.basePage.uuid;
            delete this.pageData.uuid;
            this.basePageInfoAvailable = true;
            this.pageData.template = this.basePage.masterTemplateId;
            const structure = (yield this.typeStructureRestService.getStructureByTypeAndMode(this.pageData.typeCode, 'DEFAULT', true));
            this.pageData.type = structure.type;
        });
    }
    getPageUUID(pageUUID) {
        return __awaiter(this, void 0, void 0, function* () {
            return !smarteditcommons.stringUtils.isBlank(pageUUID) ? pageUUID : this.pageInfoService.getPageUUID();
        });
    }
    updatePageInfoFields() {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.pageData.defaultPage === 'undefined') {
                return;
            }
            if (this.pageData.typeCode) {
                const pageInfoFields = yield this.contextAwarePageStructureService.getPageStructureForNewPage(this.pageData.typeCode, this.pageData.defaultPage);
                this.pageInfoStructure = pageInfoFields;
            }
            else {
                this.pageInfoStructure = {};
            }
        });
    }
}
let /* @ngInject */ ClonePageBuilderFactory = class /* @ngInject */ ClonePageBuilderFactory {
    constructor(contextAwarePageStructureService, typeStructureRestService, cmsitemsRestService, catalogService, pageInfoService, pageService) {
        this.contextAwarePageStructureService = contextAwarePageStructureService;
        this.typeStructureRestService = typeStructureRestService;
        this.cmsitemsRestService = cmsitemsRestService;
        this.catalogService = catalogService;
        this.pageInfoService = pageInfoService;
        this.pageService = pageService;
    }
    createClonePageBuilder(restrictionsStepHandler, basePageUUID, uriContext) {
        return new ClonePageBuilder(restrictionsStepHandler, basePageUUID, uriContext, this.contextAwarePageStructureService, this.typeStructureRestService, this.cmsitemsRestService, this.catalogService, this.pageInfoService);
    }
};
ClonePageBuilderFactory.$inject = ["contextAwarePageStructureService", "typeStructureRestService", "cmsitemsRestService", "catalogService", "pageInfoService", "pageService"];
/* @ngInject */ ClonePageBuilderFactory = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [exports.ContextAwarePageStructureService,
        TypeStructureRestService,
        smarteditcommons.CmsitemsRestService,
        smarteditcommons.ICatalogService,
        smarteditcommons.IPageInfoService,
        smarteditcommons.IPageService])
], /* @ngInject */ ClonePageBuilderFactory);

window.__smartedit__.addDecoratorPayload("Component", "ClonePageOptionsStepComponent", {
    selector: 'se-clone-page-options-step',
    template: `
        <se-event-message
            class="existing-homepage__ymessage"
            [showEvent]="'CMS_EVENT_SHOW_REPLACE_PARENT_HOMEPAGE_INFO'"
            [hideEvent]="'CMS_EVENT_HIDE_REPLACE_PARENT_HOMEPAGE_INFO'"
        >
        </se-event-message>

        <se-select-target-catalog-version
            *ngIf="wizardApi.isBasePageInfoAvailable()"
            [pageTypeCode]="wizardApi.getPageTypeCode()"
            [pageLabel]="wizardApi.getPageLabel()"
            [uriContext]="wizardApi.uriContext"
            (onTargetCatalogVersionSelected)="wizardApi.onTargetCatalogVersionSelected($event)"
        >
        </se-select-target-catalog-version>
        <se-new-page-display-condition
            [pageTypeCode]="wizardApi.getPageTypeCode()"
            [uriContext]="wizardApi.uriContext"
            [resultFn]="wizardApi.variationResult"
            [initialConditionSelectedKey]="'page.displaycondition.variation'"
            [pageUuid]="wizardApi.getBasePageUuid()"
            [targetCatalogVersion]="wizardApi.getTargetCatalogVersion()"
        >
        </se-new-page-display-condition>

        <se-component-clone-option-form
            (onSelectionChange)="wizardApi.triggerUpdateCloneOptionResult($event)"
        ></se-component-clone-option-form>
    `
});
let /* @ngInject */ ClonePageOptionsStepComponent = class /* @ngInject */ ClonePageOptionsStepComponent {
    constructor(wizardApi) {
        this.wizardApi = wizardApi;
    }
};
ClonePageOptionsStepComponent.$inject = ["wizardApi"];
/* @ngInject */ ClonePageOptionsStepComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-clone-page-options-step',
        template: `
        <se-event-message
            class="existing-homepage__ymessage"
            [showEvent]="'CMS_EVENT_SHOW_REPLACE_PARENT_HOMEPAGE_INFO'"
            [hideEvent]="'CMS_EVENT_HIDE_REPLACE_PARENT_HOMEPAGE_INFO'"
        >
        </se-event-message>

        <se-select-target-catalog-version
            *ngIf="wizardApi.isBasePageInfoAvailable()"
            [pageTypeCode]="wizardApi.getPageTypeCode()"
            [pageLabel]="wizardApi.getPageLabel()"
            [uriContext]="wizardApi.uriContext"
            (onTargetCatalogVersionSelected)="wizardApi.onTargetCatalogVersionSelected($event)"
        >
        </se-select-target-catalog-version>
        <se-new-page-display-condition
            [pageTypeCode]="wizardApi.getPageTypeCode()"
            [uriContext]="wizardApi.uriContext"
            [resultFn]="wizardApi.variationResult"
            [initialConditionSelectedKey]="'page.displaycondition.variation'"
            [pageUuid]="wizardApi.getBasePageUuid()"
            [targetCatalogVersion]="wizardApi.getTargetCatalogVersion()"
        >
        </se-new-page-display-condition>

        <se-component-clone-option-form
            (onSelectionChange)="wizardApi.triggerUpdateCloneOptionResult($event)"
        ></se-component-clone-option-form>
    `
    }),
    __param(0, core.Inject(smarteditcommons.WIZARD_API)),
    __metadata("design:paramtypes", [Object])
], /* @ngInject */ ClonePageOptionsStepComponent);

window.__smartedit__.addDecoratorPayload("Component", "ClonePageRestrictionsStepComponent", {
    selector: 'se-clone-page-options-step',
    template: `
        <span *ngIf="wizardApi.isRestrictionsActive()" class="se-clone-page-restriction-step">
            <div *ngIf="wizardApi.getPageRestrictions().length > 1">
                <se-page-restrictions-info-message></se-page-restrictions-info-message>
            </div>

            <se-restrictions-editor
                [editable]="true"
                [(resetFn)]="wizardApi.restrictionsEditorFunctionBindings.reset"
                [(cancelFn)]="wizardApi.restrictionsEditorFunctionBindings.cancel"
                [(isDirtyFn)]="wizardApi.restrictionsEditorFunctionBindings.isDirty"
                (onRestrictionsChange)="wizardApi.restrictionsResult($event)"
                [getRestrictionTypes]="wizardApi.getRestrictionTypes"
                [getSupportedRestrictionTypes]="wizardApi.getSupportedRestrictionTypes"
                [item]="wizardApi.getBasePageInfo()"
                [restrictionUuids]="wizardApi.getPageRestrictions()"
            >
            </se-restrictions-editor>
        </span>
    `
});
let /* @ngInject */ ClonePageRestrictionsStepComponent = class /* @ngInject */ ClonePageRestrictionsStepComponent {
    constructor(wizardApi) {
        this.wizardApi = wizardApi;
    }
};
ClonePageRestrictionsStepComponent.$inject = ["wizardApi"];
/* @ngInject */ ClonePageRestrictionsStepComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-clone-page-options-step',
        template: `
        <span *ngIf="wizardApi.isRestrictionsActive()" class="se-clone-page-restriction-step">
            <div *ngIf="wizardApi.getPageRestrictions().length > 1">
                <se-page-restrictions-info-message></se-page-restrictions-info-message>
            </div>

            <se-restrictions-editor
                [editable]="true"
                [(resetFn)]="wizardApi.restrictionsEditorFunctionBindings.reset"
                [(cancelFn)]="wizardApi.restrictionsEditorFunctionBindings.cancel"
                [(isDirtyFn)]="wizardApi.restrictionsEditorFunctionBindings.isDirty"
                (onRestrictionsChange)="wizardApi.restrictionsResult($event)"
                [getRestrictionTypes]="wizardApi.getRestrictionTypes"
                [getSupportedRestrictionTypes]="wizardApi.getSupportedRestrictionTypes"
                [item]="wizardApi.getBasePageInfo()"
                [restrictionUuids]="wizardApi.getPageRestrictions()"
            >
            </se-restrictions-editor>
        </span>
    `
    }),
    __param(0, core.Inject(smarteditcommons.WIZARD_API)),
    __metadata("design:paramtypes", [Object])
], /* @ngInject */ ClonePageRestrictionsStepComponent);

window.__smartedit__.addDecoratorPayload("Component", "ClonePageInfoStepComponent", {
    selector: 'se-clone-page-info-step',
    template: `
        <se-component-clone-info-form
            *ngIf="wizardApi.isPageInfoActive()"
            [structure]="wizardApi.getPageInfoStructure()"
            [content]="wizardApi.getPageInfo()"
            [(submit)]="wizardApi.callbacks.savePageInfo"
            [(reset)]="wizardApi.callbacks.resetPageInfo"
            [(isDirty)]="wizardApi.callbacks.isDirtyPageInfo"
            [(isValid)]="wizardApi.callbacks.isValidPageInfo"
            [pageTemplate]="wizardApi.getPageTemplate()"
            [pageTypeCode]="wizardApi.getPageTypeCode()"
            [uriContext]="wizardApi.uriContext"
            [targetCatalogVersion]="wizardApi.getTargetCatalogVersion()"
        >
        </se-component-clone-info-form>
    `
});
let /* @ngInject */ ClonePageInfoStepComponent = class /* @ngInject */ ClonePageInfoStepComponent {
    constructor(wizardApi) {
        this.wizardApi = wizardApi;
    }
};
ClonePageInfoStepComponent.$inject = ["wizardApi"];
/* @ngInject */ ClonePageInfoStepComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-clone-page-info-step',
        template: `
        <se-component-clone-info-form
            *ngIf="wizardApi.isPageInfoActive()"
            [structure]="wizardApi.getPageInfoStructure()"
            [content]="wizardApi.getPageInfo()"
            [(submit)]="wizardApi.callbacks.savePageInfo"
            [(reset)]="wizardApi.callbacks.resetPageInfo"
            [(isDirty)]="wizardApi.callbacks.isDirtyPageInfo"
            [(isValid)]="wizardApi.callbacks.isValidPageInfo"
            [pageTemplate]="wizardApi.getPageTemplate()"
            [pageTypeCode]="wizardApi.getPageTypeCode()"
            [uriContext]="wizardApi.uriContext"
            [targetCatalogVersion]="wizardApi.getTargetCatalogVersion()"
        >
        </se-component-clone-info-form>
    `
    }),
    __param(0, core.Inject(smarteditcommons.WIZARD_API)),
    __metadata("design:paramtypes", [Object])
], /* @ngInject */ ClonePageInfoStepComponent);

window.__smartedit__.addDecoratorPayload("Component", "ClonePageWizardComponent", {
    selector: 'se-clone-page-wizard',
    template: ''
});
let /* @ngInject */ ClonePageWizardComponent = class /* @ngInject */ ClonePageWizardComponent {
    constructor(wizardManager, clonePageBuilderFactory, restrictionsStepHandlerFactory, experienceService, confirmationModalService, systemEventService, restrictionTypesService, restrictionsService, sharedDataService, clonePageAlertService, alertService, pageFacade, syncPollingService) {
        this.wizardManager = wizardManager;
        this.clonePageBuilderFactory = clonePageBuilderFactory;
        this.restrictionsStepHandlerFactory = restrictionsStepHandlerFactory;
        this.experienceService = experienceService;
        this.confirmationModalService = confirmationModalService;
        this.systemEventService = systemEventService;
        this.restrictionTypesService = restrictionTypesService;
        this.restrictionsService = restrictionsService;
        this.sharedDataService = sharedDataService;
        this.clonePageAlertService = clonePageAlertService;
        this.alertService = alertService;
        this.pageFacade = pageFacade;
        this.syncPollingService = syncPollingService;
        // Enumerable methods
        // This way of defining method creates a public field in class instead of prototype method
        // which allows then to be reassigned/extended in ModalWizardTemplateComponent#assignAngularController
        this.getWizardConfig = () => ({
            isFormValid: (stepId) => this.isFormValid(stepId),
            onNext: () => this.onNext(),
            onDone: () => this.onDone(),
            onCancel: () => this.onCancel(),
            steps: [
                {
                    id: this.CLONE_PAGE_WIZARD_STEPS.PAGE_CLONE_OPTIONS,
                    name: 'se.cms.clonepagewizard.pagecloneoptions.tabname',
                    title: 'se.cms.clonepagewizard.pageclone.title',
                    component: ClonePageOptionsStepComponent
                },
                {
                    id: this.CLONE_PAGE_WIZARD_STEPS.PAGE_INFO,
                    name: 'se.cms.clonepagewizard.pageinfo.tabname',
                    title: 'se.cms.clonepagewizard.pageclone.title',
                    component: ClonePageInfoStepComponent
                }
            ]
        });
        this.getRestrictionTypes = () => this.restrictionTypesService.getRestrictionTypesByPageType(this.getPageTypeCode());
        this.getSupportedRestrictionTypes = () => this.restrictionsService.getSupportedRestrictionTypeCodes();
        this.variationResult = (displayConditionResult) => {
            this.infoChanged = true;
            this.pageBuilder.displayConditionSelected(displayConditionResult);
        };
        this.basePageUUID = this.wizardManager.properties.basePageUUID;
        this.callbacks = {};
        this.uriContext = this.wizardManager.properties.uriContext;
        this.restrictionStepProperties = {
            id: 'restrictionsStepId',
            name: 'se.cms.restrictions.editor.tab',
            title: 'se.cms.clonepagewizard.pageclone.title',
            component: ClonePageRestrictionsStepComponent
        };
        // bound in the view for restrictions step
        const restrictionsEditorFunctionBindingsClosure = {};
        this.restrictionsEditorFunctionBindings = restrictionsEditorFunctionBindingsClosure;
        this.cloneInProgress = false;
        this.infoChanged = true;
        this.typeChanged = true;
        this.restrictionsStepHandler = this.restrictionsStepHandlerFactory.createRestrictionsStepHandler(this.wizardManager, this.restrictionsEditorFunctionBindings, this.restrictionStepProperties);
        this.pageBuilder = this.clonePageBuilderFactory.createClonePageBuilder(this.restrictionsStepHandler, this.basePageUUID, this.uriContext);
        this.pageBuilder.init();
        this.CLONE_PAGE_WIZARD_STEPS = {
            PAGE_CLONE_OPTIONS: 'cloneOptions',
            PAGE_INFO: 'pageInfo',
            PAGE_RESTRICTIONS: this.restrictionStepProperties.id
        };
    }
    // Class Methods
    getPageTypeCode() {
        return this.pageBuilder.getPageTypeCode();
    }
    getPageLabel() {
        return this.pageBuilder.getPageLabel();
    }
    getBasePageUuid() {
        return this.pageBuilder.getBasePageUuid();
    }
    getPageTemplate() {
        return this.pageBuilder.getPageTemplate();
    }
    getPageInfo() {
        const page = this.pageBuilder.getPageInfo();
        page.uriContext = this.uriContext;
        return page;
    }
    getBasePageInfo() {
        const page = this.pageBuilder.getBasePageInfo();
        page.uriContext = this.uriContext;
        return page;
    }
    getPageRestrictions() {
        return this.pageBuilder.getPageRestrictions();
    }
    onTargetCatalogVersionSelected(catalogVersion) {
        this.pageBuilder.onTargetCatalogVersionSelected(catalogVersion);
    }
    triggerUpdateCloneOptionResult(cloneOptionResult) {
        this.pageBuilder.componentCloneOptionSelected(cloneOptionResult);
    }
    getPageInfoStructure() {
        return this.pageBuilder.getPageInfoStructure();
    }
    restrictionsResult(data) {
        this.pageBuilder.restrictionsSelected(data.onlyOneRestrictionMustApply, data.restrictionUuids);
    }
    isRestrictionsActive() {
        if (!this.typeChanged ||
            this.wizardManager.getCurrentStepId() === this.CLONE_PAGE_WIZARD_STEPS.PAGE_RESTRICTIONS) {
            this.typeChanged = false;
            return true;
        }
        return false;
    }
    isPageInfoActive() {
        if (!this.infoChanged ||
            this.wizardManager.getCurrentStepId() === this.CLONE_PAGE_WIZARD_STEPS.PAGE_INFO) {
            this.infoChanged = false;
            return true;
        }
        return false;
    }
    getTargetCatalogVersion() {
        return this.pageBuilder.getTargetCatalogVersion();
    }
    isBasePageInfoAvailable() {
        return this.pageBuilder.isBasePageInfoAvailable();
    }
    onCancel() {
        return this.confirmationModalService.confirm({
            description: 'se.editor.cancel.confirm'
        });
    }
    isFormValid(stepId) {
        switch (stepId) {
            case this.CLONE_PAGE_WIZARD_STEPS.PAGE_CLONE_OPTIONS:
                // This step has no required inputs. However we set the valid status as soon as the data is fetched
                // to avoid modal NEXT button enabled status to be true before content is actually loaded.
                return this.isBasePageInfoAvailable();
            case this.CLONE_PAGE_WIZARD_STEPS.PAGE_INFO:
                return (!this.cloneInProgress &&
                    !!this.callbacks.isValidPageInfo &&
                    this.callbacks.isValidPageInfo());
            case this.CLONE_PAGE_WIZARD_STEPS.PAGE_RESTRICTIONS:
                return !this.cloneInProgress && this.pageBuilder.getPageRestrictions().length > 0;
        }
        return false;
    }
    onNext() {
        return true;
    }
    onDone() {
        return __awaiter(this, void 0, void 0, function* () {
            this.cloneInProgress = true;
            try {
                const page = yield this.callbacks.savePageInfo();
                const payload = this.preparePagePayload(page);
                if (this.pageBuilder.getTargetCatalogVersion()) {
                    payload.siteId = this.pageBuilder.getTargetCatalogVersion().siteId;
                    payload.catalogId = this.pageBuilder.getTargetCatalogVersion().catalogId;
                    payload.version = this.pageBuilder.getTargetCatalogVersion().version;
                }
                const experience = (yield this.sharedDataService.get(smarteditcommons.EXPERIENCE_STORAGE_KEY));
                yield this.createPage(payload, experience);
            }
            catch (_a) {
                // re-enable the button
                this.cloneInProgress = false;
                // prevent closing modal when there's an error
                return Promise.reject();
            }
        });
    }
    createPage(payload, experience) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.pageFacade.createPageForSite(payload, payload.siteId);
                this.syncPollingService.getSyncStatus(payload.pageUuid, this.uriContext, true);
                if (experience.catalogDescriptor.catalogVersionUuid === response.catalogVersion) {
                    this.experienceService.loadExperience({
                        siteId: payload.siteId,
                        catalogId: payload.catalogId,
                        catalogVersion: payload.version,
                        pageId: response.uid
                    });
                }
                else {
                    this.clonePageAlertService.displayClonePageAlert(response);
                }
                return this.alertService.showSuccess({
                    message: 'se.cms.clonepage.alert.success'
                });
            }
            catch (exception) {
                this.cloneInProgress = false; // re-enable the button
                this.systemEventService.publishAsync(smarteditcommons.GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT, {
                    messages: exception.error.errors
                });
                const errors = exception.error.errors;
                if (!errors.find((error) => error.subject.indexOf('restrictions') === 0)) {
                    this.wizardManager.goToStepWithId(this.CLONE_PAGE_WIZARD_STEPS.PAGE_INFO);
                }
                return Promise.reject();
            }
        });
    }
    preparePagePayload(page) {
        const newClonePage = lodash.cloneDeep(page);
        // set page info properties
        lodash.merge(newClonePage, this.pageBuilder.getPageProperties());
        // set clone option
        newClonePage.cloneComponents = this.pageBuilder.getComponentCloneOption() === 'clone';
        newClonePage.itemtype = page.typeCode;
        // set linkComponents to [].
        // As when clone page,
        // the link component should remain refer to old page.
        if (newClonePage.linkComponents && newClonePage.linkComponents.length > 0) {
            newClonePage.linkComponents = [];
        }
        if (this.isRestrictionsActive()) {
            // set restrictions
            newClonePage.restrictions = this.pageBuilder.getPageRestrictions();
        }
        return newClonePage;
    }
};
ClonePageWizardComponent.$inject = ["wizardManager", "clonePageBuilderFactory", "restrictionsStepHandlerFactory", "experienceService", "confirmationModalService", "systemEventService", "restrictionTypesService", "restrictionsService", "sharedDataService", "clonePageAlertService", "alertService", "pageFacade", "syncPollingService"];
/* @ngInject */ ClonePageWizardComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-clone-page-wizard',
        template: ''
    }),
    __param(0, core.Inject(smarteditcommons.WIZARD_MANAGER)),
    __metadata("design:paramtypes", [smarteditcommons.WizardService,
        ClonePageBuilderFactory,
        exports.RestrictionsStepHandlerFactory,
        smarteditcommons.IExperienceService,
        smarteditcommons.IConfirmationModalService,
        smarteditcommons.SystemEventService,
        exports.RestrictionTypesService,
        exports.RestrictionsService,
        smarteditcommons.ISharedDataService,
        exports.ClonePageAlertService,
        smarteditcommons.IAlertService,
        PageFacade,
        smarteditcommons.ISyncPollingService])
], /* @ngInject */ ClonePageWizardComponent);

let /* @ngInject */ ClonePageWizardService = class /* @ngInject */ ClonePageWizardService {
    constructor(modalWizard, catalogService, pageFacade) {
        this.modalWizard = modalWizard;
        this.catalogService = catalogService;
        this.pageFacade = pageFacade;
    }
    /**
     * When called, this method opens a modal window containing a wizard to clone an existing page.
     *
     * @param pageData An object containing the pageData when the clone page wizard is opened from the page list.
     * @returns A promise that will resolve when the modal wizard is closed or reject if it's canceled.
     *
     */
    openClonePageWizard(pageData) {
        return __awaiter(this, void 0, void 0, function* () {
            const uriContext = pageData
                ? yield this.catalogService.retrieveUriContext()
                : yield this.pageFacade.retrievePageUriContext();
            return this.modalWizard.open({
                component: ClonePageWizardComponent,
                properties: {
                    uriContext,
                    basePageUUID: pageData ? pageData.uuid : undefined
                }
            });
        });
    }
};
ClonePageWizardService.$inject = ["modalWizard", "catalogService", "pageFacade"];
/* @ngInject */ ClonePageWizardService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.ModalWizard,
        smarteditcommons.ICatalogService,
        PageFacade])
], /* @ngInject */ ClonePageWizardService);

window.__smartedit__.addDecoratorPayload("Component", "ComponentCloneInfoFormComponent", {
    selector: 'se-component-clone-info-form',
    template: `<se-message *ngIf="catalogVersionContainsPageWithSameTypeCode" type="warning"><span se-message-description translate="se.cms.clonepagewizard.pageinfo.targetcatalogversion.pagetype.exists.message" [translateParams]="{ typeCode: pageTypeCode }"></span></se-message><se-generic-editor [id]="genericEditorId" [structure]="structure" [content]="content" [(submit)]="submitInternal" [(reset)]="resetInternal" [(isDirty)]="isDirtyInternal" [(isValid)]="isValidInternal" (getApi)="setGenericEditorApi($event)"></se-generic-editor>`
});
let /* @ngInject */ ComponentCloneInfoFormComponent = class /* @ngInject */ ComponentCloneInfoFormComponent {
    constructor(translateService, languageService, pageFacade, pageService, systemEventService) {
        this.translateService = translateService;
        this.languageService = languageService;
        this.pageFacade = pageFacade;
        this.pageService = pageService;
        this.systemEventService = systemEventService;
        this.genericEditorId = 'COMPONENT_CLONE_INFO_FORM_GENERIC_ID';
        this.isDirtyChange = new core.EventEmitter();
        this.isValidChange = new core.EventEmitter();
        this.submitChange = new core.EventEmitter();
        this.resetChange = new core.EventEmitter();
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.pageLabel = null;
            this.catalogVersionContainsPageWithSameTypeCode = false;
            if (this.pageTypeCode !== 'ContentPage' &&
                this.targetCatalogVersion &&
                !this.isUriContextEqualToCatalogVersion(this.uriContext, this.targetCatalogVersion)) {
                const uriContextForSelectedCatalogVersion = {
                    [smarteditcommons.PAGE_CONTEXT_SITE_ID]: this.targetCatalogVersion.siteId,
                    [cmscommons.PAGE_CONTEXT_CATALOG]: this.targetCatalogVersion.catalogId,
                    [cmscommons.PAGE_CONTEXT_CATALOG_VERSION]: this.targetCatalogVersion.version
                };
                const pageExists = yield this.pageService.primaryPageForPageTypeExists(this.pageTypeCode, uriContextForSelectedCatalogVersion);
                this.catalogVersionContainsPageWithSameTypeCode = pageExists;
            }
            setTimeout(() => {
                this.isDirtyChange.emit(() => this.isDirtyInternal && this.isDirtyInternal());
                this.isValidChange.emit(() => this.isValidInternal && this.isValidInternal());
                this.submitChange.emit(() => this.submitInternal && this.submitInternal());
                this.resetChange.emit(() => this.resetInternal && this.resetInternal());
            });
            this.genericEditorLoadEventUnsubscribe = this.systemEventService.subscribe(smarteditcommons.GENERIC_EDITOR_LOADED_EVENT, (_eventId, editorId) => this.handleWarningMessage(editorId));
        });
    }
    ngOnDestroy() {
        if (this.genericEditorLoadEventUnsubscribe) {
            this.genericEditorLoadEventUnsubscribe();
        }
    }
    setGenericEditorApi(api) {
        this.pageInfoEditorApi = api;
        if (this.targetCatalogVersion &&
            !this.isUriContextEqualToCatalogVersion(this.uriContext, this.targetCatalogVersion)) {
            this.pageInfoEditorApi.getLanguages = () => this.languageService.getLanguagesForSite(this.targetCatalogVersion.siteId);
        }
    }
    isUriContextEqualToCatalogVersion(uriContext, catalogVersion) {
        return (uriContext &&
            catalogVersion &&
            catalogVersion.siteId === uriContext.CURRENT_CONTEXT_SITE_ID &&
            catalogVersion.catalogId === uriContext.CURRENT_CONTEXT_CATALOG &&
            catalogVersion.version === uriContext.CURRENT_CONTEXT_CATALOG_VERSION);
    }
    handleWarningMessage(editorId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (editorId !== this.genericEditorId) {
                return;
            }
            if (this.pageTypeCode === 'ContentPage' &&
                this.targetCatalogVersion &&
                this.pageInfoEditorApi &&
                !this.isUriContextEqualToCatalogVersion(this.uriContext, this.targetCatalogVersion)) {
                const content = this.pageInfoEditorApi.getContent();
                if (content && content.label !== this.pageLabel) {
                    this.pageLabel = content.label;
                    yield this.toggleWarningMessage();
                }
            }
        });
    }
    toggleWarningMessage() {
        return __awaiter(this, void 0, void 0, function* () {
            const pageExists = yield this.pageFacade.contentPageWithLabelExists(this.pageLabel, this.targetCatalogVersion.catalogId, this.targetCatalogVersion.version);
            if (pageExists) {
                this.systemEventService.publishAsync(smarteditcommons.GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT, {
                    messages: [
                        {
                            subject: 'label',
                            message: this.translateService.instant('se.cms.clonepagewizard.pageinfo.targetcatalogversion.label.exists.message'),
                            type: 'Warning'
                        }
                    ]
                });
            }
            else {
                this.pageInfoEditorApi.clearMessages();
            }
        });
    }
};
ComponentCloneInfoFormComponent.$inject = ["translateService", "languageService", "pageFacade", "pageService", "systemEventService"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ ComponentCloneInfoFormComponent.prototype, "content", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ ComponentCloneInfoFormComponent.prototype, "pageTemplate", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ ComponentCloneInfoFormComponent.prototype, "pageTypeCode", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ ComponentCloneInfoFormComponent.prototype, "structure", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ ComponentCloneInfoFormComponent.prototype, "targetCatalogVersion", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ ComponentCloneInfoFormComponent.prototype, "uriContext", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ ComponentCloneInfoFormComponent.prototype, "submit", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ ComponentCloneInfoFormComponent.prototype, "reset", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ ComponentCloneInfoFormComponent.prototype, "isDirty", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Function)
], /* @ngInject */ ComponentCloneInfoFormComponent.prototype, "isValid", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ ComponentCloneInfoFormComponent.prototype, "isDirtyChange", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ ComponentCloneInfoFormComponent.prototype, "isValidChange", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ ComponentCloneInfoFormComponent.prototype, "submitChange", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ ComponentCloneInfoFormComponent.prototype, "resetChange", void 0);
/* @ngInject */ ComponentCloneInfoFormComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-component-clone-info-form',
        template: `<se-message *ngIf="catalogVersionContainsPageWithSameTypeCode" type="warning"><span se-message-description translate="se.cms.clonepagewizard.pageinfo.targetcatalogversion.pagetype.exists.message" [translateParams]="{ typeCode: pageTypeCode }"></span></se-message><se-generic-editor [id]="genericEditorId" [structure]="structure" [content]="content" [(submit)]="submitInternal" [(reset)]="resetInternal" [(isDirty)]="isDirtyInternal" [(isValid)]="isValidInternal" (getApi)="setGenericEditorApi($event)"></se-generic-editor>`
    }),
    __metadata("design:paramtypes", [core$1.TranslateService,
        smarteditcommons.LanguageService,
        PageFacade,
        smarteditcommons.IPageService,
        smarteditcommons.SystemEventService])
], /* @ngInject */ ComponentCloneInfoFormComponent);

window.__smartedit__.addDecoratorPayload("Component", "ComponentCloneOptionFormComponent", {
    selector: 'se-component-clone-option-form',
    template: `<label for="components-cloned-selector-id" class="se-control-label"><span translate="se.cms.clonepagewizard.options.title"></span><se-help><span translate="se.cms.clonepagewizard.options.tooltip"></span></se-help></label><div id="components-cloned-selector-id"><div class="se-form-control-row"><input class="components-cloned-option-id fd-form__control" type="radio" name="componentsclone" id="reference-cloning" [(ngModel)]="componentInSlotOption" (click)="updateComponentInSlotOption(CLONE_COMPONENTS_IN_CONTENT_SLOTS_OPTION.REFERENCE_EXISTING)" [value]="CLONE_COMPONENTS_IN_CONTENT_SLOTS_OPTION.REFERENCE_EXISTING"/> <label for="reference-cloning" translate="se.cms.clonepagewizard.options.existing"></label></div><div class="se-form-control-row"><input class="components-cloned-option-id fd-form__control" type="radio" id="deep-cloning" name="componentsclone" [(ngModel)]="componentInSlotOption" (click)="updateComponentInSlotOption(CLONE_COMPONENTS_IN_CONTENT_SLOTS_OPTION.CLONE)" [value]="CLONE_COMPONENTS_IN_CONTENT_SLOTS_OPTION.CLONE"/> <label for="deep-cloning" translate="se.cms.clonepagewizard.options.copies"></label></div></div>`,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ ComponentCloneOptionFormComponent = class /* @ngInject */ ComponentCloneOptionFormComponent {
    constructor() {
        this.CLONE_COMPONENTS_IN_CONTENT_SLOTS_OPTION = {
            REFERENCE_EXISTING: 'reference',
            CLONE: 'clone'
        };
        this.onSelectionChange = new core.EventEmitter();
    }
    ngOnInit() {
        this.componentInSlotOption = this.CLONE_COMPONENTS_IN_CONTENT_SLOTS_OPTION.REFERENCE_EXISTING;
        this.onSelectionChange.emit(this.componentInSlotOption);
    }
    updateComponentInSlotOption(option) {
        this.onSelectionChange.emit(option);
    }
};
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ ComponentCloneOptionFormComponent.prototype, "onSelectionChange", void 0);
/* @ngInject */ ComponentCloneOptionFormComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-component-clone-option-form',
        template: `<label for="components-cloned-selector-id" class="se-control-label"><span translate="se.cms.clonepagewizard.options.title"></span><se-help><span translate="se.cms.clonepagewizard.options.tooltip"></span></se-help></label><div id="components-cloned-selector-id"><div class="se-form-control-row"><input class="components-cloned-option-id fd-form__control" type="radio" name="componentsclone" id="reference-cloning" [(ngModel)]="componentInSlotOption" (click)="updateComponentInSlotOption(CLONE_COMPONENTS_IN_CONTENT_SLOTS_OPTION.REFERENCE_EXISTING)" [value]="CLONE_COMPONENTS_IN_CONTENT_SLOTS_OPTION.REFERENCE_EXISTING"/> <label for="reference-cloning" translate="se.cms.clonepagewizard.options.existing"></label></div><div class="se-form-control-row"><input class="components-cloned-option-id fd-form__control" type="radio" id="deep-cloning" name="componentsclone" [(ngModel)]="componentInSlotOption" (click)="updateComponentInSlotOption(CLONE_COMPONENTS_IN_CONTENT_SLOTS_OPTION.CLONE)" [value]="CLONE_COMPONENTS_IN_CONTENT_SLOTS_OPTION.CLONE"/> <label for="deep-cloning" translate="se.cms.clonepagewizard.options.copies"></label></div></div>`,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [])
], /* @ngInject */ ComponentCloneOptionFormComponent);

window.__smartedit__.addDecoratorPayload("Component", "DeletePageToolbarItemComponent", {
    selector: 'se-delete-page-toolbar-item',
    template: `<div class="toolbar-action" *ngIf="isReady" [attr.data-item-key]="toolbarItem.key"><button type="button" class="btn toolbar-action--button" [disabled]="isDeletePageDisabled" [ngClass]="{ 'toolbar-action__disabled' : isDeletePageDisabled }" (click)="deletePage()"><span class="icon-delete se-toolbar-menu-ddlb--button__icon"></span><div class="toolbar-action-button__txt" translate="se.cms.actionitem.page.trash"></div></button><se-tooltip *ngIf="isDeletePageDisabled" [appendTo]="'body'" [isChevronVisible]="true" [placement]="'bottom'" [triggers]="['mouseenter', 'mouseleave']" [additionalClasses]="['se-tooltip--stretched']"><div se-tooltip-body><span [translate]="tooltipMessage"></span></div></se-tooltip></div>`,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ DeletePageToolbarItemComponent = class /* @ngInject */ DeletePageToolbarItemComponent {
    constructor(pageService, pageFacade, managePageService, systemEventService, crossFrameEventService, cdr, userTrackingService, toolbarItem) {
        this.pageService = pageService;
        this.pageFacade = pageFacade;
        this.managePageService = managePageService;
        this.systemEventService = systemEventService;
        this.crossFrameEventService = crossFrameEventService;
        this.cdr = cdr;
        this.userTrackingService = userTrackingService;
        this.toolbarItem = toolbarItem;
    }
    ngOnInit() {
        this.unRegPageChange = this.crossFrameEventService.subscribe(smarteditcommons.EVENTS.PAGE_CHANGE, () => this.updateToolbar());
        return this.updateToolbar();
    }
    ngOnDestroy() {
        this.unRegPageChange();
    }
    get isDeletePageDisabled() {
        return !this.isDeletePageEnabled;
    }
    deletePage() {
        return __awaiter(this, void 0, void 0, function* () {
            this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.TOOL_BAR, 'Delete Page');
            const pageInfo = yield this.pageService.getCurrentPageInfo();
            yield this.managePageService.softDeletePage(pageInfo, this.uriContext);
            this.systemEventService.publishAsync(smarteditcommons.EVENT_CONTENT_CATALOG_UPDATE);
        });
    }
    updateToolbar() {
        return __awaiter(this, void 0, void 0, function* () {
            this.markAsNotReady();
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
            const uriContext = yield this.pageFacade.retrievePageUriContext();
            if (!uriContext) {
                return;
            }
            this.uriContext = uriContext;
            this.pageInfo = yield this.pageService.getCurrentPageInfo();
            this.isDeletePageEnabled = yield this.managePageService.isPageTrashable(this.pageInfo, this.uriContext);
            this.tooltipMessage = yield this.resolveTooltipMessage(this.isDeletePageEnabled, this.pageInfo, this.uriContext);
            this.markAsReady();
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    markAsNotReady() {
        this.isReady = false;
        this.isDeletePageEnabled = false;
        this.tooltipMessage = null;
    }
    markAsReady() {
        this.isReady = true;
    }
    resolveTooltipMessage(isDeleteEnabled, pageInfo, uriContext) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (isDeleteEnabled
                ? null
                : this.managePageService.getDisabledTrashTooltipMessage(pageInfo, uriContext));
        });
    }
};
DeletePageToolbarItemComponent.$inject = ["pageService", "pageFacade", "managePageService", "systemEventService", "crossFrameEventService", "cdr", "userTrackingService", "toolbarItem"];
/* @ngInject */ DeletePageToolbarItemComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-delete-page-toolbar-item',
        template: `<div class="toolbar-action" *ngIf="isReady" [attr.data-item-key]="toolbarItem.key"><button type="button" class="btn toolbar-action--button" [disabled]="isDeletePageDisabled" [ngClass]="{ 'toolbar-action__disabled' : isDeletePageDisabled }" (click)="deletePage()"><span class="icon-delete se-toolbar-menu-ddlb--button__icon"></span><div class="toolbar-action-button__txt" translate="se.cms.actionitem.page.trash"></div></button><se-tooltip *ngIf="isDeletePageDisabled" [appendTo]="'body'" [isChevronVisible]="true" [placement]="'bottom'" [triggers]="['mouseenter', 'mouseleave']" [additionalClasses]="['se-tooltip--stretched']"><div se-tooltip-body><span [translate]="tooltipMessage"></span></div></se-tooltip></div>`,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(7, core.Inject(smarteditcommons.TOOLBAR_ITEM)),
    __metadata("design:paramtypes", [smarteditcommons.IPageService,
        PageFacade,
        exports.ManagePageService,
        smarteditcommons.SystemEventService,
        smarteditcommons.CrossFrameEventService,
        core.ChangeDetectorRef,
        smarteditcommons.UserTrackingService, Object])
], /* @ngInject */ DeletePageToolbarItemComponent);

var CatalogHomepageDetailsStatus$1;
(function (CatalogHomepageDetailsStatus) {
    CatalogHomepageDetailsStatus["PENDING"] = "PENDING";
    CatalogHomepageDetailsStatus["NO_HOMEPAGE"] = "NO_HOMEPAGE";
    CatalogHomepageDetailsStatus["LOCAL"] = "LOCAL";
    CatalogHomepageDetailsStatus["OLD"] = "OLD";
    CatalogHomepageDetailsStatus["PARENT"] = "PARENT";
})(CatalogHomepageDetailsStatus$1 || (CatalogHomepageDetailsStatus$1 = {}));
window.__smartedit__.addDecoratorPayload("Component", "DisplayConditionsEditorComponent", {
    selector: 'se-display-conditions-editor',
    template: `<div><se-event-message class="existing-homepage__ymessage" [showEvent]="'CMS_EVENT_SHOW_REPLACE_PARENT_HOMEPAGE_INFO'" [hideEvent]="'CMS_EVENT_HIDE_REPLACE_PARENT_HOMEPAGE_INFO'"></se-event-message><se-display-conditions-page-info [pageName]="getPageName()" [pageType]="getPageType()" [isPrimary]="isPagePrimary()"></se-display-conditions-page-info><se-display-conditions-page-variations *ngIf="isPagePrimary()" [variations]="getVariations()"></se-display-conditions-page-variations><se-display-conditions-primary-page *ngIf="!isPagePrimary()" [readOnly]="getIsAssociatedPrimaryReadOnly()" [associatedPrimaryPage]="getAssociatedPrimaryPage()" [pageType]="getPageType()" (onPrimaryPageSelect)="onPrimaryPageSelect($event)"></se-display-conditions-primary-page><div *ngIf="showHomePageWidget()"><div class="se-component-homepage"><label class="se-control-label"><input type="checkbox" id="set-homepage-checkbox" class="fd-form__control se-display-conditions__homepage-input" name="clone-on-drop" [disabled]="disableHomepageCheckbox()" (ngModelChange)="homePageChanged($event)" [ngModel]="page.homepage"/> <span translate="se.cms.display.conditions.homepage.set"></span><se-help *ngIf="disableHomepageCheckbox()"><span translate="se.cms.display.conditions.homepage.disabled"></span></se-help></label></div><div class="se-display-conditions__replace-home-message" *ngIf="showReplaceLabel" translate="se.cms.display.conditions.homepage.replace" [translateParams]="{ currentHomepage: currentHomePageName }"></div></div></div>`,
    styles: [`.se-display-conditions__homepage-input{margin:0 4px 0 0}.se-display-conditions__replace-home-message{padding-top:8px}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    providers: [smarteditcommons.L10nPipe]
});
let /* @ngInject */ DisplayConditionsEditorComponent = class /* @ngInject */ DisplayConditionsEditorComponent {
    constructor(data, route, displayConditionsEditorModel, homepageService, pageService, logService, l10n, translateService, cdr) {
        this.data = data;
        this.route = route;
        this.displayConditionsEditorModel = displayConditionsEditorModel;
        this.homepageService = homepageService;
        this.pageService = pageService;
        this.logService = logService;
        this.l10n = l10n;
        this.translateService = translateService;
        this.cdr = cdr;
        ({ model: this.page } = this.data);
        this.hasFallback = false;
        this.isPrimaryPage = false;
        this.showReplaceLabel = false;
        this.homepageDetails = {
            status: CatalogHomepageDetailsStatus$1.PENDING
        };
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.displayConditionsEditorModel.initModel(this.page.uid);
            const routeParams = this.getRouteParams();
            try {
                const uriContext = yield this.pageService.buildUriContextForCurrentPage(routeParams.siteId, routeParams.catalogId, routeParams.catalogVersion);
                const [isPagePrimary, hasFallbackHomePage, homePageDetails] = yield Promise.all([
                    this.pageService.isPagePrimaryWithContext(this.page.uid, uriContext),
                    this.homepageService.hasFallbackHomePage(uriContext),
                    this.homepageService.getHomepageDetailsForContext(uriContext)
                ]);
                this.isPrimaryPage = isPagePrimary;
                this.hasFallback = hasFallbackHomePage;
                this.homepageDetails = homePageDetails;
                if (!this.cdr.destroyed) {
                    this.cdr.detectChanges();
                }
            }
            catch (_a) {
                this.logService.error('DisplayConditionsEditorComponent::ngOnInit - unable to retrieve uriContext');
            }
        });
    }
    disableHomepageCheckbox() {
        if (this.hasFallback) {
            return false;
        }
        if (this.homepageDetails.status === CatalogHomepageDetailsStatus$1.LOCAL) {
            if (this.homepageDetails.currentHomepageUid === this.page.uid) {
                return true;
            }
            if (this.homepageDetails.oldHomepageUid === this.page.uid) {
                return false;
            }
            return false;
        }
        return true;
    }
    homePageChanged(isHomepage) {
        return __awaiter(this, void 0, void 0, function* () {
            this.page.homepage = isHomepage;
            if (this.page.homepage) {
                switch (this.homepageDetails.status) {
                    case CatalogHomepageDetailsStatus$1.NO_HOMEPAGE:
                        this.homepageService.sendEventHideReplaceParentHomePageInfo();
                        this.showReplaceLabel = false;
                        break;
                    case CatalogHomepageDetailsStatus$1.PARENT:
                        const [parentCatalogName, targetCatalogName] = yield this.getTranslatedNames(this.homepageDetails.parentCatalogName, this.homepageDetails.targetCatalogName);
                        this.homepageService.sendEventShowReplaceParentHomePageInfo({
                            description: this.translateService.instant('se.cms.display.conditions.homepage.replace.parent.info.header', {
                                parentCatalogName,
                                parentCatalogVersion: this.homepageDetails.parentCatalogVersion,
                                targetCatalogName,
                                targetCatalogVersion: this.homepageDetails.targetCatalogVersion
                            })
                        });
                        this.showReplaceLabel = false;
                        break;
                    case CatalogHomepageDetailsStatus$1.LOCAL:
                        this.homepageService.sendEventHideReplaceParentHomePageInfo();
                        this.currentHomePageName = this.homepageDetails.currentHomepageName;
                        this.showReplaceLabel =
                            this.page.uid !== this.homepageDetails.currentHomepageUid;
                        break;
                }
            }
            else {
                this.homepageService.sendEventHideReplaceParentHomePageInfo();
                this.showReplaceLabel = false;
            }
        });
    }
    showHomePageWidget() {
        return (this.homepageDetails.status !== CatalogHomepageDetailsStatus$1.PENDING &&
            this.page.typeCode === 'ContentPage' &&
            this.isPrimaryPage);
    }
    getPageName() {
        return this.displayConditionsEditorModel.pageName;
    }
    getPageType() {
        return this.displayConditionsEditorModel.pageType;
    }
    isPagePrimary() {
        return this.displayConditionsEditorModel.isPrimary;
    }
    getVariations() {
        return this.displayConditionsEditorModel.variations;
    }
    getAssociatedPrimaryPage() {
        return this.displayConditionsEditorModel.associatedPrimaryPage;
    }
    getIsAssociatedPrimaryReadOnly() {
        return this.displayConditionsEditorModel.isAssociatedPrimaryReadOnly;
    }
    onPrimaryPageSelect(primaryPage) {
        this.page.label = primaryPage.label;
    }
    getRouteParams() {
        let demandedRoute = this.route.firstChild ? this.route.firstChild : this.route;
        while (!!demandedRoute.firstChild) {
            demandedRoute = demandedRoute.firstChild;
        }
        return demandedRoute.snapshot.params;
    }
    getTranslatedNames(name, secondName) {
        return Promise.all([
            this.l10n.transform(name).pipe(operators.take(1)).toPromise(),
            this.l10n.transform(secondName).pipe(operators.take(1)).toPromise()
        ]);
    }
};
DisplayConditionsEditorComponent.$inject = ["data", "route", "displayConditionsEditorModel", "homepageService", "pageService", "logService", "l10n", "translateService", "cdr"];
/* @ngInject */ DisplayConditionsEditorComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-display-conditions-editor',
        template: `<div><se-event-message class="existing-homepage__ymessage" [showEvent]="'CMS_EVENT_SHOW_REPLACE_PARENT_HOMEPAGE_INFO'" [hideEvent]="'CMS_EVENT_HIDE_REPLACE_PARENT_HOMEPAGE_INFO'"></se-event-message><se-display-conditions-page-info [pageName]="getPageName()" [pageType]="getPageType()" [isPrimary]="isPagePrimary()"></se-display-conditions-page-info><se-display-conditions-page-variations *ngIf="isPagePrimary()" [variations]="getVariations()"></se-display-conditions-page-variations><se-display-conditions-primary-page *ngIf="!isPagePrimary()" [readOnly]="getIsAssociatedPrimaryReadOnly()" [associatedPrimaryPage]="getAssociatedPrimaryPage()" [pageType]="getPageType()" (onPrimaryPageSelect)="onPrimaryPageSelect($event)"></se-display-conditions-primary-page><div *ngIf="showHomePageWidget()"><div class="se-component-homepage"><label class="se-control-label"><input type="checkbox" id="set-homepage-checkbox" class="fd-form__control se-display-conditions__homepage-input" name="clone-on-drop" [disabled]="disableHomepageCheckbox()" (ngModelChange)="homePageChanged($event)" [ngModel]="page.homepage"/> <span translate="se.cms.display.conditions.homepage.set"></span><se-help *ngIf="disableHomepageCheckbox()"><span translate="se.cms.display.conditions.homepage.disabled"></span></se-help></label></div><div class="se-display-conditions__replace-home-message" *ngIf="showReplaceLabel" translate="se.cms.display.conditions.homepage.replace" [translateParams]="{ currentHomepage: currentHomePageName }"></div></div></div>`,
        styles: [`.se-display-conditions__homepage-input{margin:0 4px 0 0}.se-display-conditions__replace-home-message{padding-top:8px}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush,
        providers: [smarteditcommons.L10nPipe]
    }),
    __param(0, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [Object, router.ActivatedRoute,
        exports.DisplayConditionsEditorModel,
        exports.HomepageService,
        smarteditcommons.IPageService,
        smarteditcommons.LogService,
        smarteditcommons.L10nPipe,
        core$1.TranslateService,
        core.ChangeDetectorRef])
], /* @ngInject */ DisplayConditionsEditorComponent);

window.__smartedit__.addDecoratorPayload("Component", "DisplayConditionsPageInfoComponent", {
    selector: 'se-display-conditions-page-info',
    template: `<div class="se-edit-page-info__display-conditions"><div class="se-edit-page-info-display-conditions__basic-info"><div><label class="se-control-label" translate="se.cms.pagelist.headerpagename"></label><div class="form-readonly-text form-readonly-text__tight dc-page-name">{{ pageName }}</div></div><div><label class="se-control-label" translate="se.cms.pagelist.headerpagetype"></label><div class="form-readonly-text form-readonly-text__tight dc-page-type">{{ pageType }}</div></div></div><label class="se-control-label"><span translate="se.cms.display.conditions.label"></span><se-help><span [translate]="getPageDisplayConditionDescriptionI18nKey()"></span></se-help></label><p class="form-readonly-text form-readonly-text__tight dc-page-display-condition" [translate]="getPageDisplayConditionI18nKey()"></p></div>`,
    styles: [`.se-edit-page-info__display-conditions{margin-bottom:16px}.se-edit-page-info-display-conditions__basic-info{display:grid;grid-template-columns:repeat(2,1fr);margin-bottom:16px}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ DisplayConditionsPageInfoComponent = class /* @ngInject */ DisplayConditionsPageInfoComponent {
    getPageDisplayConditionI18nKey() {
        return this.isPrimary
            ? 'se.cms.display.conditions.primary.id'
            : 'se.cms.display.conditions.variation.id';
    }
    getPageDisplayConditionDescriptionI18nKey() {
        return this.isPrimary
            ? 'se.cms.display.conditions.primary.description'
            : 'se.cms.display.conditions.variation.description';
    }
};
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], /* @ngInject */ DisplayConditionsPageInfoComponent.prototype, "isPrimary", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ DisplayConditionsPageInfoComponent.prototype, "pageName", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ DisplayConditionsPageInfoComponent.prototype, "pageType", void 0);
/* @ngInject */ DisplayConditionsPageInfoComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-display-conditions-page-info',
        template: `<div class="se-edit-page-info__display-conditions"><div class="se-edit-page-info-display-conditions__basic-info"><div><label class="se-control-label" translate="se.cms.pagelist.headerpagename"></label><div class="form-readonly-text form-readonly-text__tight dc-page-name">{{ pageName }}</div></div><div><label class="se-control-label" translate="se.cms.pagelist.headerpagetype"></label><div class="form-readonly-text form-readonly-text__tight dc-page-type">{{ pageType }}</div></div></div><label class="se-control-label"><span translate="se.cms.display.conditions.label"></span><se-help><span [translate]="getPageDisplayConditionDescriptionI18nKey()"></span></se-help></label><p class="form-readonly-text form-readonly-text__tight dc-page-display-condition" [translate]="getPageDisplayConditionI18nKey()"></p></div>`,
        styles: [`.se-edit-page-info__display-conditions{margin-bottom:16px}.se-edit-page-info-display-conditions__basic-info{display:grid;grid-template-columns:repeat(2,1fr);margin-bottom:16px}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    })
], /* @ngInject */ DisplayConditionsPageInfoComponent);

window.__smartedit__.addDecoratorPayload("Component", "CreationDateRendererComponent", {
    selector: 'se-creation-date-renderer',
    template: `<span>{{ item.creationDate | date: 'short' }}</span>`
});
let /* @ngInject */ CreationDateRendererComponent = class /* @ngInject */ CreationDateRendererComponent {
    constructor(cellData) {
        this.cellData = cellData;
        this.item = this.cellData.item;
    }
};
CreationDateRendererComponent.$inject = ["cellData"];
/* @ngInject */ CreationDateRendererComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-creation-date-renderer',
        template: `<span>{{ item.creationDate | date: 'short' }}</span>`
    }),
    __param(0, core.Inject(smarteditcommons.CLIENT_PAGED_LIST_CELL_COMPONENT_DATA_TOKEN)),
    __metadata("design:paramtypes", [Object])
], /* @ngInject */ CreationDateRendererComponent);

window.__smartedit__.addDecoratorPayload("Component", "DisplayConditionsPageVariationsComponent", {
    selector: 'se-display-conditions-page-variations',
    template: `<div class="form-group dc-page-variations"><label class="se-control-label control-label__margin"><span translate="se.cms.display.conditions.variation.pages.title"></span><se-help *ngIf="variations.length > 0"><span translate="se.cms.display.conditions.variations.description"></span></se-help></label><div *ngIf="variations.length === 0" class="dc-no-variations form-readonly-text form-readonly-text__tight form-readonly-text__inline" translate="se.cms.display.conditions.no.variations"></div><div *ngIf="variations.length > 0"><se-client-paged-list [items]="variations" [keys]="keys" [itemsPerPage]="itemsPerPage" class="dc-page-variations-list"></se-client-paged-list></div></div>`,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ DisplayConditionsPageVariationsComponent = class /* @ngInject */ DisplayConditionsPageVariationsComponent {
    constructor() {
        this.itemsPerPage = 3;
        this.keys = [
            {
                property: 'pageName',
                i18n: 'se.cms.display.conditions.header.page.name'
            },
            {
                property: 'creationDate',
                i18n: 'se.cms.display.conditions.header.creation.date',
                component: CreationDateRendererComponent
            },
            {
                property: 'restrictions',
                i18n: 'se.cms.display.conditions.header.restrictions'
            }
        ];
    }
};
__decorate([
    core.Input(),
    __metadata("design:type", Array)
], /* @ngInject */ DisplayConditionsPageVariationsComponent.prototype, "variations", void 0);
/* @ngInject */ DisplayConditionsPageVariationsComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-display-conditions-page-variations',
        template: `<div class="form-group dc-page-variations"><label class="se-control-label control-label__margin"><span translate="se.cms.display.conditions.variation.pages.title"></span><se-help *ngIf="variations.length > 0"><span translate="se.cms.display.conditions.variations.description"></span></se-help></label><div *ngIf="variations.length === 0" class="dc-no-variations form-readonly-text form-readonly-text__tight form-readonly-text__inline" translate="se.cms.display.conditions.no.variations"></div><div *ngIf="variations.length > 0"><se-client-paged-list [items]="variations" [keys]="keys" [itemsPerPage]="itemsPerPage" class="dc-page-variations-list"></se-client-paged-list></div></div>`,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [])
], /* @ngInject */ DisplayConditionsPageVariationsComponent);

window.__smartedit__.addDecoratorPayload("Component", "DisplayConditionsPrimaryPageComponent", {
    selector: 'se-display-conditions-primary-page',
    template: `<div class="form-group form-group__inline"><label class="se-control-label control-label__margin" translate="se.cms.display.conditions.primary.page.label"></label><div *ngIf="readOnly" class="dc-associated-primary-page form-readonly-text form-readonly-text__tight">{{ associatedPrimaryPage?.name }}</div><div *ngIf="!readOnly"><se-select id="display-conditions-primary-association-selector" [model]="associatedPrimaryPageUid" (modelChange)="associatedPrimaryPageUidOnChange($event)" [fetchStrategy]="fetchStrategy"></se-select><span *ngIf="associatedPrimaryPage?.name" class="se-form-help-message"><span>{{ 'se.cms.page.label.label' | translate }}: {{ associatedPrimaryPage.label }}</span></span></div></div>`
});
let /* @ngInject */ DisplayConditionsPrimaryPageComponent = class /* @ngInject */ DisplayConditionsPrimaryPageComponent {
    constructor(pageService, displayConditionsFacade) {
        this.pageService = pageService;
        this.displayConditionsFacade = displayConditionsFacade;
        this.associatedPrimaryPageUid = null;
        this.onPrimaryPageSelect = new core.EventEmitter();
        this.fetchStrategy = {
            fetchEntity: () => Promise.resolve({
                id: this.associatedPrimaryPage.uid,
                label: this.associatedPrimaryPage.name
            }),
            fetchPage: (search, pageSize, currentPage) => this.displayConditionsFacade.getPrimaryPagesForPageType(this.pageType, null, {
                search,
                pageSize,
                currentPage
            })
        };
    }
    ngOnChanges(changes) {
        const associatedPrimaryPageChange = changes.associatedPrimaryPage;
        if (associatedPrimaryPageChange && !!associatedPrimaryPageChange.currentValue) {
            this.setAssociatedPrimaryPageSelected(associatedPrimaryPageChange.currentValue);
        }
    }
    associatedPrimaryPageUidOnChange(uid) {
        return __awaiter(this, void 0, void 0, function* () {
            const page = yield this.pageService.getPageById(uid);
            this.setAssociatedPrimaryPageSelected(page);
            this.onPrimaryPageSelect.emit(this.associatedPrimaryPage);
        });
    }
    setAssociatedPrimaryPageSelected(page) {
        this.associatedPrimaryPage = page;
        this.associatedPrimaryPageUid = page.uid;
    }
};
DisplayConditionsPrimaryPageComponent.$inject = ["pageService", "displayConditionsFacade"];
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], /* @ngInject */ DisplayConditionsPrimaryPageComponent.prototype, "readOnly", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ DisplayConditionsPrimaryPageComponent.prototype, "associatedPrimaryPage", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ DisplayConditionsPrimaryPageComponent.prototype, "pageType", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ DisplayConditionsPrimaryPageComponent.prototype, "onPrimaryPageSelect", void 0);
/* @ngInject */ DisplayConditionsPrimaryPageComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-display-conditions-primary-page',
        template: `<div class="form-group form-group__inline"><label class="se-control-label control-label__margin" translate="se.cms.display.conditions.primary.page.label"></label><div *ngIf="readOnly" class="dc-associated-primary-page form-readonly-text form-readonly-text__tight">{{ associatedPrimaryPage?.name }}</div><div *ngIf="!readOnly"><se-select id="display-conditions-primary-association-selector" [model]="associatedPrimaryPageUid" (modelChange)="associatedPrimaryPageUidOnChange($event)" [fetchStrategy]="fetchStrategy"></se-select><span *ngIf="associatedPrimaryPage?.name" class="se-form-help-message"><span>{{ 'se.cms.page.label.label' | translate }}: {{ associatedPrimaryPage.label }}</span></span></div></div>`
    }),
    __metadata("design:paramtypes", [smarteditcommons.IPageService,
        DisplayConditionsFacade])
], /* @ngInject */ DisplayConditionsPrimaryPageComponent);

window.__smartedit__.addDecoratorPayload("Component", "HomepageIconComponent", {
    selector: 'se-homepage-icon',
    template: `<se-tooltip *ngIf="isVisible()" [isChevronVisible]="true" [triggers]="['mouseenter', 'mouseleave']"><span se-tooltip-trigger class="sap-icon--home se-homepage-icon" [ngClass]="getIconClass()"></span> <span se-tooltip-body [translate]="getTooltipMessage()"></span></se-tooltip>`,
    styles: [`.se-homepage-icon{margin-right:4px}.se-homepage-icon--current{color:#0a6ed1}.se-homepage-icon--old{color:#32363a}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ HomepageIconComponent = class /* @ngInject */ HomepageIconComponent {
    constructor(homepageService, cdr) {
        this.homepageService = homepageService;
        this.cdr = cdr;
    }
    ngOnChanges() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cmsPage && !this.uriContext) {
                return;
            }
            this.type = yield this.homepageService.getHomepageType(this.cmsPage, this.uriContext);
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    isVisible() {
        return !!this.type;
    }
    getIconClass() {
        return {
            'se-homepage-icon--current': this.type === exports.HomepageType.CURRENT,
            'se-homepage-icon--old': this.type === exports.HomepageType.OLD
        };
    }
    getTooltipMessage() {
        const state = this.getHomepageState(this.type);
        return `se.cms.homepage.tooltip.message.${state}`;
    }
    getHomepageState(type) {
        return exports.HomepageType.CURRENT === type ? 'current' : 'previous';
    }
};
HomepageIconComponent.$inject = ["homepageService", "cdr"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ HomepageIconComponent.prototype, "cmsPage", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ HomepageIconComponent.prototype, "uriContext", void 0);
/* @ngInject */ HomepageIconComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-homepage-icon',
        template: `<se-tooltip *ngIf="isVisible()" [isChevronVisible]="true" [triggers]="['mouseenter', 'mouseleave']"><span se-tooltip-trigger class="sap-icon--home se-homepage-icon" [ngClass]="getIconClass()"></span> <span se-tooltip-body [translate]="getTooltipMessage()"></span></se-tooltip>`,
        styles: [`.se-homepage-icon{margin-right:4px}.se-homepage-icon--current{color:#0a6ed1}.se-homepage-icon--old{color:#32363a}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [exports.HomepageService, core.ChangeDetectorRef])
], /* @ngInject */ HomepageIconComponent);

let /* @ngInject */ PageEditorModalConfigService = class /* @ngInject */ PageEditorModalConfigService {
    constructor(cmsitemsRestService, pageService, contextAwarePageStructureService, contextAwareEditableItemService, translateService) {
        this.cmsitemsRestService = cmsitemsRestService;
        this.pageService = pageService;
        this.contextAwarePageStructureService = contextAwarePageStructureService;
        this.contextAwareEditableItemService = contextAwareEditableItemService;
        this.translateService = translateService;
    }
    /** Creates a config for given Page that can be used to open a modal.  */
    create(page) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = {
                title: 'se.cms.pageeditormodal.editpagetab.title',
                componentUuid: page.uuid,
                componentType: page.typeCode
            };
            // set content
            const [cmsPage, isPagePrimary] = yield Promise.all([
                this.cmsitemsRestService.getById(page.uuid),
                this.pageService.isPagePrimary(page.uid)
            ]);
            config.content = cmsPage;
            config.content.template = cmsPage.masterTemplateId;
            // set structure
            const fields = yield this.contextAwarePageStructureService.getPageStructureForPageEditing(config.content.typeCode, config.content.uid);
            config.structure = fields;
            if (isPagePrimary) {
                config.structure.attributes = this.filterPrimaryPageAttributes(config.structure.attributes);
            }
            if (!!page.uid) {
                yield this.ensureReadOnlyMode(page, config);
            }
            return config;
        });
    }
    filterPrimaryPageAttributes(attributes) {
        return attributes.filter((field) => this.isPrimaryPageAttribute(field));
    }
    isPrimaryPageAttribute(attribute) {
        return (attribute.qualifier !== 'restrictions' &&
            attribute.qualifier !== 'onlyOneRestrictionMustApply');
    }
    ensureReadOnlyMode(page, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const isEditable = yield this.contextAwareEditableItemService.isItemEditable(page.uid);
            config.readOnlyMode = !isEditable;
            if (config.readOnlyMode) {
                config.messages = [
                    {
                        type: 'info',
                        message: this.translateService.instant('se.cms.pageeditormodal.page.readonly.message')
                    }
                ];
            }
            return config;
        });
    }
};
PageEditorModalConfigService.$inject = ["cmsitemsRestService", "pageService", "contextAwarePageStructureService", "contextAwareEditableItemService", "translateService"];
/* @ngInject */ PageEditorModalConfigService = __decorate([
    core.Injectable(),
    __metadata("design:paramtypes", [smarteditcommons.CmsitemsRestService,
        smarteditcommons.IPageService,
        exports.ContextAwarePageStructureService,
        cmscommons.IContextAwareEditableItemService,
        core$1.TranslateService])
], /* @ngInject */ PageEditorModalConfigService);

/**
 * The page editor modal service module provides a service that allows opening an editor modal for a given page. The editor modal is populated with a save and cancel button, and is loaded with the
 * editorTabset of cmssmarteditContainer as its content, providing a way to edit
 * various fields of the given page.
 *
 * Convenience service to open an editor modal window for a given page's data.
 */
let /* @ngInject */ PageEditorModalService = class /* @ngInject */ PageEditorModalService {
    constructor(genericEditorModalService, crossFrameEventService, systemEventService, pageEditorModalConfigService, logService) {
        this.genericEditorModalService = genericEditorModalService;
        this.crossFrameEventService = crossFrameEventService;
        this.systemEventService = systemEventService;
        this.pageEditorModalConfigService = pageEditorModalConfigService;
        this.logService = logService;
    }
    /**
     * Opens Editor Modal.
     *
     * The editor modal is initialized with a title in the format '<TypeName> Editor', ie: 'Paragraph Editor'.
     * The editor modal is also wired with a save and cancel button.
     *
     * @returns A promise that resolves to the data returned by the modal when it is closed.
     */
    open(page) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield this.pageEditorModalConfigService.create(page);
            try {
                const updatedCmsPage = yield this.genericEditorModalService.open(config, () => {
                    this.crossFrameEventService.publish(cmscommons.DEFAULT_SYNCHRONIZATION_POLLING.FETCH_SYNC_STATUS_ONCE, page.uuid);
                });
                this.systemEventService.publishAsync(smarteditcommons.EVENT_CONTENT_CATALOG_UPDATE, updatedCmsPage);
            }
            catch (error) {
                this.logService.debug('Page Editor Modal dismissed', error);
            }
        });
    }
};
PageEditorModalService.$inject = ["genericEditorModalService", "crossFrameEventService", "systemEventService", "pageEditorModalConfigService", "logService"];
/* @ngInject */ PageEditorModalService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [exports.GenericEditorModalService,
        smarteditcommons.CrossFrameEventService,
        smarteditcommons.SystemEventService,
        PageEditorModalConfigService,
        smarteditcommons.LogService])
], /* @ngInject */ PageEditorModalService);

/**
 * This service is used to provide all the information necessary to properly display the Page Info Menu.
 */
let /* @ngInject */ PageInfoMenuService = class /* @ngInject */ PageInfoMenuService {
    constructor(displayConditionsFacade, logService, pageEditorModalService, pageService, pageVersionSelectionService, translateService, typeStructureRestService) {
        this.displayConditionsFacade = displayConditionsFacade;
        this.logService = logService;
        this.pageEditorModalService = pageEditorModalService;
        this.pageService = pageService;
        this.pageVersionSelectionService = pageVersionSelectionService;
        this.translateService = translateService;
        this.typeStructureRestService = typeStructureRestService;
        this.ALL_RESTRICTIONS_CRITERIA_LABEL = 'se.cms.restrictions.criteria.all';
        this.ANY_RESTRICTIONS_CRITERIA_LABEL = 'se.cms.restrictions.criteria.any';
        this.isPageEditorOpened = false;
    }
    openPageEditor(pageInfo) {
        if (lodash.isNil(pageInfo)) {
            this.logService.warn(`[${this.constructor.name}] - Cannot open page editor. Provided page is empty.`);
            return;
        }
        if (!this.isPageEditorOpened) {
            this.isPageEditorOpened = true;
            this.pageEditorModalService.open(pageInfo).finally(() => {
                this.isPageEditorOpened = false;
            });
        }
    }
    /**
     * Retrieves the information for the current page and prepares it to be displayed in the Page Info Menu.
     */
    getCurrentPageInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const pageInfo = yield this.pageService.getCurrentPageInfoByVersion(this.getCurrentPageVersionId());
                const primaryPageName = yield this.getPrimaryPageName(pageInfo);
                pageInfo.template = pageInfo.masterTemplateId;
                const pageInfoForViewing = lodash.cloneDeep(pageInfo);
                pageInfoForViewing.content = pageInfo;
                pageInfoForViewing.primaryPage = primaryPageName;
                pageInfoForViewing.localizedType = pageInfo.typeCode;
                pageInfoForViewing.displayCondition = this.getPageDisplayCondition(pageInfo);
                pageInfoForViewing.restrictionsCriteria = this.getPageRestrictionsCriteria(pageInfo);
                // Note: In the previous implementation of the page info, there was a call to the catalog service to retrieve the URI context
                // and assign it to the page content. However, that field doesn't seem to be in use anymore, so it was removed.
                return pageInfoForViewing;
            }
            catch (_a) {
                this.logService.warn(`[${this.constructor.name}] - Cannot retrieve page info. Please try again later.`);
            }
        });
    }
    /**
     * Retrieves the page structure and adapts the fields to match the order expected in the Page Info Menu.
     */
    getPageStructureForViewing(pageTypeCode, isPrimaryPage) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const structureToMap = yield this.typeStructureRestService.getStructureByType(pageTypeCode);
                const structure = structureToMap.map((field) => (Object.assign(Object.assign({}, field), { editable: false })));
                // This method needs to ensure that the page structure contains only the fields needed for viewing and in the right order.
                // The final list of attributes will have our fields in the right order. Any other fields in the structure, will appear at the end.
                this.removeFieldFromStructure(structure, 'uid');
                this.removeFieldFromStructure(structure, 'restrictions');
                const fieldsInRightOrder = [];
                const nameField = this.removeFieldFromStructure(structure, 'name');
                nameField.cmsStructureType = 'InfoPageName';
                this.addFieldToStructure(fieldsInRightOrder, nameField);
                this.addFieldToStructure(fieldsInRightOrder, this.buildField('displayCondition'));
                const descriptionFlag = this.structureContainsItemByFieldQualifier(structure, 'description');
                if (descriptionFlag) {
                    const descriptionField = this.removeFieldFromStructure(structure, 'description');
                    descriptionField.cmsStructureType = 'InfoPageName';
                    this.addFieldToStructure(fieldsInRightOrder, descriptionField);
                }
                const titleFlag = this.structureContainsItemByFieldQualifier(structure, 'title');
                if (titleFlag) {
                    const titleField = this.removeFieldFromStructure(structure, 'title');
                    titleField.cmsStructureType = 'InfoPageName';
                    this.addFieldToStructure(fieldsInRightOrder, titleField);
                }
                const labelFlag = this.structureContainsItemByFieldQualifier(structure, 'label');
                if (labelFlag) {
                    const labelField = this.removeFieldFromStructure(structure, 'label');
                    labelField.cmsStructureType = 'InfoPageName';
                    this.addFieldToStructure(fieldsInRightOrder, labelField);
                }
                this.addFieldToStructure(fieldsInRightOrder, this.buildField('localizedType'));
                this.addFieldToStructure(fieldsInRightOrder, this.buildField('template'));
                if (!isPrimaryPage) {
                    this.addFieldToStructure(fieldsInRightOrder, this.buildField('primaryPage'));
                    this.addFieldToStructure(fieldsInRightOrder, this.buildField('restrictions', 'RestrictionsList'));
                }
                this.addFieldToStructure(fieldsInRightOrder, this.removeFieldFromStructure(structure, 'creationtime'));
                this.addFieldToStructure(fieldsInRightOrder, this.removeFieldFromStructure(structure, 'modifiedtime'));
                return {
                    attributes: lodash.concat(fieldsInRightOrder, structure),
                    category: 'PAGE'
                };
            }
            catch (_a) {
                this.logService.warn(`[${this.constructor.name}] - Cannot retrieve page info structure. Please try again later.`);
            }
        });
    }
    // ------------------------------------------------------------------------
    // Helper Methods
    // ------------------------------------------------------------------------
    addFieldToStructure(structure, field) {
        if (field) {
            structure.push(field);
        }
    }
    buildField(qualifier, cmsStructureType = 'ShortString') {
        return {
            cmsStructureType,
            qualifier,
            i18nKey: 'se.cms.pageinfo.page.' + qualifier.toLocaleLowerCase(),
            editable: false
        };
    }
    structureContainsItemByFieldQualifier(structure, fieldQualifier) {
        return !!structure.find((item) => item.qualifier === fieldQualifier);
    }
    removeFieldFromStructure(structure, fieldQualifier) {
        const removedElements = lodash.remove(structure, (field) => field.qualifier === fieldQualifier);
        return removedElements[0];
    }
    getPrimaryPageName(pageInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isVariationPage(pageInfo)) {
                const { name } = yield this.displayConditionsFacade.getPrimaryPageForVariationPage(pageInfo.uid);
                return name || null;
            }
            return null;
        });
    }
    isVariationPage(pageInfo) {
        return !pageInfo.defaultPage;
    }
    getPageDisplayCondition(pageInfo) {
        const conditionTranslKey = this.isVariationPage(pageInfo)
            ? 'page.displaycondition.variation'
            : 'page.displaycondition.primary';
        return this.translateService.instant(conditionTranslKey);
    }
    getPageRestrictionsCriteria(pageInfo) {
        if (this.isVariationPage(pageInfo) && pageInfo.onlyOneRestrictionMustApply !== undefined) {
            const criteriaTranslKey = pageInfo.onlyOneRestrictionMustApply
                ? this.ANY_RESTRICTIONS_CRITERIA_LABEL
                : this.ALL_RESTRICTIONS_CRITERIA_LABEL;
            return this.translateService.instant(criteriaTranslKey);
        }
        return null;
    }
    getCurrentPageVersionId() {
        const pageVersion = this.pageVersionSelectionService.getSelectedPageVersion();
        return pageVersion ? pageVersion.uid : null;
    }
};
PageInfoMenuService.$inject = ["displayConditionsFacade", "logService", "pageEditorModalService", "pageService", "pageVersionSelectionService", "translateService", "typeStructureRestService"];
/* @ngInject */ PageInfoMenuService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [DisplayConditionsFacade,
        smarteditcommons.LogService,
        PageEditorModalService,
        smarteditcommons.IPageService,
        smarteditcommons.PageVersionSelectionService,
        core$1.TranslateService,
        TypeStructureRestService])
], /* @ngInject */ PageInfoMenuService);

window.__smartedit__.addDecoratorPayload("Component", "PageInfoMenuComponent", {
    selector: 'se-page-info-menu',
    template: `<div class="toolbar-action" data-item-key="se.cms.pageInfoMenu"><fd-popover [(isOpen)]="toolbarItem.isOpen" (isOpenChange)="onDropdownToggle($event)" [closeOnOutsideClick]="true"><fd-popover-control><button type="button" class="btn toolbar-action--button" [attr.aria-pressed]="toolbarItem.isOpen"><span class="hyicon hyicon-pageinfo se-toolbar-menu-ddlb--button__icon"></span><div class="se-toolbar-page-info-wrapper"><span class="toolbar-action-button__txt" [translate]="toolbarItem.name"></span></div></button></fd-popover-control><fd-popover-body><div class="se-page-info__dropdown-menu toolbar-action--include"><div class="se-page-info-menu" *ngIf="toolbarItem.isOpen"><se-prevent-vertical-overflow><div class="se-page-info-menu__header"><span class="se-page-info-menu__header-title" translate="se.cms.pageinfo.information.title"></span><div *seHasOperationPermission="editPagePermission"><button class="se-page-info__edit-btn fd-button--compact" *ngIf="isReady" translate="se.cms.contextmenu.title.edit" (click)="onEditPageClick()"></button></div></div><div *ngIf="isReady" class="se-page-info-menu__body"><se-generic-editor [smarteditComponentId]="pageInfo.uid" [smarteditComponentType]="pageInfo.typeCode" [structure]="pageStructure" [content]="pageInfo"></se-generic-editor></div></se-prevent-vertical-overflow></div></div></fd-popover-body></fd-popover></div>`,
    styles: [`.se-page-info-menu__header{padding:20px;display:flex;flex-direction:row;align-items:center;justify-content:space-between;border-bottom:1px solid #d9d9d9;height:53px;padding-top:15px;height:48px}.se-page-info-menu__header:first-child{font-size:1.1428571429rem;line-height:1.25;font-weight:400;color:#32363a}.se-page-info-menu__body{width:100%;height:400px;overflow-y:auto}.se-page-info-menu__body--title{text-transform:capitalize}.se-page-info__dropdown-menu{box-shadow:0 6px 12px rgba(0,0,0,.175);background-color:#fff;border-radius:4px!important;min-width:100px;width:fit-content;position:absolute;border:1px solid #d9d9d9;z-index:2000;top:96%}.se-page-info__dropdown-menu::before{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#d9d9d9;border-bottom-color:var(var(--fd-color-neutral-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-8px}.se-page-info__dropdown-menu::after{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#fff;border-bottom-color:var(var(--fd-color-background-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-7px}.se-page-info__dropdown-menu::after,.se-page-info__dropdown-menu::before{left:14px}.se-page-info__dropdown-menu input{color:#32363a!important}.se-page-info-menu se-ge-tab{display:grid;grid-template-columns:repeat(1,1fr);grid-gap:0 16px;width:368px}.se-page-info-menu__body .fd-form-control[type=email]:disabled .fd-popover-custom,.se-page-info-menu__body .fd-form-control[type=text]:disabled .fd-popover-custom,.se-page-info-menu__body .se-select.is-disabled .fd-popover-custom,.se-tabset-wrapper .fd-form-control[type=email]:disabled .fd-popover-custom,.se-tabset-wrapper .fd-form-control[type=text]:disabled .fd-popover-custom,.se-tabset-wrapper .se-select.is-disabled .fd-popover-custom{opacity:1}.se-page-info-menu__body .fd-form-control[type=email]:disabled .fd-popover-custom .toggle-button,.se-page-info-menu__body .fd-form-control[type=text]:disabled .fd-popover-custom .toggle-button,.se-page-info-menu__body .se-select.is-disabled .fd-popover-custom .toggle-button,.se-tabset-wrapper .fd-form-control[type=email]:disabled .fd-popover-custom .toggle-button,.se-tabset-wrapper .fd-form-control[type=text]:disabled .fd-popover-custom .toggle-button,.se-tabset-wrapper .se-select.is-disabled .fd-popover-custom .toggle-button{border:none;opacity:1;color:#32363a;padding:0;line-height:1rem}.se-page-info-menu__body .fd-form-control[type=email]:disabled .fd-popover-custom .toggle-button::after,.se-page-info-menu__body .fd-form-control[type=text]:disabled .fd-popover-custom .toggle-button::after,.se-page-info-menu__body .se-select.is-disabled .fd-popover-custom .toggle-button::after,.se-tabset-wrapper .fd-form-control[type=email]:disabled .fd-popover-custom .toggle-button::after,.se-tabset-wrapper .fd-form-control[type=text]:disabled .fd-popover-custom .toggle-button::after,.se-tabset-wrapper .se-select.is-disabled .fd-popover-custom .toggle-button::after{display:none}`],
    encapsulation: core.ViewEncapsulation.None
});
let /* @ngInject */ PageInfoMenuComponent = class /* @ngInject */ PageInfoMenuComponent {
    constructor(toolbarItem, pageInfoMenuService, pageService, catalogService, systemEventService, userTrackingService) {
        this.toolbarItem = toolbarItem;
        this.pageInfoMenuService = pageInfoMenuService;
        this.pageService = pageService;
        this.catalogService = catalogService;
        this.systemEventService = systemEventService;
        this.userTrackingService = userTrackingService;
        this.cmsPage = null;
        this.uriContext = null;
        this.isReady = false;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.unRegContentCatalogUpdate = this.systemEventService.subscribe(smarteditcommons.EVENT_CONTENT_CATALOG_UPDATE, () => this.setPageData());
            yield this.setPageData();
        });
    }
    ngOnDestroy() {
        this.unRegContentCatalogUpdate();
    }
    onEditPageClick() {
        this.pageInfoMenuService.openPageEditor(this.pageInfo.content);
        this.closeMenu();
    }
    setPageData() {
        return __awaiter(this, void 0, void 0, function* () {
            const [page, uriContext] = yield Promise.all([
                this.pageService.getCurrentPageInfo(),
                this.catalogService.retrieveUriContext()
            ]);
            this.cmsPage = page;
            this.uriContext = uriContext;
            this.editPagePermission = [
                {
                    names: ['se.edit.page.type'],
                    context: {
                        typeCode: page.typeCode
                    }
                },
                {
                    names: ['se.edit.page.link']
                }
            ];
        });
    }
    onDropdownToggle(open) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!open) {
                return;
            }
            this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.TOOL_BAR, 'Info');
            const pageInfo = (yield this.pageInfoMenuService.getCurrentPageInfo());
            this.pageInfo = pageInfo;
            const pageStructure = (yield this.pageInfoMenuService.getPageStructureForViewing(pageInfo.typeCode, pageInfo.defaultPage));
            this.pageStructure = pageStructure;
            this.isReady = true;
        });
    }
    closeMenu() {
        this.toolbarItem.isOpen = false;
    }
};
PageInfoMenuComponent.$inject = ["toolbarItem", "pageInfoMenuService", "pageService", "catalogService", "systemEventService", "userTrackingService"];
/* @ngInject */ PageInfoMenuComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-info-menu',
        template: `<div class="toolbar-action" data-item-key="se.cms.pageInfoMenu"><fd-popover [(isOpen)]="toolbarItem.isOpen" (isOpenChange)="onDropdownToggle($event)" [closeOnOutsideClick]="true"><fd-popover-control><button type="button" class="btn toolbar-action--button" [attr.aria-pressed]="toolbarItem.isOpen"><span class="hyicon hyicon-pageinfo se-toolbar-menu-ddlb--button__icon"></span><div class="se-toolbar-page-info-wrapper"><span class="toolbar-action-button__txt" [translate]="toolbarItem.name"></span></div></button></fd-popover-control><fd-popover-body><div class="se-page-info__dropdown-menu toolbar-action--include"><div class="se-page-info-menu" *ngIf="toolbarItem.isOpen"><se-prevent-vertical-overflow><div class="se-page-info-menu__header"><span class="se-page-info-menu__header-title" translate="se.cms.pageinfo.information.title"></span><div *seHasOperationPermission="editPagePermission"><button class="se-page-info__edit-btn fd-button--compact" *ngIf="isReady" translate="se.cms.contextmenu.title.edit" (click)="onEditPageClick()"></button></div></div><div *ngIf="isReady" class="se-page-info-menu__body"><se-generic-editor [smarteditComponentId]="pageInfo.uid" [smarteditComponentType]="pageInfo.typeCode" [structure]="pageStructure" [content]="pageInfo"></se-generic-editor></div></se-prevent-vertical-overflow></div></div></fd-popover-body></fd-popover></div>`,
        styles: [`.se-page-info-menu__header{padding:20px;display:flex;flex-direction:row;align-items:center;justify-content:space-between;border-bottom:1px solid #d9d9d9;height:53px;padding-top:15px;height:48px}.se-page-info-menu__header:first-child{font-size:1.1428571429rem;line-height:1.25;font-weight:400;color:#32363a}.se-page-info-menu__body{width:100%;height:400px;overflow-y:auto}.se-page-info-menu__body--title{text-transform:capitalize}.se-page-info__dropdown-menu{box-shadow:0 6px 12px rgba(0,0,0,.175);background-color:#fff;border-radius:4px!important;min-width:100px;width:fit-content;position:absolute;border:1px solid #d9d9d9;z-index:2000;top:96%}.se-page-info__dropdown-menu::before{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#d9d9d9;border-bottom-color:var(var(--fd-color-neutral-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-8px}.se-page-info__dropdown-menu::after{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#fff;border-bottom-color:var(var(--fd-color-background-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-7px}.se-page-info__dropdown-menu::after,.se-page-info__dropdown-menu::before{left:14px}.se-page-info__dropdown-menu input{color:#32363a!important}.se-page-info-menu se-ge-tab{display:grid;grid-template-columns:repeat(1,1fr);grid-gap:0 16px;width:368px}.se-page-info-menu__body .fd-form-control[type=email]:disabled .fd-popover-custom,.se-page-info-menu__body .fd-form-control[type=text]:disabled .fd-popover-custom,.se-page-info-menu__body .se-select.is-disabled .fd-popover-custom,.se-tabset-wrapper .fd-form-control[type=email]:disabled .fd-popover-custom,.se-tabset-wrapper .fd-form-control[type=text]:disabled .fd-popover-custom,.se-tabset-wrapper .se-select.is-disabled .fd-popover-custom{opacity:1}.se-page-info-menu__body .fd-form-control[type=email]:disabled .fd-popover-custom .toggle-button,.se-page-info-menu__body .fd-form-control[type=text]:disabled .fd-popover-custom .toggle-button,.se-page-info-menu__body .se-select.is-disabled .fd-popover-custom .toggle-button,.se-tabset-wrapper .fd-form-control[type=email]:disabled .fd-popover-custom .toggle-button,.se-tabset-wrapper .fd-form-control[type=text]:disabled .fd-popover-custom .toggle-button,.se-tabset-wrapper .se-select.is-disabled .fd-popover-custom .toggle-button{border:none;opacity:1;color:#32363a;padding:0;line-height:1rem}.se-page-info-menu__body .fd-form-control[type=email]:disabled .fd-popover-custom .toggle-button::after,.se-page-info-menu__body .fd-form-control[type=text]:disabled .fd-popover-custom .toggle-button::after,.se-page-info-menu__body .se-select.is-disabled .fd-popover-custom .toggle-button::after,.se-tabset-wrapper .fd-form-control[type=email]:disabled .fd-popover-custom .toggle-button::after,.se-tabset-wrapper .fd-form-control[type=text]:disabled .fd-popover-custom .toggle-button::after,.se-tabset-wrapper .se-select.is-disabled .fd-popover-custom .toggle-button::after{display:none}`],
        encapsulation: core.ViewEncapsulation.None
    }),
    __param(0, core.Inject(smarteditcommons.TOOLBAR_ITEM)),
    __metadata("design:paramtypes", [Object, PageInfoMenuService,
        smarteditcommons.IPageService,
        smarteditcommons.ICatalogService,
        smarteditcommons.SystemEventService,
        smarteditcommons.UserTrackingService])
], /* @ngInject */ PageInfoMenuComponent);

window.__smartedit__.addDecoratorPayload("Component", "RestorePageItemComponent", {
    selector: 'se-restore-page-item',
    template: `<div *seHasOperationPermission="restorePagePermission"><a class="se-dropdown-item fd-menu__item" (click)="restorePage()"><span [translate]="'se.cms.actionitem.page.restore'"></span></a></div>`
});
let /* @ngInject */ RestorePageItemComponent = class /* @ngInject */ RestorePageItemComponent {
    constructor(managePageService, userTrackingService, dropdownMenuData) {
        this.managePageService = managePageService;
        this.userTrackingService = userTrackingService;
        this.dropdownMenuData = dropdownMenuData;
    }
    ngOnInit() {
        this.pageInfo = this.dropdownMenuData.selectedItem;
        this.restorePagePermission = [
            {
                names: ['se.restore.page.type'],
                context: {
                    typeCode: this.pageInfo.typeCode
                }
            }
        ];
    }
    restorePage() {
        this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.PAGE_MANAGEMENT, 'Restore');
        this.managePageService.restorePage(this.pageInfo);
    }
};
RestorePageItemComponent.$inject = ["managePageService", "userTrackingService", "dropdownMenuData"];
/* @ngInject */ RestorePageItemComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-restore-page-item',
        template: `<div *seHasOperationPermission="restorePagePermission"><a class="se-dropdown-item fd-menu__item" (click)="restorePage()"><span [translate]="'se.cms.actionitem.page.restore'"></span></a></div>`
    }),
    __param(2, core.Inject(smarteditcommons.DROPDOWN_MENU_ITEM_DATA)),
    __metadata("design:paramtypes", [exports.ManagePageService,
        smarteditcommons.UserTrackingService, Object])
], /* @ngInject */ RestorePageItemComponent);

window.__smartedit__.addDecoratorPayload("Component", "UpdatePageStatusComponent", {
    selector: 'se-update-page-status',
    template: `<div *ngIf="showButton"><a class="se-dropdown-item fd-menu__item" (click)="onClickOnSync()"><span [translate]="'se.cms.actionitem.page.sync'"></span></a></div>`,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ UpdatePageStatusComponent = class /* @ngInject */ UpdatePageStatusComponent {
    constructor(cdr, managePageService, cmsitemsRestService, catalogService, crossFrameEventService, userTrackingService, dropdownMenuData) {
        this.cdr = cdr;
        this.managePageService = managePageService;
        this.cmsitemsRestService = cmsitemsRestService;
        this.catalogService = catalogService;
        this.crossFrameEventService = crossFrameEventService;
        this.userTrackingService = userTrackingService;
        this.dropdownMenuData = dropdownMenuData;
        this.showButton = false;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.pageInfo = this.dropdownMenuData.selectedItem;
            yield this.setButtonVisibility();
        });
    }
    onClickOnSync() {
        return __awaiter(this, void 0, void 0, function* () {
            this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.PAGE_MANAGEMENT, 'Sync');
            yield this.managePageService.trashPageInActiveCatalogVersion(this.pageInfo.uid);
            this.crossFrameEventService.publish(smarteditcommons.CMSITEMS_UPDATE_EVENT);
            this.crossFrameEventService.publish(cmscommons.EVENT_PAGE_STATUS_UPDATED_IN_ACTIVE_CV);
        });
    }
    setButtonVisibility() {
        return __awaiter(this, void 0, void 0, function* () {
            this.showButton = yield this.doesPageExistInActiveCatalogVersion();
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    doesPageExistInActiveCatalogVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const uriContext = yield this.catalogService.retrieveUriContext();
            const activeVersion = yield this.catalogService.getContentCatalogActiveVersion(uriContext);
            const result = yield this.cmsitemsRestService.get({
                pageSize: 1,
                currentPage: 0,
                typeCode: 'AbstractPage',
                fields: 'BASIC',
                itemSearchParams: `uid:${this.pageInfo.uid}`,
                catalogId: uriContext.CONTEXT_CATALOG,
                catalogVersion: activeVersion
            });
            return result.pagination.totalCount === 1;
        });
    }
};
UpdatePageStatusComponent.$inject = ["cdr", "managePageService", "cmsitemsRestService", "catalogService", "crossFrameEventService", "userTrackingService", "dropdownMenuData"];
/* @ngInject */ UpdatePageStatusComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-update-page-status',
        template: `<div *ngIf="showButton"><a class="se-dropdown-item fd-menu__item" (click)="onClickOnSync()"><span [translate]="'se.cms.actionitem.page.sync'"></span></a></div>`,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(6, core.Inject(smarteditcommons.DROPDOWN_MENU_ITEM_DATA)),
    __metadata("design:paramtypes", [core.ChangeDetectorRef,
        exports.ManagePageService,
        smarteditcommons.CmsitemsRestService,
        smarteditcommons.ICatalogService,
        smarteditcommons.CrossFrameEventService,
        smarteditcommons.UserTrackingService, Object])
], /* @ngInject */ UpdatePageStatusComponent);

window.__smartedit__.addDecoratorPayload("Component", "PermanentlyDeletePageItemComponent", {
    selector: 'se-permanently-delete-page-item',
    template: `<div *seHasOperationPermission="permanentlyDeletePagePermission"><div class="se-dropdown-item__delete-wrapper"><div class="se-dropdown-item__delete-link-wrapper" [ngClass]="{'se-dropdown-item__delete-link-wrapper--disabled': isDeleteButtonDisabled()}"><a class="se-dropdown-item se-dropdown-item__delete fd-menu__item" [ngClass]="{'se-dropdown-item--disabled': isDeleteButtonDisabled()}" (click)="permanentlyDelete()"><span [translate]="'se.cms.actionitem.page.permanently.delete'"></span></a></div><se-tooltip class="se-dropdown-item__delete-page-popover" *ngIf="isDeleteButtonDisabled()" [placement]="'left'" [triggers]="['mouseenter', 'mouseleave']" [isChevronVisible]="true" [appendTo]="'body'"><span se-tooltip-trigger class="sap-icon--message-error"></span> <span se-tooltip-body [translate]="'se.cms.actionitem.page.permanently.delete.blocked'"></span></se-tooltip></div></div>`,
    styles: [`.se-dropdown-item__delete-wrapper{display:flex;flex-direction:row;align-items:center;width:100%}.se-dropdown-item__delete-page-popover{margin-right:16px}.se-dropdown-item__delete-page-popover .sap-icon--message-error{color:#0a6ed1}.se-dropdown-item__delete-link-wrapper{width:100%}.se-dropdown-item__delete-link-wrapper--disabled{cursor:not-allowed}`]
});
let /* @ngInject */ PermanentlyDeletePageItemComponent = class /* @ngInject */ PermanentlyDeletePageItemComponent {
    constructor(managePageService, cmsitemsRestService, catalogService, crossFrameEventService, userTrackingService, dropdownMenuData) {
        this.managePageService = managePageService;
        this.cmsitemsRestService = cmsitemsRestService;
        this.catalogService = catalogService;
        this.crossFrameEventService = crossFrameEventService;
        this.userTrackingService = userTrackingService;
        this.dropdownMenuData = dropdownMenuData;
        this.isDeletable = false;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.pageInfo = this.dropdownMenuData.selectedItem;
            this.permanentlyDeletePagePermission = [
                {
                    names: ['se.permanently.delete.page.type'],
                    context: {
                        typeCode: this.pageInfo.typeCode
                    }
                }
            ];
            this.unregPageSyncStatusUpdate = this.crossFrameEventService.subscribe(cmscommons.EVENT_PAGE_STATUS_UPDATED_IN_ACTIVE_CV, this.fetchPageDeletableConditions.bind(this));
            yield this.fetchPageDeletableConditions();
        });
    }
    ngOnDestroy() {
        this.unregPageSyncStatusUpdate();
    }
    permanentlyDelete() {
        this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.PAGE_MANAGEMENT, 'Permanently Delete');
        if (this.isDeletable) {
            this.managePageService.hardDeletePage(this.pageInfo);
        }
    }
    isDeleteButtonDisabled() {
        return !this.isDeletable;
    }
    fetchPageDeletableConditions() {
        return __awaiter(this, void 0, void 0, function* () {
            const uriContext = yield this.catalogService.retrieveUriContext();
            const activeVersion = yield this.catalogService.getContentCatalogActiveVersion(uriContext);
            const cmsItemResult = yield this.cmsitemsRestService.get({
                pageSize: 1,
                currentPage: 0,
                typeCode: 'AbstractPage',
                fields: 'BASIC',
                itemSearchParams: `uid:${this.pageInfo.uid}`,
                catalogId: uriContext.CURRENT_CONTEXT_CATALOG,
                catalogVersion: activeVersion
            });
            this.isDeletable =
                cmsItemResult.pagination.totalCount === 0 ||
                    cmsItemResult.response[0].pageStatus === smarteditcommons.CMSPageStatus.DELETED;
        });
    }
};
PermanentlyDeletePageItemComponent.$inject = ["managePageService", "cmsitemsRestService", "catalogService", "crossFrameEventService", "userTrackingService", "dropdownMenuData"];
/* @ngInject */ PermanentlyDeletePageItemComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-permanently-delete-page-item',
        template: `<div *seHasOperationPermission="permanentlyDeletePagePermission"><div class="se-dropdown-item__delete-wrapper"><div class="se-dropdown-item__delete-link-wrapper" [ngClass]="{'se-dropdown-item__delete-link-wrapper--disabled': isDeleteButtonDisabled()}"><a class="se-dropdown-item se-dropdown-item__delete fd-menu__item" [ngClass]="{'se-dropdown-item--disabled': isDeleteButtonDisabled()}" (click)="permanentlyDelete()"><span [translate]="'se.cms.actionitem.page.permanently.delete'"></span></a></div><se-tooltip class="se-dropdown-item__delete-page-popover" *ngIf="isDeleteButtonDisabled()" [placement]="'left'" [triggers]="['mouseenter', 'mouseleave']" [isChevronVisible]="true" [appendTo]="'body'"><span se-tooltip-trigger class="sap-icon--message-error"></span> <span se-tooltip-body [translate]="'se.cms.actionitem.page.permanently.delete.blocked'"></span></se-tooltip></div></div>`,
        styles: [`.se-dropdown-item__delete-wrapper{display:flex;flex-direction:row;align-items:center;width:100%}.se-dropdown-item__delete-page-popover{margin-right:16px}.se-dropdown-item__delete-page-popover .sap-icon--message-error{color:#0a6ed1}.se-dropdown-item__delete-link-wrapper{width:100%}.se-dropdown-item__delete-link-wrapper--disabled{cursor:not-allowed}`]
    }),
    __param(5, core.Inject(smarteditcommons.DROPDOWN_MENU_ITEM_DATA)),
    __metadata("design:paramtypes", [exports.ManagePageService,
        smarteditcommons.CmsitemsRestService,
        smarteditcommons.ICatalogService,
        smarteditcommons.CrossFrameEventService,
        smarteditcommons.UserTrackingService, Object])
], /* @ngInject */ PermanentlyDeletePageItemComponent);

window.__smartedit__.addDecoratorPayload("Component", "EditPageItemComponent", {
    selector: 'se-edit-page-item',
    template: `<div *seHasOperationPermission="editPagePermission"><a class="se-dropdown-item fd-menu__item" (click)="onClickOnEdit()"><span class="se-dropdown-item--label" translate="se.cms.actionitem.page.edit"></span></a></div>`
});
let /* @ngInject */ EditPageItemComponent = class /* @ngInject */ EditPageItemComponent {
    constructor(dropdownMenuData, pageInfoMenuService, userTrackingService) {
        this.dropdownMenuData = dropdownMenuData;
        this.pageInfoMenuService = pageInfoMenuService;
        this.userTrackingService = userTrackingService;
    }
    ngOnInit() {
        this.pageInfo = this.dropdownMenuData.selectedItem;
        this.editPagePermission = [
            {
                names: ['se.edit.page.type'],
                context: {
                    typeCode: this.pageInfo.typeCode
                }
            },
            {
                names: ['se.act.on.page.in.workflow'],
                context: {
                    pageInfo: this.pageInfo
                }
            }
        ];
    }
    onClickOnEdit() {
        this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.PAGE_MANAGEMENT, 'Edit');
        return this.pageInfoMenuService.openPageEditor(this.pageInfo);
    }
};
EditPageItemComponent.$inject = ["dropdownMenuData", "pageInfoMenuService", "userTrackingService"];
/* @ngInject */ EditPageItemComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-edit-page-item',
        template: `<div *seHasOperationPermission="editPagePermission"><a class="se-dropdown-item fd-menu__item" (click)="onClickOnEdit()"><span class="se-dropdown-item--label" translate="se.cms.actionitem.page.edit"></span></a></div>`
    }),
    __param(0, core.Inject(smarteditcommons.DROPDOWN_MENU_ITEM_DATA)),
    __metadata("design:paramtypes", [Object, PageInfoMenuService,
        smarteditcommons.UserTrackingService])
], /* @ngInject */ EditPageItemComponent);

window.__smartedit__.addDecoratorPayload("Component", "ClonePageItemComponent", {
    selector: 'se-clone-page-item',
    template: `<div *seHasOperationPermission="clonePagePermission"><a class="se-dropdown-item fd-menu__item" (click)="onClickOnClone()"><span class="se-dropdown-item--label" translate="se.cms.actionitem.page.clone"></span></a></div>`
});
let /* @ngInject */ ClonePageItemComponent = class /* @ngInject */ ClonePageItemComponent {
    constructor(dropdownMenuData, clonePageWizardService, userTrackingService) {
        this.dropdownMenuData = dropdownMenuData;
        this.clonePageWizardService = clonePageWizardService;
        this.userTrackingService = userTrackingService;
    }
    ngOnInit() {
        this.pageInfo = this.dropdownMenuData.selectedItem;
        this.clonePagePermission = [
            {
                names: ['se.clone.page.type'],
                context: {
                    typeCode: this.pageInfo.typeCode
                }
            }
        ];
    }
    onClickOnClone() {
        this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.PAGE_MANAGEMENT, 'Clone');
        this.clonePageWizardService.openClonePageWizard(this.pageInfo);
    }
};
ClonePageItemComponent.$inject = ["dropdownMenuData", "clonePageWizardService", "userTrackingService"];
/* @ngInject */ ClonePageItemComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-clone-page-item',
        template: `<div *seHasOperationPermission="clonePagePermission"><a class="se-dropdown-item fd-menu__item" (click)="onClickOnClone()"><span class="se-dropdown-item--label" translate="se.cms.actionitem.page.clone"></span></a></div>`
    }),
    __param(0, core.Inject(smarteditcommons.DROPDOWN_MENU_ITEM_DATA)),
    __metadata("design:paramtypes", [Object, ClonePageWizardService,
        smarteditcommons.UserTrackingService])
], /* @ngInject */ ClonePageItemComponent);

window.__smartedit__.addDecoratorPayload("Component", "DeletePageItemComponent", {
    selector: 'se-delete-page-item',
    template: `<div *seHasOperationPermission="deletePagePermission"><div class="se-dropdown-item__delete-wrapper"><div class="se-dropdown-item__delete-link-wrapper" [ngClass]="{'se-dropdown-item__delete-link-wrapper--disabled': !isDeletePageEnabled}"><a class="se-dropdown-item se-dropdown-item__delete fd-menu__item" [ngClass]="{'se-dropdown-item--disabled': !isDeletePageEnabled}" (click)="isDeletePageEnabled && onClickOnDeletePage()"><span class="se-dropdown-item--label" translate="se.cms.actionitem.page.trash"></span></a></div><se-tooltip *ngIf="!isDeletePageEnabled" class="se-dropdown-item__delete-page-popover" [placement]="'left'" [triggers]="['mouseenter', 'mouseleave']" [isChevronVisible]="true" [appendTo]="'body'"><span se-tooltip-trigger class="sap-icon--message-error"></span><div se-tooltip-body class="popover-tooltip"><span [translate]="tooltipMessage"></span></div></se-tooltip></div></div>`,
    styles: [`.se-dropdown-item__delete-wrapper{display:flex;flex-direction:row;align-items:center;width:100%}.se-dropdown-item__delete-page-popover{margin-right:16px}.se-dropdown-item__delete-page-popover .sap-icon--message-error{color:#0a6ed1}.se-dropdown-item__delete-link-wrapper{width:100%}.se-dropdown-item__delete-link-wrapper--disabled{cursor:not-allowed}`]
});
let /* @ngInject */ DeletePageItemComponent = class /* @ngInject */ DeletePageItemComponent {
    constructor(dropdownMenuData, managePageService, systemEventService, catalogService, userTrackingService) {
        this.dropdownMenuData = dropdownMenuData;
        this.managePageService = managePageService;
        this.systemEventService = systemEventService;
        this.catalogService = catalogService;
        this.userTrackingService = userTrackingService;
        this.isDeletePageEnabled = false;
        this.tooltipMessage = 'se.cms.tooltip.movetotrash';
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.pageInfo = this.dropdownMenuData.selectedItem;
            yield this.getDisableDeleteTooltipMessage();
            this.setDeletePermissions();
        });
    }
    onClickOnDeletePage() {
        return __awaiter(this, void 0, void 0, function* () {
            this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.PAGE_MANAGEMENT, 'Trash');
            const uriContext = yield this.catalogService.retrieveUriContext();
            yield this.managePageService.softDeletePage(this.pageInfo, uriContext);
            this.systemEventService.publishAsync(smarteditcommons.EVENT_CONTENT_CATALOG_UPDATE);
        });
    }
    setDeletePermissions() {
        this.deletePagePermission = [
            {
                names: ['se.delete.page.type'],
                context: {
                    typeCode: this.pageInfo.typeCode
                }
            },
            {
                names: ['se.act.on.page.in.workflow'],
                context: {
                    pageInfo: this.pageInfo
                }
            }
        ];
    }
    getDisableDeleteTooltipMessage() {
        return __awaiter(this, void 0, void 0, function* () {
            const uriContext = yield this.catalogService.retrieveUriContext();
            const isEnabled = yield this.managePageService.isPageTrashable(this.pageInfo, uriContext);
            this.isDeletePageEnabled = isEnabled;
            if (this.isDeletePageEnabled) {
                this.tooltipMessage = null;
                return;
            }
            this.tooltipMessage = yield this.managePageService.getDisabledTrashTooltipMessage(this.pageInfo, uriContext);
        });
    }
};
DeletePageItemComponent.$inject = ["dropdownMenuData", "managePageService", "systemEventService", "catalogService", "userTrackingService"];
/* @ngInject */ DeletePageItemComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-delete-page-item',
        template: `<div *seHasOperationPermission="deletePagePermission"><div class="se-dropdown-item__delete-wrapper"><div class="se-dropdown-item__delete-link-wrapper" [ngClass]="{'se-dropdown-item__delete-link-wrapper--disabled': !isDeletePageEnabled}"><a class="se-dropdown-item se-dropdown-item__delete fd-menu__item" [ngClass]="{'se-dropdown-item--disabled': !isDeletePageEnabled}" (click)="isDeletePageEnabled && onClickOnDeletePage()"><span class="se-dropdown-item--label" translate="se.cms.actionitem.page.trash"></span></a></div><se-tooltip *ngIf="!isDeletePageEnabled" class="se-dropdown-item__delete-page-popover" [placement]="'left'" [triggers]="['mouseenter', 'mouseleave']" [isChevronVisible]="true" [appendTo]="'body'"><span se-tooltip-trigger class="sap-icon--message-error"></span><div se-tooltip-body class="popover-tooltip"><span [translate]="tooltipMessage"></span></div></se-tooltip></div></div>`,
        styles: [`.se-dropdown-item__delete-wrapper{display:flex;flex-direction:row;align-items:center;width:100%}.se-dropdown-item__delete-page-popover{margin-right:16px}.se-dropdown-item__delete-page-popover .sap-icon--message-error{color:#0a6ed1}.se-dropdown-item__delete-link-wrapper{width:100%}.se-dropdown-item__delete-link-wrapper--disabled{cursor:not-allowed}`]
    }),
    __param(0, core.Inject(smarteditcommons.DROPDOWN_MENU_ITEM_DATA)),
    __metadata("design:paramtypes", [Object, exports.ManagePageService,
        smarteditcommons.SystemEventService,
        smarteditcommons.ICatalogService,
        smarteditcommons.UserTrackingService])
], /* @ngInject */ DeletePageItemComponent);

window.__smartedit__.addDecoratorPayload("Component", "SynchronizeCatalogComponent", {
    selector: 'se-synchronize-catalog',
    template: `<div class="se-synchronize-catalog"><div class="se-synchronize-catalog__sync-info"><div *ngIf="isSyncJobFinished()"><label class="se-synchronize-catalog__sync-info__sync-label" *ngIf="catalogVersion.active"><span translate="se.cms.cataloginfo.lastsyncedfrom"></span>&nbsp; <span>{{ syncJobStatus.source }}</span></label> <label class="se-synchronize-catalog__sync-info__sync-label" *ngIf="!catalogVersion.active" translate="se.cms.cataloginfo.lastsynced"></label> <span class="se-synchronize-catalog__sync-info__last-synched">{{ syncJobStatus.syncEndTime | date: 'M/d/yy h:mm a' }}</span></div><span class="se-synchronize-catalog__in-progress" *ngIf="isSyncJobInProgress()" translate="se.sync.status.synced.inprogress"></span> <span class="label-error se-synchronize-catalog__sync-failed" *ngIf="isSyncJobFailed()" translate="se.sync.status.synced.syncfailed"></span></div><ng-container *seHasOperationPermission="syncCatalogPermission"><ng-container *ngIf="!catalogVersion.active"><button class="se-synchronize-catalog__sync-btn fd-button--emphasized" [disabled]="!isSyncButtonEnabled()" (click)="syncCatalog()" translate="se.cms.cataloginfo.btn.sync"></button></ng-container></ng-container></div>`,
    styles: [`.se-synchronize-catalog{display:flex;flex-direction:row;align-items:center;justify-content:flex-end}.se-synchronize-catalog__sync-info{display:flex;flex-direction:row;align-items:center}.se-synchronize-catalog__sync-btn{margin-left:20px}.se-synchronize-catalog__sync-info__sync-label:first-child{font-weight:700}.se-synchronize-catalog__sync-info__last-synched,.se-synchronize-catalog__sync-info__sync-label{color:#6a6d70;display:block;text-align:right;margin:0}.se-synchronize-catalog__in-progress{color:#0a7e3e}.se-synchronize-catalog__sync-failed{color:#b00}`],
    providers: [smarteditcommons.L10nPipe],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ SynchronizeCatalogComponent = class /* @ngInject */ SynchronizeCatalogComponent {
    constructor(synchronizationService, confirmationModalService, systemEventService, l10nPipe, cdr, userTrackingService) {
        this.synchronizationService = synchronizationService;
        this.confirmationModalService = confirmationModalService;
        this.systemEventService = systemEventService;
        this.l10nPipe = l10nPipe;
        this.cdr = cdr;
        this.userTrackingService = userTrackingService;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.syncJobStatus = {
                syncStartTime: '',
                syncEndTime: '',
                status: null,
                source: '',
                target: ''
            };
            this.targetCatalogVersion = this.activeCatalogVersion.version;
            this.sourceCatalogVersion = !this.catalogVersion.active
                ? this.catalogVersion.version
                : null;
            this.syncCatalogPermission = [
                {
                    names: ['se.sync.catalog'],
                    context: {
                        catalogId: this.catalog.catalogId,
                        catalogVersion: this.sourceCatalogVersion,
                        targetCatalogVersion: this.targetCatalogVersion
                    }
                }
            ];
            this.catalogDto = {
                catalogId: this.catalog.catalogId,
                targetCatalogVersion: this.targetCatalogVersion,
                sourceCatalogVersion: this.sourceCatalogVersion
            };
            this.synchronizationService.startAutoGetSyncData(this.catalogDto, (job) => this.updateSyncStatusData(job));
            yield this.callGetSyncData();
        });
    }
    ngOnDestroy() {
        this.synchronizationService.stopAutoGetSyncData(this.catalogDto);
    }
    isSyncJobFinished() {
        return this.syncJobStatus.status === cmscommons.JOB_STATUS.FINISHED;
    }
    isSyncJobInProgress() {
        return (this.syncJobStatus.status === cmscommons.JOB_STATUS.RUNNING ||
            this.syncJobStatus.status === cmscommons.JOB_STATUS.UNKNOWN);
    }
    isSyncJobFailed() {
        return (this.syncJobStatus.status === cmscommons.JOB_STATUS.ERROR ||
            this.syncJobStatus.status === cmscommons.JOB_STATUS.FAILURE);
    }
    isSyncButtonEnabled() {
        return !this.isSyncJobInProgress();
    }
    syncCatalog() {
        return __awaiter(this, void 0, void 0, function* () {
            this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.NAVIGATION, 'Sync');
            const catalogName = yield this.translateCatalogName(this.catalog.name);
            yield this.confirmationModalService
                .confirm({
                title: 'se.sync.confirmation.title',
                description: 'se.sync.confirm.msg',
                descriptionPlaceholders: {
                    catalogName
                }
            })
                .catch(() => Promise.reject());
            const job = yield this.synchronizationService.updateCatalogSync(this.catalogDto);
            this.updateSyncStatusData(job);
            this.systemEventService.publishAsync(smarteditcommons.EVENT_CONTENT_CATALOG_UPDATE, job);
        });
    }
    translateCatalogName(catalogName) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.l10nPipe.transform(catalogName).pipe(operators.take(1)).toPromise();
        });
    }
    callGetSyncData() {
        return __awaiter(this, void 0, void 0, function* () {
            const syncStatus = yield this.synchronizationService.getCatalogSyncStatus(this.catalogDto);
            this.updateSyncStatusData(syncStatus);
        });
    }
    updateSyncStatusData(syncStatus) {
        this.syncJobStatus = {
            syncStartTime: syncStatus.creationDate,
            syncEndTime: syncStatus.endDate,
            status: syncStatus.syncStatus,
            source: syncStatus.sourceCatalogVersion ? syncStatus.sourceCatalogVersion : '',
            target: syncStatus.targetCatalogVersion ? syncStatus.targetCatalogVersion : ''
        };
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
    }
};
SynchronizeCatalogComponent.$inject = ["synchronizationService", "confirmationModalService", "systemEventService", "l10nPipe", "cdr", "userTrackingService"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ SynchronizeCatalogComponent.prototype, "catalog", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ SynchronizeCatalogComponent.prototype, "catalogVersion", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ SynchronizeCatalogComponent.prototype, "activeCatalogVersion", void 0);
/* @ngInject */ SynchronizeCatalogComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-synchronize-catalog',
        template: `<div class="se-synchronize-catalog"><div class="se-synchronize-catalog__sync-info"><div *ngIf="isSyncJobFinished()"><label class="se-synchronize-catalog__sync-info__sync-label" *ngIf="catalogVersion.active"><span translate="se.cms.cataloginfo.lastsyncedfrom"></span>&nbsp; <span>{{ syncJobStatus.source }}</span></label> <label class="se-synchronize-catalog__sync-info__sync-label" *ngIf="!catalogVersion.active" translate="se.cms.cataloginfo.lastsynced"></label> <span class="se-synchronize-catalog__sync-info__last-synched">{{ syncJobStatus.syncEndTime | date: 'M/d/yy h:mm a' }}</span></div><span class="se-synchronize-catalog__in-progress" *ngIf="isSyncJobInProgress()" translate="se.sync.status.synced.inprogress"></span> <span class="label-error se-synchronize-catalog__sync-failed" *ngIf="isSyncJobFailed()" translate="se.sync.status.synced.syncfailed"></span></div><ng-container *seHasOperationPermission="syncCatalogPermission"><ng-container *ngIf="!catalogVersion.active"><button class="se-synchronize-catalog__sync-btn fd-button--emphasized" [disabled]="!isSyncButtonEnabled()" (click)="syncCatalog()" translate="se.cms.cataloginfo.btn.sync"></button></ng-container></ng-container></div>`,
        styles: [`.se-synchronize-catalog{display:flex;flex-direction:row;align-items:center;justify-content:flex-end}.se-synchronize-catalog__sync-info{display:flex;flex-direction:row;align-items:center}.se-synchronize-catalog__sync-btn{margin-left:20px}.se-synchronize-catalog__sync-info__sync-label:first-child{font-weight:700}.se-synchronize-catalog__sync-info__last-synched,.se-synchronize-catalog__sync-info__sync-label{color:#6a6d70;display:block;text-align:right;margin:0}.se-synchronize-catalog__in-progress{color:#0a7e3e}.se-synchronize-catalog__sync-failed{color:#b00}`],
        providers: [smarteditcommons.L10nPipe],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [cmscommons.SynchronizationService,
        smarteditcommons.IConfirmationModalService,
        smarteditcommons.SystemEventService,
        smarteditcommons.L10nPipe,
        core.ChangeDetectorRef,
        smarteditcommons.UserTrackingService])
], /* @ngInject */ SynchronizeCatalogComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageSynchronizationHeaderComponent", {
    selector: 'se-page-synchronization-header',
    template: `<ng-container *ngIf="ready"><div class="se-sync-panel-header"><span class="se-sync-panel-header__sub-header" [translate]="getSubHeaderText()"></span></div><div *ngIf="isNewPage()" class="se-sync-panel-new-page"><div class="se-sync-panel-new-page__header" translate="se.cms.synchronization.page.new.header"></div><div class="se-sync-panel-new-page__message">{{ headerText }}</div></div><div class="se-sync-panel-header__timestamp" *ngIf="!isNewPage()"><div translate="se.cms.synchronization.panel.lastsync.text"></div><span class="se-sync-panel-header__timestamp-text">{{ syncStatus.lastSyncStatus | date: 'M/d/yy h:mm a' }}</span></div></ng-container>`,
    styles: [`.se-sync-panel-header{padding:0 20px 20px;border-bottom:1px solid #d9d9d9;min-width:400px}.se-sync-panel-header__sub-header{padding-top:4px;color:#51555a}.se-sync-panel-header__timestamp{font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;color:#51555a;position:absolute;left:20px;bottom:23px;width:150px}.se-sync-panel-new-page{padding:20px}.se-sync-panel-new-page__header{font-weight:700;padding-bottom:4px}.se-sync-panel-new-page__message{white-space:normal}`],
    providers: [smarteditcommons.L10nPipe],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ PageSynchronizationHeaderComponent = class /* @ngInject */ PageSynchronizationHeaderComponent {
    constructor(sharedDataService, catalogService, cmsitemsRestService, translateService, l10nPipe, cdr) {
        this.sharedDataService = sharedDataService;
        this.catalogService = catalogService;
        this.cmsitemsRestService = cmsitemsRestService;
        this.translateService = translateService;
        this.l10nPipe = l10nPipe;
        this.cdr = cdr;
        this.ready = false;
    }
    ngOnChanges() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.syncStatus) {
                return;
            }
            this.ready = false;
            yield this.updateHeaderText();
            this.ready = true;
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    getSubHeaderText() {
        if (this.isDefaultSubHeader()) {
            return 'se.cms.synchronization.page.header';
        }
        else if (this.isSyncOldHomeHeader()) {
            return 'se.cms.synchronization.page.header.old.homepage';
        }
    }
    isNewPage() {
        return this.pageSyncConditions.pageHasNoDepOrNoSyncStatus;
    }
    isSyncOldHomeHeader() {
        return (this.pageSyncConditions.pageHasSyncStatus && !this.pageSyncConditions.canSyncHomepage);
    }
    isDefaultSubHeader() {
        return !this.isSyncOldHomeHeader() && !this.isNewPage();
    }
    updateHeaderText() {
        return __awaiter(this, void 0, void 0, function* () {
            const experience = (yield this.sharedDataService.get(smarteditcommons.EXPERIENCE_STORAGE_KEY));
            const { catalogId, catalogName } = yield this.getCurrentCatalogIdFromExperience(experience);
            const catalogVersion = yield this.catalogService.getActiveContentCatalogVersionByCatalogId(catalogId);
            const itemNames = yield (this.pageSyncConditions.pageHasUnavailableDependencies
                ? this.fetchUnavailableDependencies()
                : null);
            this.headerText = this.pageSyncConditions.pageHasUnavailableDependencies
                ? this.translateService.instant('se.cms.synchronization.page.unavailable.items.description', {
                    itemNames,
                    catalogName,
                    catalogVersion
                })
                : this.translateService.instant('se.cms.synchronization.page.new.description', {
                    catalogName,
                    catalogVersion
                });
        });
    }
    userIsInsidePage(pageContext) {
        return !!pageContext;
    }
    getCurrentCatalogIdFromExperience({ pageContext, catalogDescriptor }) {
        return __awaiter(this, void 0, void 0, function* () {
            const catalogId = this.userIsInsidePage(pageContext)
                ? pageContext.catalogId
                : catalogDescriptor.catalogId;
            const catalogName = this.userIsInsidePage(pageContext)
                ? pageContext.catalogName
                : catalogDescriptor.name;
            const catalogNameTranslated = yield this.l10nPipe
                .transform(catalogName)
                .pipe(operators.take(1))
                .toPromise();
            return {
                catalogId,
                catalogName: catalogNameTranslated
            };
        });
    }
    fetchUnavailableDependencies() {
        const itemIds = this.syncStatus.unavailableDependencies.map(({ itemId }) => itemId);
        return this.cmsitemsRestService
            .getByIds(itemIds)
            .then(({ response }) => response.map(({ name }) => name).join(', '));
    }
};
PageSynchronizationHeaderComponent.$inject = ["sharedDataService", "catalogService", "cmsitemsRestService", "translateService", "l10nPipe", "cdr"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ PageSynchronizationHeaderComponent.prototype, "syncStatus", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ PageSynchronizationHeaderComponent.prototype, "pageSyncConditions", void 0);
/* @ngInject */ PageSynchronizationHeaderComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-synchronization-header',
        template: `<ng-container *ngIf="ready"><div class="se-sync-panel-header"><span class="se-sync-panel-header__sub-header" [translate]="getSubHeaderText()"></span></div><div *ngIf="isNewPage()" class="se-sync-panel-new-page"><div class="se-sync-panel-new-page__header" translate="se.cms.synchronization.page.new.header"></div><div class="se-sync-panel-new-page__message">{{ headerText }}</div></div><div class="se-sync-panel-header__timestamp" *ngIf="!isNewPage()"><div translate="se.cms.synchronization.panel.lastsync.text"></div><span class="se-sync-panel-header__timestamp-text">{{ syncStatus.lastSyncStatus | date: 'M/d/yy h:mm a' }}</span></div></ng-container>`,
        styles: [`.se-sync-panel-header{padding:0 20px 20px;border-bottom:1px solid #d9d9d9;min-width:400px}.se-sync-panel-header__sub-header{padding-top:4px;color:#51555a}.se-sync-panel-header__timestamp{font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;color:#51555a;position:absolute;left:20px;bottom:23px;width:150px}.se-sync-panel-new-page{padding:20px}.se-sync-panel-new-page__header{font-weight:700;padding-bottom:4px}.se-sync-panel-new-page__message{white-space:normal}`],
        providers: [smarteditcommons.L10nPipe],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [smarteditcommons.ISharedDataService,
        smarteditcommons.ICatalogService,
        smarteditcommons.CmsitemsRestService,
        core$1.TranslateService,
        smarteditcommons.L10nPipe,
        core.ChangeDetectorRef])
], /* @ngInject */ PageSynchronizationHeaderComponent);

/*
 * Copyright (c) 2022 SAP SE or an SAP affiliate company. All rights reserved.
 */
const PAGE_SYNC_STATUS_READY = 'PAGE_SYNC_STATUS_READY';

window.__smartedit__.addDecoratorPayload("Component", "PageSynchronizationPanelComponent", {
    selector: 'se-page-synchronization-panel',
    template: `<se-page-synchronization-header class="se-sync-panel__sync-status" [syncStatus]="syncStatus" [pageSyncConditions]="pageSyncConditions"></se-page-synchronization-header><se-synchronization-panel *ngIf="!showFooter" [itemId]="cmsPage.uuid" [showFooter]="false" [getSyncStatus]="getSyncStatus" [performSync]="performSync" (selectedItemsUpdate)="onSelectedItemsUpdate($event)" (syncStatusReady)="onSyncStatusReady($event)" (getApi)="onGetApi($event)"></se-synchronization-panel><se-synchronization-panel *ngIf="showFooter" [itemId]="cmsPage.uuid" [getSyncStatus]="getSyncStatus" [performSync]="performSync" (syncStatusReady)="onSyncStatusReady($event)" (getApi)="onGetApi($event)"></se-synchronization-panel>`
});
let /* @ngInject */ PageSynchronizationPanelComponent = class /* @ngInject */ PageSynchronizationPanelComponent {
    constructor(pageService, homepageService, crossFrameEventService, syncPollingService, translateService) {
        this.pageService = pageService;
        this.homepageService = homepageService;
        this.crossFrameEventService = crossFrameEventService;
        this.syncPollingService = syncPollingService;
        this.translateService = translateService;
        this.getSyncStatus = () => __awaiter(this, void 0, void 0, function* () {
            const [canSyncHomepage, syncStatus] = yield Promise.all([
                this.homepageService.canSyncHomepage(this.cmsPage, this.uriContext),
                this.syncPollingService.getSyncStatus(this.cmsPage.uuid, this.uriContext),
                this.evaluateIfSyncIsApproved()
            ]);
            this.pageSyncConditions.canSyncHomepage = canSyncHomepage;
            this.syncStatus = syncStatus;
            return this.syncStatus;
        });
        this.performSync = (items) => this.syncPollingService.performSync(items, this.uriContext);
        this.syncStatusReady = (syncStatus) => {
            this.pageSyncConditions.pageHasUnavailableDependencies =
                syncStatus.unavailableDependencies.length > 0;
            this.pageSyncConditions.pageHasSyncStatus = !!syncStatus.lastSyncStatus;
            this.pageSyncConditions.pageHasNoDepOrNoSyncStatus =
                this.pageSyncConditions.pageHasUnavailableDependencies ||
                    !this.pageSyncConditions.pageHasSyncStatus;
            this.pageSyncConditions = lodash.cloneDeep(this.pageSyncConditions);
            if (this.pageSyncConditions.pageHasUnavailableDependencies) {
                this.hidePageSync();
            }
            else if (!this.pageSyncConditions.pageHasSyncStatus) {
                this.showPageSync();
            }
            else {
                this.enableSlotsSync();
            }
            this.crossFrameEventService.publish(PAGE_SYNC_STATUS_READY, this.pageSyncConditions);
        };
        this.selectedItemsUpdate = new core.EventEmitter();
        this.showFooter = true;
        this.syncStatus = null;
        this.pageSyncConditions = {
            canSyncHomepage: false,
            pageHasUnavailableDependencies: false,
            pageHasSyncStatus: false,
            pageHasNoDepOrNoSyncStatus: false
        };
    }
    ngOnInit() {
        this.unSubPageUpdatedEvent = this.crossFrameEventService.subscribe(smarteditcommons.EVENTS.PAGE_UPDATED, () => this.evaluateIfSyncIsApproved());
    }
    ngOnDestroy() {
        this.unSubPageUpdatedEvent();
    }
    onGetApi(api) {
        this.synchronizationPanelApi = api;
        this.synchronizationPanelApi.disableItem = (item) => !this.pageSyncConditions.canSyncHomepage && item === this.syncStatus;
    }
    onSyncStatusReady(syncStatus) {
        this.syncStatusReady(syncStatus);
    }
    onSelectedItemsUpdate(items) {
        this.selectedItemsUpdate.emit(items);
    }
    syncItems() {
        return this.synchronizationPanel.syncItems();
    }
    evaluateIfSyncIsApproved() {
        return __awaiter(this, void 0, void 0, function* () {
            const isPageApproved = yield this.pageService.isPageApproved(this.cmsPage.uuid);
            if (!isPageApproved) {
                this.disablePageSync();
            }
        });
    }
    disablePageSync() {
        this.synchronizationPanelApi.setMessage({
            type: smarteditcommons.IAlertServiceType.WARNING,
            description: this.translateService.instant('se.cms.synchronization.slot.disabled.msg')
        });
        this.synchronizationPanelApi.disableItemList(true);
    }
    hidePageSync() {
        this.synchronizationPanelApi.displayItemList(false);
    }
    showPageSync() {
        this.synchronizationPanelApi.selectAll();
        this.synchronizationPanelApi.displayItemList(false);
    }
    enableSlotsSync() {
        this.synchronizationPanelApi.displayItemList(true);
    }
};
PageSynchronizationPanelComponent.$inject = ["pageService", "homepageService", "crossFrameEventService", "syncPollingService", "translateService"];
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ PageSynchronizationPanelComponent.prototype, "selectedItemsUpdate", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ PageSynchronizationPanelComponent.prototype, "uriContext", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ PageSynchronizationPanelComponent.prototype, "cmsPage", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], /* @ngInject */ PageSynchronizationPanelComponent.prototype, "showFooter", void 0);
__decorate([
    core.ViewChild(cmscommons.SynchronizationPanelComponent, { static: false }),
    __metadata("design:type", cmscommons.SynchronizationPanelComponent)
], /* @ngInject */ PageSynchronizationPanelComponent.prototype, "synchronizationPanel", void 0);
/* @ngInject */ PageSynchronizationPanelComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-synchronization-panel',
        template: `<se-page-synchronization-header class="se-sync-panel__sync-status" [syncStatus]="syncStatus" [pageSyncConditions]="pageSyncConditions"></se-page-synchronization-header><se-synchronization-panel *ngIf="!showFooter" [itemId]="cmsPage.uuid" [showFooter]="false" [getSyncStatus]="getSyncStatus" [performSync]="performSync" (selectedItemsUpdate)="onSelectedItemsUpdate($event)" (syncStatusReady)="onSyncStatusReady($event)" (getApi)="onGetApi($event)"></se-synchronization-panel><se-synchronization-panel *ngIf="showFooter" [itemId]="cmsPage.uuid" [getSyncStatus]="getSyncStatus" [performSync]="performSync" (syncStatusReady)="onSyncStatusReady($event)" (getApi)="onGetApi($event)"></se-synchronization-panel>`
    }),
    __metadata("design:paramtypes", [smarteditcommons.IPageService,
        exports.HomepageService,
        smarteditcommons.CrossFrameEventService,
        smarteditcommons.ISyncPollingService,
        core$1.TranslateService])
], /* @ngInject */ PageSynchronizationPanelComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageSynchronizationPanelModalComponent", {
    selector: 'se-page-synchronization-panel-modal',
    template: `
        <se-page-synchronization-panel
            *ngIf="isReady"
            (selectedItemsUpdate)="onSelectedItemsUpdate($event)"
            [uriContext]="data.uriContext"
            [cmsPage]="data.cmsPage"
            [showFooter]="false"
        ></se-page-synchronization-panel>
    `,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let PageSynchronizationPanelModalComponent = class PageSynchronizationPanelModalComponent {
    constructor(modalManager, cdr) {
        this.modalManager = modalManager;
        this.cdr = cdr;
        this.syncBtnId = 'sync';
    }
    ngOnInit() {
        this.modalManager.addButtons([
            {
                id: this.syncBtnId,
                label: 'se.cms.actionitem.page.sync',
                style: smarteditcommons.ModalButtonStyle.Primary,
                action: smarteditcommons.ModalButtonAction.Close,
                disabled: true,
                callback: () => rxjs.from(this.pageSynchronizationPanelComponent.syncItems())
            },
            {
                id: 'cancel',
                label: 'se.cms.component.confirmation.modal.cancel',
                style: smarteditcommons.ModalButtonStyle.Default,
                action: smarteditcommons.ModalButtonAction.Dismiss
            }
        ]);
        this.modalManager
            .getModalData()
            .pipe(operators.take(1))
            .subscribe((data) => {
            this.data = data;
            this.isReady = true;
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    onSelectedItemsUpdate(selectedItems) {
        if (selectedItems.length === 0 ||
            this.data.cmsPage.displayStatus !== 'READY_TO_SYNC' // draft or in process page can't be synced from page list
        ) {
            this.modalManager.disableButton(this.syncBtnId);
            return;
        }
        this.modalManager.enableButton(this.syncBtnId);
    }
};
__decorate([
    core.ViewChild(PageSynchronizationPanelComponent, { static: false }),
    __metadata("design:type", PageSynchronizationPanelComponent)
], PageSynchronizationPanelModalComponent.prototype, "pageSynchronizationPanelComponent", void 0);
PageSynchronizationPanelModalComponent = __decorate([
    core.Component({
        selector: 'se-page-synchronization-panel-modal',
        template: `
        <se-page-synchronization-panel
            *ngIf="isReady"
            (selectedItemsUpdate)="onSelectedItemsUpdate($event)"
            [uriContext]="data.uriContext"
            [cmsPage]="data.cmsPage"
            [showFooter]="false"
        ></se-page-synchronization-panel>
    `,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [smarteditcommons.ModalManagerService,
        core.ChangeDetectorRef])
], PageSynchronizationPanelModalComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageSyncMenuToolbarItemComponent", {
    selector: 'se-page-sync-menu-toolbar-item',
    template: `<ng-container *seHasOperationPermission="'se.sync.catalog'"><fd-popover [(isOpen)]="toolbarItem.isOpen" [closeOnOutsideClick]="true"><fd-popover-control><button type="button" class="btn toolbar-action--button" [attr.aria-expanded]="toolbarItem.isOpen"><span class="icon-synchronize se-toolbar-menu-ddlb--button__icon"><span *ngIf="isNotInSync" class="hyicon hyicon-caution se-toolbar-menu-ddlb--button__caution"></span> </span><span class="toolbar-action-button__txt" [ngClass]="{'se-toolbar-menu-ddlb--button__txt': isNotInSync }" [translate]="toolbarItem.name"></span></button></fd-popover-control><fd-popover-body><div *ngIf="toolbarItem.isOpen && isReady" class="toolbar-action--include se-sync-menu-content__dropdown"><se-prevent-vertical-overflow><div class="se-sync-menu-content__header"><span class="se-sync-menu-content__header-title" translate="se.cms.synchronization.page.title"></span><se-help *ngIf="!syncPageConditions?.canSyncHomepage && !syncPageConditions?.pageHasNoDepOrNoSyncStatus" class="se-page-sync__y-help"><span>{{ helpText }}</span></se-help></div><se-page-synchronization-panel [cmsPage]="cmsPage" [uriContext]="uriContext"></se-page-synchronization-panel></se-prevent-vertical-overflow></div></fd-popover-body></fd-popover></ng-container>`,
    styles: [`.se-toolbar-menu-ddlb--button__icon{position:relative}.se-toolbar-menu-ddlb--button__caution{position:absolute;color:#e9730c;right:-9px;bottom:1px}.se-sync-menu-content__header{padding:15px 20px 0}.se-sync-menu-content__header-title{text-transform:capitalize;font-size:1.1428571429rem;line-height:1.25;font-weight:400;color:#32363a}.se-sync-menu-content__dropdown{box-shadow:0 6px 12px rgba(0,0,0,.175);background-color:#fff;border-radius:4px!important;min-width:100px;width:fit-content;position:absolute;border:1px solid #d9d9d9;z-index:2000;top:96%;max-width:400px}.se-sync-menu-content__dropdown::before{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#d9d9d9;border-bottom-color:var(var(--fd-color-neutral-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-8px}.se-sync-menu-content__dropdown::after{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#fff;border-bottom-color:var(var(--fd-color-background-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-7px}.se-sync-menu-content__dropdown::after,.se-sync-menu-content__dropdown::before{left:14px}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ PageSyncMenuToolbarItemComponent = class /* @ngInject */ PageSyncMenuToolbarItemComponent {
    constructor(crossFrameEventService, systemEventService, catalogService, pageService, pageInfoService, syncPollingService, translateService, logService, cdr, toolbarItem) {
        this.crossFrameEventService = crossFrameEventService;
        this.systemEventService = systemEventService;
        this.catalogService = catalogService;
        this.pageService = pageService;
        this.pageInfoService = pageInfoService;
        this.syncPollingService = syncPollingService;
        this.translateService = translateService;
        this.logService = logService;
        this.cdr = cdr;
        this.toolbarItem = toolbarItem;
        this.isReady = false;
    }
    ngOnInit() {
        this.unRegisterPageChange = this.crossFrameEventService.subscribe(smarteditcommons.EVENTS.PAGE_CHANGE, () => this.setup());
        this.unRegisterSyncPageConditions = this.systemEventService.subscribe(PAGE_SYNC_STATUS_READY, (_event, syncPageConditions) => {
            this.syncPageConditions = syncPageConditions;
            this.setHelpText();
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
        return this.setup();
    }
    ngOnDestroy() {
        this.unRegisterSyncPageConditions();
        this.unRegisterPageChange();
        if (this.unRegisterSyncPolling) {
            this.unRegisterSyncPolling();
        }
    }
    setup() {
        return __awaiter(this, void 0, void 0, function* () {
            this.isReady = false;
            this.isNotInSync = false;
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
            try {
                [this.cmsPage, this.uriContext] = yield this.fetchSynchronizationPanelInfo();
                const isNonActive = yield this.catalogService.isContentCatalogVersionNonActive();
                if (!isNonActive) {
                    return;
                }
            }
            catch (error) {
                this.logService.error('Failed to setup PageSyncMenuToolbarItemComponent', error);
                return;
            }
            this.subscribeSyncPolling();
            this.fetchSyncStatusAndSetIsNotInSync();
            this.isReady = true;
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    fetchSynchronizationPanelInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.all([
                this.pageService.getCurrentPageInfo(),
                this.catalogService.retrieveUriContext()
            ]).catch((error) => {
                this.logService.error('Failed to fetch Synchronization Panel Info', error);
                throw new Error(error);
            });
        });
    }
    subscribeSyncPolling() {
        if (this.unRegisterSyncPolling) {
            this.unRegisterSyncPolling();
        }
        this.unRegisterSyncPolling = this.crossFrameEventService.subscribe(cmscommons.DEFAULT_SYNCHRONIZATION_POLLING.FAST_FETCH, () => this.fetchSyncStatusAndSetIsNotInSync());
    }
    fetchSyncStatusAndSetIsNotInSync() {
        return __awaiter(this, void 0, void 0, function* () {
            const syncStatus = yield this.fetchSyncStatus();
            this.isNotInSync = !cmscommons.synchronizationUtils.isInSync(syncStatus);
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    fetchSyncStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            const pageUUID = yield this.pageInfoService.getPageUUID();
            return this.syncPollingService.getSyncStatus(pageUUID);
        });
    }
    setHelpText() {
        let helpText = this.translateService.instant('se.cms.synchronization.page.header');
        if (!this.syncPageConditions.pageHasNoDepOrNoSyncStatus) {
            helpText += ` ${this.translateService.instant('se.cms.synchronization.page.header.help')}`;
        }
        this.helpText = helpText;
    }
};
PageSyncMenuToolbarItemComponent.$inject = ["crossFrameEventService", "systemEventService", "catalogService", "pageService", "pageInfoService", "syncPollingService", "translateService", "logService", "cdr", "toolbarItem"];
/* @ngInject */ PageSyncMenuToolbarItemComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-sync-menu-toolbar-item',
        template: `<ng-container *seHasOperationPermission="'se.sync.catalog'"><fd-popover [(isOpen)]="toolbarItem.isOpen" [closeOnOutsideClick]="true"><fd-popover-control><button type="button" class="btn toolbar-action--button" [attr.aria-expanded]="toolbarItem.isOpen"><span class="icon-synchronize se-toolbar-menu-ddlb--button__icon"><span *ngIf="isNotInSync" class="hyicon hyicon-caution se-toolbar-menu-ddlb--button__caution"></span> </span><span class="toolbar-action-button__txt" [ngClass]="{'se-toolbar-menu-ddlb--button__txt': isNotInSync }" [translate]="toolbarItem.name"></span></button></fd-popover-control><fd-popover-body><div *ngIf="toolbarItem.isOpen && isReady" class="toolbar-action--include se-sync-menu-content__dropdown"><se-prevent-vertical-overflow><div class="se-sync-menu-content__header"><span class="se-sync-menu-content__header-title" translate="se.cms.synchronization.page.title"></span><se-help *ngIf="!syncPageConditions?.canSyncHomepage && !syncPageConditions?.pageHasNoDepOrNoSyncStatus" class="se-page-sync__y-help"><span>{{ helpText }}</span></se-help></div><se-page-synchronization-panel [cmsPage]="cmsPage" [uriContext]="uriContext"></se-page-synchronization-panel></se-prevent-vertical-overflow></div></fd-popover-body></fd-popover></ng-container>`,
        styles: [`.se-toolbar-menu-ddlb--button__icon{position:relative}.se-toolbar-menu-ddlb--button__caution{position:absolute;color:#e9730c;right:-9px;bottom:1px}.se-sync-menu-content__header{padding:15px 20px 0}.se-sync-menu-content__header-title{text-transform:capitalize;font-size:1.1428571429rem;line-height:1.25;font-weight:400;color:#32363a}.se-sync-menu-content__dropdown{box-shadow:0 6px 12px rgba(0,0,0,.175);background-color:#fff;border-radius:4px!important;min-width:100px;width:fit-content;position:absolute;border:1px solid #d9d9d9;z-index:2000;top:96%;max-width:400px}.se-sync-menu-content__dropdown::before{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#d9d9d9;border-bottom-color:var(var(--fd-color-neutral-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-8px}.se-sync-menu-content__dropdown::after{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#fff;border-bottom-color:var(var(--fd-color-background-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-7px}.se-sync-menu-content__dropdown::after,.se-sync-menu-content__dropdown::before{left:14px}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(9, core.Inject(smarteditcommons.TOOLBAR_ITEM)),
    __metadata("design:paramtypes", [smarteditcommons.CrossFrameEventService,
        smarteditcommons.SystemEventService,
        smarteditcommons.ICatalogService,
        smarteditcommons.IPageService,
        smarteditcommons.IPageInfoService,
        smarteditcommons.ISyncPollingService,
        core$1.TranslateService,
        smarteditcommons.LogService,
        core.ChangeDetectorRef, Object])
], /* @ngInject */ PageSyncMenuToolbarItemComponent);

window.__smartedit__.addDecoratorPayload("Component", "CatalogDetailsSyncComponent", {
    selector: 'se-catalog-details-sync',
    template: `
        <se-synchronize-catalog
            [catalog]="catalogDetails.catalog"
            [catalogVersion]="catalogDetails.catalogVersion"
            [activeCatalogVersion]="catalogDetails.activeCatalogVersion"
        >
        </se-synchronize-catalog>
    `
});
let /* @ngInject */ CatalogDetailsSyncComponent = class /* @ngInject */ CatalogDetailsSyncComponent {
    constructor(catalogDetails) {
        this.catalogDetails = catalogDetails;
    }
};
CatalogDetailsSyncComponent.$inject = ["catalogDetails"];
/* @ngInject */ CatalogDetailsSyncComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-catalog-details-sync',
        template: `
        <se-synchronize-catalog
            [catalog]="catalogDetails.catalog"
            [catalogVersion]="catalogDetails.catalogVersion"
            [activeCatalogVersion]="catalogDetails.activeCatalogVersion"
        >
        </se-synchronize-catalog>
    `
    }),
    __param(0, core.Inject(smarteditcommons.CATALOG_DETAILS_ITEM_DATA)),
    __metadata("design:paramtypes", [Object])
], /* @ngInject */ CatalogDetailsSyncComponent);

let SynchronizationModule = class SynchronizationModule {
};
SynchronizationModule = __decorate([
    core.NgModule({
        imports: [
            common.CommonModule,
            smarteditcommons.TranslationModule.forChild(),
            core$2.PopoverModule,
            smarteditcommons.L10nPipeModule,
            smarteditcommons.HasOperationPermissionDirectiveModule,
            cmscommons.SynchronizationPanelModule,
            smarteditcommons.PreventVerticalOverflowModule,
            smarteditcommons.HelpModule
        ],
        declarations: [
            SynchronizeCatalogComponent,
            PageSynchronizationHeaderComponent,
            PageSynchronizationPanelComponent,
            PageSynchronizationPanelModalComponent,
            PageSyncMenuToolbarItemComponent,
            CatalogDetailsSyncComponent
        ],
        entryComponents: [
            SynchronizeCatalogComponent,
            PageSynchronizationHeaderComponent,
            PageSynchronizationPanelComponent,
            PageSynchronizationPanelModalComponent,
            PageSyncMenuToolbarItemComponent,
            CatalogDetailsSyncComponent
        ]
    })
], SynchronizationModule);

window.__smartedit__.addDecoratorPayload("Component", "SyncPageItemComponent", {
    selector: 'se-sync-page-item',
    template: `<div *seHasOperationPermission="syncPagePermission"><a class="se-dropdown-item fd-menu__item" (click)="sync()" translate="se.cms.actionitem.page.sync"></a></div>`,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ SyncPageItemComponent = class /* @ngInject */ SyncPageItemComponent {
    constructor(dropdownMenuData, catalogService, systemEventService, modalService, logService, userTrackingService) {
        this.dropdownMenuData = dropdownMenuData;
        this.catalogService = catalogService;
        this.systemEventService = systemEventService;
        this.modalService = modalService;
        this.logService = logService;
        this.userTrackingService = userTrackingService;
    }
    ngOnInit() {
        this.pageInfo = this.dropdownMenuData.selectedItem;
        this.syncPagePermission = [
            {
                names: ['se.act.on.page.in.workflow'],
                context: {
                    pageInfo: this.pageInfo
                }
            }
        ];
    }
    sync() {
        return __awaiter(this, void 0, void 0, function* () {
            this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.PAGE_MANAGEMENT, 'Sync');
            const uriContext = yield this.catalogService.retrieveUriContext();
            try {
                yield this.modalService
                    .open({
                    component: PageSynchronizationPanelModalComponent,
                    templateConfig: {
                        title: 'se.cms.synchronization.pagelist.modal.title.prefix',
                        titleSuffix: 'se.cms.pageeditormodal.editpagetab.title'
                    },
                    config: {
                        modalPanelClass: 'modal-md'
                    },
                    data: {
                        cmsPage: this.pageInfo,
                        uriContext
                    }
                })
                    .afterClosed.toPromise();
                this.systemEventService.publishAsync(smarteditcommons.EVENT_CONTENT_CATALOG_UPDATE);
            }
            catch (error) {
                this.logService.debug('Page Synchronization Panel Modal dismissed', error);
            }
        });
    }
};
SyncPageItemComponent.$inject = ["dropdownMenuData", "catalogService", "systemEventService", "modalService", "logService", "userTrackingService"];
/* @ngInject */ SyncPageItemComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-sync-page-item',
        template: `<div *seHasOperationPermission="syncPagePermission"><a class="se-dropdown-item fd-menu__item" (click)="sync()" translate="se.cms.actionitem.page.sync"></a></div>`,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(0, core.Inject(smarteditcommons.DROPDOWN_MENU_ITEM_DATA)),
    __metadata("design:paramtypes", [Object, smarteditcommons.ICatalogService,
        smarteditcommons.SystemEventService,
        smarteditcommons.IModalService,
        smarteditcommons.LogService,
        smarteditcommons.UserTrackingService])
], /* @ngInject */ SyncPageItemComponent);

window.__smartedit__.addDecoratorPayload("Component", "TrashListDropdownItemsWrapperComponent", {
    selector: 'se-trash-list-dropdown-items-wrapper',
    template: `<div
        *seHasOperationPermission="'se.edit.page'"
        class="paged-list-table__body__td paged-list-table__body__td-menu"
    >
        <se-dropdown-menu
            [dropdownItems]="dropdownItems"
            [selectedItem]="item"
            class="pull-right"
        ></se-dropdown-menu>
    </div>`,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let TrashListDropdownItemsWrapperComponent = class TrashListDropdownItemsWrapperComponent {
    constructor(route, data, catalogVersionPermissionService, cdr) {
        this.route = route;
        this.data = data;
        this.catalogVersionPermissionService = catalogVersionPermissionService;
        this.cdr = cdr;
        this.dropdownItems = [];
        this.loaded = false;
    }
    ngOnInit() {
        return this.setDropdownItems();
    }
    setDropdownItems() {
        return __awaiter(this, void 0, void 0, function* () {
            this.item = this.data.item;
            const canSynchronize = yield this.catalogVersionPermissionService.hasSyncPermissionToActiveCatalogVersion(this.route.snapshot.params.catalogId, this.route.snapshot.params.catalogVersion);
            this.addDropdownItem(RestorePageItemComponent);
            if (canSynchronize) {
                this.addDropdownItem(UpdatePageStatusComponent);
            }
            this.addDropdownItem(PermanentlyDeletePageItemComponent);
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    addDropdownItem(item) {
        this.dropdownItems = this.dropdownItems.concat({
            component: item
        });
    }
};
TrashListDropdownItemsWrapperComponent = __decorate([
    core.Component({
        selector: 'se-trash-list-dropdown-items-wrapper',
        template: `<div
        *seHasOperationPermission="'se.edit.page'"
        class="paged-list-table__body__td paged-list-table__body__td-menu"
    >
        <se-dropdown-menu
            [dropdownItems]="dropdownItems"
            [selectedItem]="item"
            class="pull-right"
        ></se-dropdown-menu>
    </div>`,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(1, core.Inject(smarteditcommons.DATA_TABLE_COMPONENT_DATA)),
    __metadata("design:paramtypes", [router.ActivatedRoute, Object, smarteditcommons.ICatalogVersionPermissionService,
        core.ChangeDetectorRef])
], TrashListDropdownItemsWrapperComponent);

window.__smartedit__.addDecoratorPayload("Component", "BaseWrapperComponent", {
    template: ''
});
let BaseWrapperComponent = class BaseWrapperComponent {
    constructor(data) {
        this.data = data;
    }
    ngOnInit() {
        this.item = this.data.item;
    }
};
BaseWrapperComponent = __decorate([
    core.Component({
        template: ''
    }),
    __param(0, core.Inject(smarteditcommons.DATA_TABLE_COMPONENT_DATA)),
    __metadata("design:paramtypes", [Object])
], BaseWrapperComponent);

window.__smartedit__.addDecoratorPayload("Component", "ModifiedTimeWrapperComponent", {
    selector: 'se-modified-time-wrapper',
    template: `<div>{{ item.modifiedtime | date: 'short' }}</div>`
});
let ModifiedTimeWrapperComponent = class ModifiedTimeWrapperComponent extends BaseWrapperComponent {
};
ModifiedTimeWrapperComponent = __decorate([
    core.Component({
        selector: 'se-modified-time-wrapper',
        template: `<div>{{ item.modifiedtime | date: 'short' }}</div>`
    })
], ModifiedTimeWrapperComponent);

window.__smartedit__.addDecoratorPayload("Component", "NumberOfRestrictionsWrapperComponent", {
    selector: 'se-number-of-restrictions-wrapper',
    template: `<se-restrictions-viewer [restrictions]="item.restrictions"></se-restrictions-viewer>`
});
let NumberOfRestrictionsWrapperComponent = class NumberOfRestrictionsWrapperComponent extends BaseWrapperComponent {
};
NumberOfRestrictionsWrapperComponent = __decorate([
    core.Component({
        selector: 'se-number-of-restrictions-wrapper',
        template: `<se-restrictions-viewer [restrictions]="item.restrictions"></se-restrictions-viewer>`
    })
], NumberOfRestrictionsWrapperComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageStatusWrapperComponent", {
    selector: 'se-page-status-wrapper',
    template: `<div>
        <se-page-display-status
            [cmsPage]="item"
            [showLastSyncTime]="false"
        ></se-page-display-status>
    </div>`
});
let PageStatusWrapperComponent = class PageStatusWrapperComponent extends BaseWrapperComponent {
};
PageStatusWrapperComponent = __decorate([
    core.Component({
        selector: 'se-page-status-wrapper',
        template: `<div>
        <se-page-display-status
            [cmsPage]="item"
            [showLastSyncTime]="false"
        ></se-page-display-status>
    </div>`
    })
], PageStatusWrapperComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageNameWrapperComponent", {
    selector: 'se-page-name-wrapper',
    template: `
        <a href="" (click)="goToPage($event)">
            <se-homepage-icon
                class="homepage-icon__page-list"
                [cmsPage]="item"
                [uriContext]="uriContext"
            ></se-homepage-icon>
            {{ item.name }}
        </a>
    `
});
let PageNameWrapperComponent = class PageNameWrapperComponent {
    constructor(data, route, experienceService, urlService) {
        this.data = data;
        this.route = route;
        this.experienceService = experienceService;
        this.urlService = urlService;
    }
    ngOnInit() {
        this.item = this.data.item;
        ({
            siteId: this.siteUid,
            catalogId: this.catalogId,
            catalogVersion: this.catalogVersion
        } = this.route.snapshot.params);
        this.uriContext = lodash.merge(this.urlService.buildUriContext(this.siteUid, this.catalogId, this.catalogVersion), this.urlService.buildPageUriContext(this.siteUid, this.catalogId, this.catalogVersion));
    }
    goToPage(event) {
        event.preventDefault();
        if (this.item.uid) {
            this.experienceService.loadExperience({
                siteId: this.siteUid,
                catalogId: this.catalogId,
                catalogVersion: this.catalogVersion,
                pageId: this.item.uid
            });
        }
    }
};
PageNameWrapperComponent = __decorate([
    core.Component({
        selector: 'se-page-name-wrapper',
        template: `
        <a href="" (click)="goToPage($event)">
            <se-homepage-icon
                class="homepage-icon__page-list"
                [cmsPage]="item"
                [uriContext]="uriContext"
            ></se-homepage-icon>
            {{ item.name }}
        </a>
    `
    }),
    __param(0, core.Inject(smarteditcommons.DATA_TABLE_COMPONENT_DATA)),
    __metadata("design:paramtypes", [Object, router.ActivatedRoute,
        smarteditcommons.IExperienceService,
        smarteditcommons.IUrlService])
], PageNameWrapperComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageListDropdownItemsWrapperComponent", {
    selector: 'se-page-list-dropdown-items-wrapper',
    template: `<div
        *seHasOperationPermission="'se.edit.page'"
        class="paged-list-table__body__td paged-list-table__body__td-menu"
    >
        <se-dropdown-menu
            [dropdownItems]="dropdownItems"
            [selectedItem]="item"
            class="pull-right"
        ></se-dropdown-menu>
    </div>`,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let PageListDropdownItemsWrapperComponent = class PageListDropdownItemsWrapperComponent {
    constructor(route, data, catalogVersionPermissionService, managePageService, cdr) {
        this.route = route;
        this.data = data;
        this.catalogVersionPermissionService = catalogVersionPermissionService;
        this.managePageService = managePageService;
        this.cdr = cdr;
        this.dropdownItems = [];
    }
    ngOnInit() {
        return this.setDropdownItems();
    }
    setDropdownItems() {
        return __awaiter(this, void 0, void 0, function* () {
            this.item = this.data.item;
            const { catalogId, catalogVersion } = this.route.snapshot.params;
            const [hasSyncPermission, hasClonePermission] = yield Promise.all([
                this.catalogVersionPermissionService.hasSyncPermissionToActiveCatalogVersion(catalogId, catalogVersion),
                /**
                 * Normally we would use something like `isPermitted` from PermissionService but as we are in pages
                 * which are container (outer) part of app and PermissionService uses some data retrieved from inner
                 * (which in this case can be also obtained from outer) we had to use methods available in outer
                 * to see if the clone button can be cloned or not.
                 *
                 * Using here PermissionService.isPermitted will throw error
                 * as there is no iframe in Pages site
                 */
                this.managePageService.isPageCloneable(this.data.item.uuid, this.data.item.catalogVersion)
            ]);
            this.addDropdownItem(EditPageItemComponent);
            if (hasSyncPermission) {
                this.addDropdownItem(SyncPageItemComponent);
            }
            if (hasClonePermission) {
                this.addDropdownItem(ClonePageItemComponent);
            }
            this.addDropdownItem(DeletePageItemComponent);
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    addDropdownItem(item) {
        this.dropdownItems = this.dropdownItems.concat({
            component: item
        });
    }
};
PageListDropdownItemsWrapperComponent = __decorate([
    core.Component({
        selector: 'se-page-list-dropdown-items-wrapper',
        template: `<div
        *seHasOperationPermission="'se.edit.page'"
        class="paged-list-table__body__td paged-list-table__body__td-menu"
    >
        <se-dropdown-menu
            [dropdownItems]="dropdownItems"
            [selectedItem]="item"
            class="pull-right"
        ></se-dropdown-menu>
    </div>`,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(1, core.Inject(smarteditcommons.DATA_TABLE_COMPONENT_DATA)),
    __metadata("design:paramtypes", [router.ActivatedRoute, Object, smarteditcommons.ICatalogVersionPermissionService,
        exports.ManagePageService,
        core.ChangeDetectorRef])
], PageListDropdownItemsWrapperComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageListComponent", {
    selector: 'se-page-list',
    template: `<div class="se-page-list"><se-toolbar cssClass="se-toolbar--shell" imageRoot="imageRoot" toolbarName="smartEditHeaderToolbar"></se-toolbar><se-toolbar cssClass="se-toolbar--shell se-toolbar--shortcut" imageRoot="imageRoot" toolbarName="smartEditPagesToolbar"></se-toolbar><div *ngIf="isReady"><div class="se-page-list__header"><span class="se-page-list__catalog-name" translate="se.cms.pagelist.title"></span><p class="se-page-list__sub-title">{{ catalogName | seL10n | async }} - {{ catalogVersion }}</p></div><div class="se-page-list__body"><div class="se-page-list__table-header"><span class="se-paged-list__page-count-wrapper"><span class="span-page-list__page-count-text" translate="se.pagelist.countsearchresult"></span> <span>&nbsp;</span> <span class="se-page-list__page-count">({{ count }})</span></span><div class="se-page-list__table-header--right"><div class="fd-form__group se-page-list__search"><div class="se-input-group"><input type="search" class="se-input-group__input-area ySEPage-list-search-input" maxlength="255" name="query" [ngModel]="query" (ngModelChange)="onQueryChange($event)" [placeholder]="'se.cms.pagelist.searchplaceholder' | translate"/> <span class="sap-icon--search se-input-group__addon"></span><div *ngIf="query" aria-label="clear" class="se-input-group__addon se-input-group__clear-btn" (click)="reset()"><span class="sap-icon--decline"></span></div></div></div><button class="fd-button se-page-list__add" (click)="openAddPageWizard()" translate="se.cms.addpagewizard.addpage"></button></div></div><div class="se-page-list__table-body"><se-dynamic-paged-list [config]="pageListConfig" [mask]="query" (getApi)="getApi($event);" (onItemsUpdate)="onPageItemsUpdate($event.pagination)"></se-dynamic-paged-list></div></div></div></div>`,
    styles: [`.se-page-list{background-color:#edeff0;min-height:100vh;height:100%}.se-page-list__page-link-anchor{text-decoration:none!important;color:#51555a}.se-page-list__page-link-anchor:hover{color:#0a6ed1}.se-page-list__header{padding:16px 30px;background-color:#fff}.se-page-list__page-link-icon{font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;color:#51555a}.se-page-list__catalog-name{font-size:1.7142857143rem;line-height:1.3333333333;font-weight:400;display:block;margin-bottom:4px}.se-page-list__sub-title{color:#6a6d70}.se-page-list__body{padding:20px 20px 70px}.se-page-list__page-link--left{cursor:pointer}.se-page-list__page-link--left .se-page-list__page-link-anchor{margin-left:3px}.se-page-list__page-link--right{cursor:pointer}.se-page-list__page-link--right .se-page-list__page-link-anchor{margin-right:3px}.se-page-list__table-header{display:flex;flex-direction:row;align-items:center;justify-content:space-between;background-color:#fff;height:56px;padding:20px;border-radius:4px 4px 0 0}.se-page-list__table-header--right{display:flex;flex-direction:row;align-items:center}.se-page-list__table-header .se-paged-list__page-count-wrapper{font-size:1.1428571429rem;line-height:1.25;font-weight:400;margin-right:auto}.se-page-list__table-body{padding-bottom:16px}.se-page-list__table-body .se-data-table__arrow{margin-left:2px}.se-page-list__table-body .se-paged-list-item{cursor:default}.se-page-list__search{margin-right:16px;width:380px}.se-page-list__add{text-transform:capitalize}.se-paged-list__header{font-size:1rem;line-height:1.4285714286;font-weight:400}.se-paged-list__header-dropdownitems,.se-paged-list__header-pageStatus,.se-paged-list__header-syncStatus{cursor:default}.se-paged-list-item-name a{text-decoration:none!important}.se-sync-btn__status--done{color:#0a7e3e}.se-sync-btn__status--not{color:#e9730c}.ySmartEditTrashPageToolbar{background-color:#fff}.fd-table td.se-paged-list-item-numberOfRestrictions,.fd-table td.se-paged-list-item-syncStatus,.fd-table th.se-paged-list__header-numberOfRestrictions,.fd-table th.se-paged-list__header-syncStatus{text-align:center}.fd-table td.se-paged-list-item-syncStatus{font-size:1.1428571429rem;line-height:1.25;font-weight:400}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    encapsulation: core.ViewEncapsulation.None
});
let /* @ngInject */ PageListComponent = class /* @ngInject */ PageListComponent {
    constructor(activatedRoute, urlService, catalogService, addPageWizardService, systemEventService, cdr, userTrackingService) {
        this.activatedRoute = activatedRoute;
        this.urlService = urlService;
        this.catalogService = catalogService;
        this.addPageWizardService = addPageWizardService;
        this.systemEventService = systemEventService;
        this.cdr = cdr;
        this.userTrackingService = userTrackingService;
        const { snapshot: { params } } = this.activatedRoute;
        this.isReady = false;
        this.count = 0;
        this.catalogId = params.catalogId;
        this.catalogVersion = params.catalogVersion;
        this.siteUid = params.siteId;
        this.catalogName = {};
        this.pageUriContext = this.urlService.buildPageUriContext(this.siteUid, this.catalogId, this.catalogVersion);
        this.uriContext = this.urlService.buildUriContext(this.siteUid, this.catalogId, this.catalogVersion);
        this.pageListConfig = {
            sortBy: 'name',
            reversed: false,
            itemsPerPage: 10,
            displayCount: true,
            keys: [],
            queryParams: {
                catalogId: this.catalogId,
                catalogVersion: this.catalogVersion,
                typeCode: 'AbstractPage',
                itemSearchParams: 'pageStatus:active',
                fields: 'PAGE_LIST'
            },
            uri: smarteditcommons.cmsitemsUri
        };
        this.query = '';
        this.querySubject$ = new rxjs.Subject();
        this.querySubscription = this.querySubject$
            .pipe(operators.debounceTime(500), operators.distinctUntilChanged())
            .subscribe((newValue) => {
            this.query = newValue;
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    ngOnInit() {
        return this.initialize();
    }
    ngOnDestroy() {
        this.eventUnsubscribe();
        this.querySubscription.unsubscribe();
    }
    onPageItemsUpdate(pagination) {
        this.count = pagination.totalCount;
    }
    onContentCatalogUpdate() {
        if (this.dynamicPagedListApi) {
            this.dynamicPagedListApi.reloadItems();
        }
    }
    onQueryChange(value) {
        this.querySubject$.next(value);
    }
    getApi(api) {
        this.dynamicPagedListApi = api;
    }
    openAddPageWizard() {
        return __awaiter(this, void 0, void 0, function* () {
            this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.PAGE_MANAGEMENT, 'Create Page');
            yield this.addPageWizardService.openAddPageWizard();
            this.dynamicPagedListApi.reloadItems();
        });
    }
    reset() {
        this.querySubject$.next('');
    }
    retrieveCatalogName() {
        return __awaiter(this, void 0, void 0, function* () {
            const catalogs = yield this.catalogService.getContentCatalogsForSite(this.siteUid);
            this.catalogName = catalogs.find((catalog) => catalog.catalogId === this.catalogId).name;
        });
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            const isNonActive = yield this.catalogService.isContentCatalogVersionNonActive();
            this.pageListConfig.keys = [
                {
                    property: 'name',
                    i18n: 'se.cms.pagelist.headerpagename',
                    sortable: true,
                    component: PageNameWrapperComponent
                },
                {
                    property: 'uid',
                    i18n: 'se.cms.pagelist.headerpageid',
                    sortable: true
                },
                {
                    property: 'itemtype',
                    i18n: 'se.cms.pagelist.headerpagetype',
                    sortable: true
                },
                {
                    property: 'label',
                    i18n: 'se.cms.pagelist.headerpagelable',
                    sortable: false
                },
                {
                    property: 'masterTemplateId',
                    i18n: 'se.cms.pagelist.headerpagetemplate',
                    sortable: false
                },
                {
                    property: 'numberOfRestrictions',
                    i18n: 'se.cms.pagelist.headerrestrictions',
                    sortable: false,
                    component: NumberOfRestrictionsWrapperComponent
                }
            ];
            if (isNonActive) {
                this.pageListConfig.keys.push({
                    property: 'pageStatus',
                    i18n: 'se.cms.pagelist.headerpagestatus',
                    sortable: false,
                    component: PageStatusWrapperComponent
                });
            }
            this.pageListConfig.keys.push({
                property: 'dropdownitems',
                i18n: '',
                sortable: false,
                component: PageListDropdownItemsWrapperComponent
            });
            yield this.retrieveCatalogName();
            this.eventUnsubscribe = this.systemEventService.subscribe(smarteditcommons.EVENT_CONTENT_CATALOG_UPDATE, () => this.onContentCatalogUpdate());
            this.isReady = true;
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
};
PageListComponent.$inject = ["activatedRoute", "urlService", "catalogService", "addPageWizardService", "systemEventService", "cdr", "userTrackingService"];
/* @ngInject */ PageListComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-list',
        template: `<div class="se-page-list"><se-toolbar cssClass="se-toolbar--shell" imageRoot="imageRoot" toolbarName="smartEditHeaderToolbar"></se-toolbar><se-toolbar cssClass="se-toolbar--shell se-toolbar--shortcut" imageRoot="imageRoot" toolbarName="smartEditPagesToolbar"></se-toolbar><div *ngIf="isReady"><div class="se-page-list__header"><span class="se-page-list__catalog-name" translate="se.cms.pagelist.title"></span><p class="se-page-list__sub-title">{{ catalogName | seL10n | async }} - {{ catalogVersion }}</p></div><div class="se-page-list__body"><div class="se-page-list__table-header"><span class="se-paged-list__page-count-wrapper"><span class="span-page-list__page-count-text" translate="se.pagelist.countsearchresult"></span> <span>&nbsp;</span> <span class="se-page-list__page-count">({{ count }})</span></span><div class="se-page-list__table-header--right"><div class="fd-form__group se-page-list__search"><div class="se-input-group"><input type="search" class="se-input-group__input-area ySEPage-list-search-input" maxlength="255" name="query" [ngModel]="query" (ngModelChange)="onQueryChange($event)" [placeholder]="'se.cms.pagelist.searchplaceholder' | translate"/> <span class="sap-icon--search se-input-group__addon"></span><div *ngIf="query" aria-label="clear" class="se-input-group__addon se-input-group__clear-btn" (click)="reset()"><span class="sap-icon--decline"></span></div></div></div><button class="fd-button se-page-list__add" (click)="openAddPageWizard()" translate="se.cms.addpagewizard.addpage"></button></div></div><div class="se-page-list__table-body"><se-dynamic-paged-list [config]="pageListConfig" [mask]="query" (getApi)="getApi($event);" (onItemsUpdate)="onPageItemsUpdate($event.pagination)"></se-dynamic-paged-list></div></div></div></div>`,
        styles: [`.se-page-list{background-color:#edeff0;min-height:100vh;height:100%}.se-page-list__page-link-anchor{text-decoration:none!important;color:#51555a}.se-page-list__page-link-anchor:hover{color:#0a6ed1}.se-page-list__header{padding:16px 30px;background-color:#fff}.se-page-list__page-link-icon{font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;color:#51555a}.se-page-list__catalog-name{font-size:1.7142857143rem;line-height:1.3333333333;font-weight:400;display:block;margin-bottom:4px}.se-page-list__sub-title{color:#6a6d70}.se-page-list__body{padding:20px 20px 70px}.se-page-list__page-link--left{cursor:pointer}.se-page-list__page-link--left .se-page-list__page-link-anchor{margin-left:3px}.se-page-list__page-link--right{cursor:pointer}.se-page-list__page-link--right .se-page-list__page-link-anchor{margin-right:3px}.se-page-list__table-header{display:flex;flex-direction:row;align-items:center;justify-content:space-between;background-color:#fff;height:56px;padding:20px;border-radius:4px 4px 0 0}.se-page-list__table-header--right{display:flex;flex-direction:row;align-items:center}.se-page-list__table-header .se-paged-list__page-count-wrapper{font-size:1.1428571429rem;line-height:1.25;font-weight:400;margin-right:auto}.se-page-list__table-body{padding-bottom:16px}.se-page-list__table-body .se-data-table__arrow{margin-left:2px}.se-page-list__table-body .se-paged-list-item{cursor:default}.se-page-list__search{margin-right:16px;width:380px}.se-page-list__add{text-transform:capitalize}.se-paged-list__header{font-size:1rem;line-height:1.4285714286;font-weight:400}.se-paged-list__header-dropdownitems,.se-paged-list__header-pageStatus,.se-paged-list__header-syncStatus{cursor:default}.se-paged-list-item-name a{text-decoration:none!important}.se-sync-btn__status--done{color:#0a7e3e}.se-sync-btn__status--not{color:#e9730c}.ySmartEditTrashPageToolbar{background-color:#fff}.fd-table td.se-paged-list-item-numberOfRestrictions,.fd-table td.se-paged-list-item-syncStatus,.fd-table th.se-paged-list__header-numberOfRestrictions,.fd-table th.se-paged-list__header-syncStatus{text-align:center}.fd-table td.se-paged-list-item-syncStatus{font-size:1.1428571429rem;line-height:1.25;font-weight:400}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush,
        encapsulation: core.ViewEncapsulation.None
    }),
    __metadata("design:paramtypes", [router.ActivatedRoute,
        smarteditcommons.IUrlService,
        smarteditcommons.ICatalogService,
        exports.AddPageWizardService,
        smarteditcommons.SystemEventService,
        core.ChangeDetectorRef,
        smarteditcommons.UserTrackingService])
], /* @ngInject */ PageListComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageListLinkComponent", {
    selector: 'se-page-list-link',
    template: `<div><a class="page-list-link-item__link" [href]="getLink()" translate="se.cms.cataloginfo.pagelist" (click)="onClick()"></a></div>`
});
let /* @ngInject */ PageListLinkComponent = class /* @ngInject */ PageListLinkComponent {
    constructor(catalogDetails, userTrackingService) {
        this.catalogDetails = catalogDetails;
        this.userTrackingService = userTrackingService;
    }
    getLink() {
        const { siteId, catalog: { catalogId }, catalogVersion: { version } } = this.catalogDetails;
        return `#!/${smarteditcommons.NG_ROUTE_PREFIX}/pages/${siteId}/${catalogId}/${version}`;
    }
    onClick() {
        const { catalogVersion: { version: catalogVersion } } = this.catalogDetails;
        this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.NAVIGATION, catalogVersion + '- Pages');
    }
};
PageListLinkComponent.$inject = ["catalogDetails", "userTrackingService"];
/* @ngInject */ PageListLinkComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-list-link',
        template: `<div><a class="page-list-link-item__link" [href]="getLink()" translate="se.cms.cataloginfo.pagelist" (click)="onClick()"></a></div>`
    }),
    __param(0, core.Inject(smarteditcommons.CATALOG_DETAILS_ITEM_DATA)),
    __metadata("design:paramtypes", [Object, smarteditcommons.UserTrackingService])
], /* @ngInject */ PageListLinkComponent);

window.__smartedit__.addDecoratorPayload("Component", "PagesLinkComponent", {
    selector: 'se-pages-link',
    template: `<div class="se-page-list__page-link--left" (click)="backToPagelist()"><span class="se-page-list__page-link-icon icon-navigation-left-arrow"></span> <a class="se-page-list__page-link-anchor">{{ 'se.cms.back.to.pagelist' | translate }}</a></div>`,
    styles: [`.se-page-list{background-color:#edeff0;min-height:100vh;height:100%}.se-page-list__page-link-anchor{text-decoration:none!important;color:#51555a}.se-page-list__page-link-anchor:hover{color:#0a6ed1}.se-page-list__header{padding:16px 30px;background-color:#fff}.se-page-list__page-link-icon{font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;color:#51555a}.se-page-list__catalog-name{font-size:1.7142857143rem;line-height:1.3333333333;font-weight:400;display:block;margin-bottom:4px}.se-page-list__sub-title{color:#6a6d70}.se-page-list__body{padding:20px 20px 70px}.se-page-list__page-link--left{cursor:pointer}.se-page-list__page-link--left .se-page-list__page-link-anchor{margin-left:3px}.se-page-list__page-link--right{cursor:pointer}.se-page-list__page-link--right .se-page-list__page-link-anchor{margin-right:3px}.se-page-list__table-header{display:flex;flex-direction:row;align-items:center;justify-content:space-between;background-color:#fff;height:56px;padding:20px;border-radius:4px 4px 0 0}.se-page-list__table-header--right{display:flex;flex-direction:row;align-items:center}.se-page-list__table-header .se-paged-list__page-count-wrapper{font-size:1.1428571429rem;line-height:1.25;font-weight:400;margin-right:auto}.se-page-list__table-body{padding-bottom:16px}.se-page-list__table-body .se-data-table__arrow{margin-left:2px}.se-page-list__table-body .se-paged-list-item{cursor:default}.se-page-list__search{margin-right:16px;width:380px}.se-page-list__add{text-transform:capitalize}.se-paged-list__header{font-size:1rem;line-height:1.4285714286;font-weight:400}.se-paged-list__header-dropdownitems,.se-paged-list__header-pageStatus,.se-paged-list__header-syncStatus{cursor:default}.se-paged-list-item-name a{text-decoration:none!important}.se-sync-btn__status--done{color:#0a7e3e}.se-sync-btn__status--not{color:#e9730c}.ySmartEditTrashPageToolbar{background-color:#fff}.fd-table td.se-paged-list-item-numberOfRestrictions,.fd-table td.se-paged-list-item-syncStatus,.fd-table th.se-paged-list__header-numberOfRestrictions,.fd-table th.se-paged-list__header-syncStatus{text-align:center}.fd-table td.se-paged-list-item-syncStatus{font-size:1.1428571429rem;line-height:1.25;font-weight:400}`]
});
let /* @ngInject */ PagesLinkComponent = class /* @ngInject */ PagesLinkComponent {
    constructor(route, seRouting) {
        this.route = route;
        this.seRouting = seRouting;
    }
    ngOnInit() {
        this.siteId = this.route.snapshot.params.siteId;
        this.catalogId = this.route.snapshot.params.catalogId;
        this.catalogVersion = this.route.snapshot.params.catalogVersion;
    }
    backToPagelist() {
        this.seRouting.go(`${smarteditcommons.NG_ROUTE_PREFIX}${cmscommons.PAGE_LIST_PATH}`
            .replace(':siteId', this.siteId)
            .replace(':catalogId', this.catalogId)
            .replace(':catalogVersion', this.catalogVersion));
    }
};
PagesLinkComponent.$inject = ["route", "seRouting"];
/* @ngInject */ PagesLinkComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-pages-link',
        template: `<div class="se-page-list__page-link--left" (click)="backToPagelist()"><span class="se-page-list__page-link-icon icon-navigation-left-arrow"></span> <a class="se-page-list__page-link-anchor">{{ 'se.cms.back.to.pagelist' | translate }}</a></div>`,
        styles: [`.se-page-list{background-color:#edeff0;min-height:100vh;height:100%}.se-page-list__page-link-anchor{text-decoration:none!important;color:#51555a}.se-page-list__page-link-anchor:hover{color:#0a6ed1}.se-page-list__header{padding:16px 30px;background-color:#fff}.se-page-list__page-link-icon{font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;color:#51555a}.se-page-list__catalog-name{font-size:1.7142857143rem;line-height:1.3333333333;font-weight:400;display:block;margin-bottom:4px}.se-page-list__sub-title{color:#6a6d70}.se-page-list__body{padding:20px 20px 70px}.se-page-list__page-link--left{cursor:pointer}.se-page-list__page-link--left .se-page-list__page-link-anchor{margin-left:3px}.se-page-list__page-link--right{cursor:pointer}.se-page-list__page-link--right .se-page-list__page-link-anchor{margin-right:3px}.se-page-list__table-header{display:flex;flex-direction:row;align-items:center;justify-content:space-between;background-color:#fff;height:56px;padding:20px;border-radius:4px 4px 0 0}.se-page-list__table-header--right{display:flex;flex-direction:row;align-items:center}.se-page-list__table-header .se-paged-list__page-count-wrapper{font-size:1.1428571429rem;line-height:1.25;font-weight:400;margin-right:auto}.se-page-list__table-body{padding-bottom:16px}.se-page-list__table-body .se-data-table__arrow{margin-left:2px}.se-page-list__table-body .se-paged-list-item{cursor:default}.se-page-list__search{margin-right:16px;width:380px}.se-page-list__add{text-transform:capitalize}.se-paged-list__header{font-size:1rem;line-height:1.4285714286;font-weight:400}.se-paged-list__header-dropdownitems,.se-paged-list__header-pageStatus,.se-paged-list__header-syncStatus{cursor:default}.se-paged-list-item-name a{text-decoration:none!important}.se-sync-btn__status--done{color:#0a7e3e}.se-sync-btn__status--not{color:#e9730c}.ySmartEditTrashPageToolbar{background-color:#fff}.fd-table td.se-paged-list-item-numberOfRestrictions,.fd-table td.se-paged-list-item-syncStatus,.fd-table th.se-paged-list__header-numberOfRestrictions,.fd-table th.se-paged-list__header-syncStatus{text-align:center}.fd-table td.se-paged-list-item-syncStatus{font-size:1.1428571429rem;line-height:1.25;font-weight:400}`]
    }),
    __metadata("design:paramtypes", [router.ActivatedRoute, smarteditcommons.SmarteditRoutingService])
], /* @ngInject */ PagesLinkComponent);

window.__smartedit__.addDecoratorPayload("Component", "RestrictionsModalComponent", {
    selector: 'se-restrictions-modal',
    template: `<div class="se-restrictions-list fd-menu__list fd-menu__list--separated"><div class="se-restriction__item fd-menu__item" *ngFor="let restriction of restrictions"><div class="se-restrictions-list__item-content"><div class="se-restriction__item-name">{{ restriction.name }}</div><div class="se-restriction__item-type-and-id">{{ restriction.type | seL10n | async }}</div><div class="se-restriction__item-description">{{ restriction.description }}</div></div></div></div>`,
    styles: [`#restrictions-label{display:none}.se-restriction__select{text-transform:capitalize;width:100%}.se-restrictions-list__item-content{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;cursor:default;flex-grow:1}#userGroups-selector .se-generic-editor-multiple-dropdown__match li[draggable=true]{display:flex;flex-direction:row;align-items:center;justify-content:center;display:inline-flex!important;border:1px solid #d9d9d9;margin:4px 0 4px 8px;padding:4px 8px;border-radius:4px;background-color:var(--fd-token-background-color);color:#51555a;min-height:28px}`]
});
let RestrictionsModalComponent = class RestrictionsModalComponent {
    constructor(modalRef, cmsitemsRestService, cdr) {
        this.modalRef = modalRef;
        this.cmsitemsRestService = cmsitemsRestService;
        this.cdr = cdr;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const restrictionsData = yield this.cmsitemsRestService.getByIdsNoCache(this.modalRef.data.modalData, 'FULL');
            this.restrictions = (restrictionsData.response
                ? restrictionsData.response
                : [restrictionsData]);
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
};
RestrictionsModalComponent = __decorate([
    core.Component({
        selector: 'se-restrictions-modal',
        template: `<div class="se-restrictions-list fd-menu__list fd-menu__list--separated"><div class="se-restriction__item fd-menu__item" *ngFor="let restriction of restrictions"><div class="se-restrictions-list__item-content"><div class="se-restriction__item-name">{{ restriction.name }}</div><div class="se-restriction__item-type-and-id">{{ restriction.type | seL10n | async }}</div><div class="se-restriction__item-description">{{ restriction.description }}</div></div></div></div>`,
        styles: [`#restrictions-label{display:none}.se-restriction__select{text-transform:capitalize;width:100%}.se-restrictions-list__item-content{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;cursor:default;flex-grow:1}#userGroups-selector .se-generic-editor-multiple-dropdown__match li[draggable=true]{display:flex;flex-direction:row;align-items:center;justify-content:center;display:inline-flex!important;border:1px solid #d9d9d9;margin:4px 0 4px 8px;padding:4px 8px;border-radius:4px;background-color:var(--fd-token-background-color);color:#51555a;min-height:28px}`]
    }),
    __metadata("design:paramtypes", [core$2.ModalRef,
        smarteditcommons.CmsitemsRestService,
        core.ChangeDetectorRef])
], RestrictionsModalComponent);

window.__smartedit__.addDecoratorPayload("Component", "RestrictionsViewerComponent", {
    selector: 'se-restrictions-viewer',
    template: `<div *ngIf="restrictions?.length > 0; else noRestrictions"><a href="" class="show-restrictions-btn" (click)="showRestrictions($event)">{{restrictions.length}}</a></div><ng-template #noRestrictions><div>-</div></ng-template>`,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ RestrictionsViewerComponent = class /* @ngInject */ RestrictionsViewerComponent {
    constructor(modalService, logService) {
        this.modalService = modalService;
        this.logService = logService;
    }
    showRestrictions(event) {
        event.preventDefault();
        return this.modalService
            .open({
            component: RestrictionsModalComponent,
            data: this.restrictions,
            templateConfig: {
                title: 'se.cms.restrictionsviewer.title',
                isDismissButtonVisible: true
            },
            config: {
                modalPanelClass: 'modal-md'
            }
        })
            .afterClosed.toPromise()
            .catch(() => {
            this.logService.warn('RestrictionsViewer - modal closed without any action');
        });
    }
};
RestrictionsViewerComponent.$inject = ["modalService", "logService"];
__decorate([
    core.Input(),
    __metadata("design:type", Array)
], /* @ngInject */ RestrictionsViewerComponent.prototype, "restrictions", void 0);
/* @ngInject */ RestrictionsViewerComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-restrictions-viewer',
        template: `<div *ngIf="restrictions?.length > 0; else noRestrictions"><a href="" class="show-restrictions-btn" (click)="showRestrictions($event)">{{restrictions.length}}</a></div><ng-template #noRestrictions><div>-</div></ng-template>`,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [smarteditcommons.ModalService, smarteditcommons.LogService])
], /* @ngInject */ RestrictionsViewerComponent);

window.__smartedit__.addDecoratorPayload("Component", "TrashLinkComponent", {
    selector: 'se-trash-link',
    template: `<div *ngIf="isNonActiveCatalog" (click)="goToTrash()" class="se-page-list__page-link--right"><a translate="se.cms.pagelist.trashcan.link.text" [translateParams]="trashedPagesTranslationData" class="se-page-list__page-link-anchor"></a> <span class="se-page-list__page-link-icon sap-icon--navigation-right-arrow"></span></div>`,
    styles: [`.se-page-list{background-color:#edeff0;min-height:100vh;height:100%}.se-page-list__page-link-anchor{text-decoration:none!important;color:#51555a}.se-page-list__page-link-anchor:hover{color:#0a6ed1}.se-page-list__header{padding:16px 30px;background-color:#fff}.se-page-list__page-link-icon{font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;color:#51555a}.se-page-list__catalog-name{font-size:1.7142857143rem;line-height:1.3333333333;font-weight:400;display:block;margin-bottom:4px}.se-page-list__sub-title{color:#6a6d70}.se-page-list__body{padding:20px 20px 70px}.se-page-list__page-link--left{cursor:pointer}.se-page-list__page-link--left .se-page-list__page-link-anchor{margin-left:3px}.se-page-list__page-link--right{cursor:pointer}.se-page-list__page-link--right .se-page-list__page-link-anchor{margin-right:3px}.se-page-list__table-header{display:flex;flex-direction:row;align-items:center;justify-content:space-between;background-color:#fff;height:56px;padding:20px;border-radius:4px 4px 0 0}.se-page-list__table-header--right{display:flex;flex-direction:row;align-items:center}.se-page-list__table-header .se-paged-list__page-count-wrapper{font-size:1.1428571429rem;line-height:1.25;font-weight:400;margin-right:auto}.se-page-list__table-body{padding-bottom:16px}.se-page-list__table-body .se-data-table__arrow{margin-left:2px}.se-page-list__table-body .se-paged-list-item{cursor:default}.se-page-list__search{margin-right:16px;width:380px}.se-page-list__add{text-transform:capitalize}.se-paged-list__header{font-size:1rem;line-height:1.4285714286;font-weight:400}.se-paged-list__header-dropdownitems,.se-paged-list__header-pageStatus,.se-paged-list__header-syncStatus{cursor:default}.se-paged-list-item-name a{text-decoration:none!important}.se-sync-btn__status--done{color:#0a7e3e}.se-sync-btn__status--not{color:#e9730c}.ySmartEditTrashPageToolbar{background-color:#fff}.fd-table td.se-paged-list-item-numberOfRestrictions,.fd-table td.se-paged-list-item-syncStatus,.fd-table th.se-paged-list__header-numberOfRestrictions,.fd-table th.se-paged-list__header-syncStatus{text-align:center}.fd-table td.se-paged-list-item-syncStatus{font-size:1.1428571429rem;line-height:1.25;font-weight:400}`]
});
let /* @ngInject */ TrashLinkComponent = class /* @ngInject */ TrashLinkComponent {
    constructor(route, routingsService, managePageService, urlService, catalogService, systemEventService) {
        this.route = route;
        this.routingsService = routingsService;
        this.managePageService = managePageService;
        this.urlService = urlService;
        this.catalogService = catalogService;
        this.systemEventService = systemEventService;
        this.isNonActiveCatalog = false;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            ({
                siteId: this.siteId,
                catalogId: this.catalogId,
                catalogVersion: this.catalogVersion
            } = this.route.snapshot.params);
            this.uriContext = this.urlService.buildUriContext(this.siteId, this.catalogId, this.catalogVersion);
            const isNonActiveCatalog = yield this.catalogService.isContentCatalogVersionNonActive();
            this.isNonActiveCatalog = isNonActiveCatalog;
            if (isNonActiveCatalog) {
                this.updateTrashedPagesCount();
            }
            this.unsubscribeContentCatalogUpdateEvent = this.systemEventService.subscribe(smarteditcommons.EVENT_CONTENT_CATALOG_UPDATE, () => this.updateTrashedPagesCount());
        });
    }
    ngOnDestroy() {
        this.unsubscribeContentCatalogUpdateEvent();
    }
    updateTrashedPagesCount() {
        return __awaiter(this, void 0, void 0, function* () {
            const trashedPagesCount = yield this.managePageService.getSoftDeletedPagesCount(this.uriContext);
            this.trashedPagesTranslationData = {
                totalCount: trashedPagesCount
            };
        });
    }
    goToTrash() {
        this.routingsService.go(`${smarteditcommons.NG_ROUTE_PREFIX}${cmscommons.TRASHED_PAGE_LIST_PATH}`
            .replace(':siteId', this.siteId)
            .replace(':catalogId', this.catalogId)
            .replace(':catalogVersion', this.catalogVersion));
    }
};
TrashLinkComponent.$inject = ["route", "routingsService", "managePageService", "urlService", "catalogService", "systemEventService"];
/* @ngInject */ TrashLinkComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-trash-link',
        template: `<div *ngIf="isNonActiveCatalog" (click)="goToTrash()" class="se-page-list__page-link--right"><a translate="se.cms.pagelist.trashcan.link.text" [translateParams]="trashedPagesTranslationData" class="se-page-list__page-link-anchor"></a> <span class="se-page-list__page-link-icon sap-icon--navigation-right-arrow"></span></div>`,
        styles: [`.se-page-list{background-color:#edeff0;min-height:100vh;height:100%}.se-page-list__page-link-anchor{text-decoration:none!important;color:#51555a}.se-page-list__page-link-anchor:hover{color:#0a6ed1}.se-page-list__header{padding:16px 30px;background-color:#fff}.se-page-list__page-link-icon{font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;color:#51555a}.se-page-list__catalog-name{font-size:1.7142857143rem;line-height:1.3333333333;font-weight:400;display:block;margin-bottom:4px}.se-page-list__sub-title{color:#6a6d70}.se-page-list__body{padding:20px 20px 70px}.se-page-list__page-link--left{cursor:pointer}.se-page-list__page-link--left .se-page-list__page-link-anchor{margin-left:3px}.se-page-list__page-link--right{cursor:pointer}.se-page-list__page-link--right .se-page-list__page-link-anchor{margin-right:3px}.se-page-list__table-header{display:flex;flex-direction:row;align-items:center;justify-content:space-between;background-color:#fff;height:56px;padding:20px;border-radius:4px 4px 0 0}.se-page-list__table-header--right{display:flex;flex-direction:row;align-items:center}.se-page-list__table-header .se-paged-list__page-count-wrapper{font-size:1.1428571429rem;line-height:1.25;font-weight:400;margin-right:auto}.se-page-list__table-body{padding-bottom:16px}.se-page-list__table-body .se-data-table__arrow{margin-left:2px}.se-page-list__table-body .se-paged-list-item{cursor:default}.se-page-list__search{margin-right:16px;width:380px}.se-page-list__add{text-transform:capitalize}.se-paged-list__header{font-size:1rem;line-height:1.4285714286;font-weight:400}.se-paged-list__header-dropdownitems,.se-paged-list__header-pageStatus,.se-paged-list__header-syncStatus{cursor:default}.se-paged-list-item-name a{text-decoration:none!important}.se-sync-btn__status--done{color:#0a7e3e}.se-sync-btn__status--not{color:#e9730c}.ySmartEditTrashPageToolbar{background-color:#fff}.fd-table td.se-paged-list-item-numberOfRestrictions,.fd-table td.se-paged-list-item-syncStatus,.fd-table th.se-paged-list__header-numberOfRestrictions,.fd-table th.se-paged-list__header-syncStatus{text-align:center}.fd-table td.se-paged-list-item-syncStatus{font-size:1.1428571429rem;line-height:1.25;font-weight:400}`]
    }),
    __metadata("design:paramtypes", [router.ActivatedRoute,
        smarteditcommons.SmarteditRoutingService,
        exports.ManagePageService,
        smarteditcommons.IUrlService,
        smarteditcommons.ICatalogService,
        smarteditcommons.SystemEventService])
], /* @ngInject */ TrashLinkComponent);

/**
 * Module containing all the components and services necessary to manage a page.
 */
let PageComponentsModule = class PageComponentsModule {
};
PageComponentsModule = __decorate([
    core.NgModule({
        imports: [
            common.CommonModule,
            smarteditcommons.L10nPipeModule,
            forms.FormsModule,
            smarteditcommons.TranslationModule.forChild(),
            smarteditcommons.HasOperationPermissionDirectiveModule,
            smarteditcommons.TooltipModule,
            WorkflowModule,
            smarteditcommons.SharedComponentsModule,
            smarteditcommons.SelectModule,
            smarteditcommons.SeGenericEditorModule,
            exports.PageRestrictionsModule,
            smarteditcontainer.ToolbarModule,
            smarteditcommons.ClientPagedListModule,
            core$2.PopoverModule
        ],
        providers: [
            exports.ContextAwarePageStructureService,
            PageBuilderFactory,
            PageEditorModalService,
            PageEditorModalConfigService,
            PageInfoMenuService,
            ClonePageBuilderFactory,
            ClonePageWizardService
        ],
        declarations: [
            UpdatePageStatusComponent,
            RestorePageItemComponent,
            PermanentlyDeletePageItemComponent,
            PagesLinkComponent,
            RestrictionsViewerComponent,
            RestrictionsModalComponent,
            NumberOfRestrictionsWrapperComponent,
            PageStatusWrapperComponent,
            ModifiedTimeWrapperComponent,
            TrashListDropdownItemsWrapperComponent,
            SelectPageTemplateComponent,
            SelectPageTypeComponent,
            SyncPageItemComponent,
            DeletePageToolbarItemComponent,
            HomepageIconComponent,
            AddPageWizardComponent,
            PageTypeStepComponent,
            PageTemplateStepComponent,
            PageDisplayConditionStepComponent,
            PageInfoStepComponent,
            PageRestrictionsStepComponent,
            ClonePageWizardComponent,
            ClonePageOptionsStepComponent,
            ClonePageRestrictionsStepComponent,
            SelectTargetCatalogVersionComponent,
            NewPageDisplayConditionComponent,
            ComponentCloneOptionFormComponent,
            ComponentCloneInfoFormComponent,
            ClonePageInfoStepComponent,
            EditPageItemComponent,
            ClonePageItemComponent,
            DeletePageItemComponent,
            PageListLinkComponent,
            PageListComponent,
            PageNameWrapperComponent,
            PageListDropdownItemsWrapperComponent,
            TrashLinkComponent,
            DisplayConditionsPrimaryPageComponent,
            DisplayConditionsPageInfoComponent,
            DisplayConditionsPageVariationsComponent,
            CreationDateRendererComponent,
            DisplayConditionsEditorComponent,
            PageInfoMenuComponent
        ],
        entryComponents: [
            UpdatePageStatusComponent,
            RestorePageItemComponent,
            PermanentlyDeletePageItemComponent,
            PagesLinkComponent,
            RestrictionsViewerComponent,
            RestrictionsModalComponent,
            NumberOfRestrictionsWrapperComponent,
            PageStatusWrapperComponent,
            ModifiedTimeWrapperComponent,
            TrashListDropdownItemsWrapperComponent,
            SelectPageTemplateComponent,
            SelectPageTypeComponent,
            SyncPageItemComponent,
            DeletePageToolbarItemComponent,
            HomepageIconComponent,
            AddPageWizardComponent,
            PageTypeStepComponent,
            PageTemplateStepComponent,
            PageDisplayConditionStepComponent,
            PageInfoStepComponent,
            PageRestrictionsStepComponent,
            ClonePageWizardComponent,
            ClonePageOptionsStepComponent,
            ClonePageRestrictionsStepComponent,
            SelectTargetCatalogVersionComponent,
            NewPageDisplayConditionComponent,
            ComponentCloneOptionFormComponent,
            ComponentCloneInfoFormComponent,
            ClonePageInfoStepComponent,
            EditPageItemComponent,
            ClonePageItemComponent,
            DeletePageItemComponent,
            PageListLinkComponent,
            PageNameWrapperComponent,
            PageListDropdownItemsWrapperComponent,
            TrashLinkComponent,
            DisplayConditionsPrimaryPageComponent,
            DisplayConditionsPageInfoComponent,
            DisplayConditionsPageVariationsComponent,
            CreationDateRendererComponent,
            DisplayConditionsEditorComponent,
            PageInfoMenuComponent
        ],
        exports: [HomepageIconComponent]
    })
], PageComponentsModule);

/**
 * Used for converting Tree Nodes that are displayed in Breadcrumb.
 */
let /* @ngInject */ NodeAncestryService = class /* @ngInject */ NodeAncestryService {
    buildOrderedListOfAncestors(nodes, uid) {
        const ancestry = lodash.reverse(this.fetchAncestors(nodes, uid));
        let level = -1;
        return ancestry.map((node) => {
            const nextLevel = ++level;
            return Object.assign(Object.assign({}, lodash.cloneDeep(node)), { level: nextLevel, formattedLevel: nextLevel === 0
                    ? 'se.cms.navigationcomponent.management.node.level.root'
                    : 'se.cms.navigationcomponent.management.node.level.non.root' });
        });
    }
    fetchAncestors(nodes, uid) {
        const parent = nodes.find((element) => element.uid === uid);
        if (!parent) {
            return [];
        }
        return [parent].concat(this.fetchAncestors(nodes, parent.parentUid));
    }
};
/* @ngInject */ NodeAncestryService = __decorate([
    smarteditcommons.SeDowngradeService()
], /* @ngInject */ NodeAncestryService);

/*
 * This service updates the navigation node by making REST call to the cmswebservices navigations API.
 */
let /* @ngInject */ NavigationEditorNodeService = class /* @ngInject */ NavigationEditorNodeService {
    constructor(cmsitemsRestService, nodeAncestryService, restServiceFactory) {
        this.cmsitemsRestService = cmsitemsRestService;
        this.nodeAncestryService = nodeAncestryService;
        this.navigationNodeRestService = restServiceFactory.get(cmscommons.NAVIGATION_MANAGEMENT_RESOURCE_URI);
    }
    getNavigationNode(nodeUid, uriParams) {
        const payload = Object.assign({ identifier: nodeUid }, uriParams);
        return this.navigationNodeRestService.get(payload);
    }
    /**
     * Updates the position of the navigation node within the children collection of its parent.
     * Fetches the parent node, and reorders the children, then updates the parent with the new child order.
     *
     * @param node The navigation node to be updated.
     *
     * E.g. Navigation Management Page -> Edit Node
     */
    updateNavigationNodePosition(node) {
        return __awaiter(this, void 0, void 0, function* () {
            const parentNode = yield this.cmsitemsRestService.getById(node.parent.uuid);
            parentNode.children = parentNode.children || [];
            const currentIndex = parentNode.children.findIndex((child) => child === node.uuid);
            const targetIndex = node.position;
            if (currentIndex < 0 || node.position === undefined) {
                throw new Error(`navigationEditorNodeService.updateNavigationNodePosition() - invalid index: move FROM [${currentIndex}] TO [${targetIndex}]`);
            }
            // update parent children with the new child
            parentNode.children.splice(targetIndex, 0, parentNode.children.splice(currentIndex, 1)[0]);
            parentNode.identifier = parentNode.uuid;
            return this.cmsitemsRestService.update(parentNode);
        });
    }
    /**
     * Returns the list of nodes belonging to the ancestry of the node identified by its uid. This list includes the queried node as well.
     */
    getNavigationNodeAncestry(nodeUid, uriParams) {
        return __awaiter(this, void 0, void 0, function* () {
            const payload = Object.assign({ ancestorTrailFrom: nodeUid }, uriParams);
            const response = yield this.navigationNodeRestService.get(payload);
            return this.nodeAncestryService.buildOrderedListOfAncestors(smarteditcommons.apiUtils.getDataFromResponse(response), nodeUid);
        });
    }
};
NavigationEditorNodeService.$inject = ["cmsitemsRestService", "nodeAncestryService", "restServiceFactory"];
/* @ngInject */ NavigationEditorNodeService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.CmsitemsRestService,
        NodeAncestryService,
        smarteditcommons.IRestServiceFactory])
], /* @ngInject */ NavigationEditorNodeService);

window.__smartedit__.addDecoratorPayload("Component", "BreadcrumbComponent", {
    selector: 'se-breadcrumb',
    template: `<div class="se-breadcrumb"><div *ngFor="let node of breadcrumb; index as idx; last as isLast" class="se-breadcrumb__node"><div class="se-breadcrumb__info" [ngClass]="{'se-breadcrumb__info--last': isLast}"><span class="se-breadcrumb__info--level">{{ node.formattedLevel | translate: node }}</span> <span class="se-breadcrumb__info--name">{{ node.name }}</span></div><div class="se-breadcrumb__divider" *ngIf="idx < breadcrumb.length - 1"><span class="sap-icon--navigation-right-arrow"></span></div></div></div>`,
    styles: [`.se-breadcrumb{border-bottom:1px solid #eeeeef;margin-bottom:35px}.se-breadcrumb__divider,.se-breadcrumb__info,.se-breadcrumb__node{display:inline-block}.se-breadcrumb__info--last{border-bottom:3px solid #0a6ed1;padding-top:10px;padding-bottom:10px}.se-breadcrumb__info--level{display:block;text-transform:uppercase;color:#51555a;font-family:"72",web,"Open Sans",sans-serif;font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;font-weight:700}.se-breadcrumb__info--name{display:block;color:#51555a;font-family:"72",web,"Open Sans",sans-serif;font-size:1rem;line-height:1.4285714286;font-weight:400;font-weight:400}.se-breadcrumb__divider{margin-left:15px;margin-right:15px;margin-top:5px;vertical-align:top}.se-breadcrumb__node:last-child .se-breadcrumb__info--level,.se-breadcrumb__node:last-child .se-breadcrumb__info--name{color:#0a6ed1}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    encapsulation: core.ViewEncapsulation.None
});
let /* @ngInject */ BreadcrumbComponent = class /* @ngInject */ BreadcrumbComponent {
    constructor(navigationEditorNodeService, cmsitemsRestService, cdr) {
        this.navigationEditorNodeService = navigationEditorNodeService;
        this.cmsitemsRestService = cmsitemsRestService;
        this.cdr = cdr;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.nodeUid && !this.nodeUuid) {
                throw new Error('BreadcrumbComponent requires either nodeUid or nodeUuid');
            }
            const uid = yield this.getUid();
            const ancestry = yield this.navigationEditorNodeService.getNavigationNodeAncestry(uid, this.uriContext);
            this.breadcrumb = ancestry;
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    getUid() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.nodeUid) {
                const cmsItem = yield this.cmsitemsRestService.getById(this.nodeUuid);
                return cmsItem.uid;
            }
            return this.nodeUid;
        });
    }
};
BreadcrumbComponent.$inject = ["navigationEditorNodeService", "cmsitemsRestService", "cdr"];
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ BreadcrumbComponent.prototype, "nodeUid", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ BreadcrumbComponent.prototype, "nodeUuid", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ BreadcrumbComponent.prototype, "uriContext", void 0);
/* @ngInject */ BreadcrumbComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-breadcrumb',
        template: `<div class="se-breadcrumb"><div *ngFor="let node of breadcrumb; index as idx; last as isLast" class="se-breadcrumb__node"><div class="se-breadcrumb__info" [ngClass]="{'se-breadcrumb__info--last': isLast}"><span class="se-breadcrumb__info--level">{{ node.formattedLevel | translate: node }}</span> <span class="se-breadcrumb__info--name">{{ node.name }}</span></div><div class="se-breadcrumb__divider" *ngIf="idx < breadcrumb.length - 1"><span class="sap-icon--navigation-right-arrow"></span></div></div></div>`,
        styles: [`.se-breadcrumb{border-bottom:1px solid #eeeeef;margin-bottom:35px}.se-breadcrumb__divider,.se-breadcrumb__info,.se-breadcrumb__node{display:inline-block}.se-breadcrumb__info--last{border-bottom:3px solid #0a6ed1;padding-top:10px;padding-bottom:10px}.se-breadcrumb__info--level{display:block;text-transform:uppercase;color:#51555a;font-family:"72",web,"Open Sans",sans-serif;font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;font-weight:700}.se-breadcrumb__info--name{display:block;color:#51555a;font-family:"72",web,"Open Sans",sans-serif;font-size:1rem;line-height:1.4285714286;font-weight:400;font-weight:400}.se-breadcrumb__divider{margin-left:15px;margin-right:15px;margin-top:5px;vertical-align:top}.se-breadcrumb__node:last-child .se-breadcrumb__info--level,.se-breadcrumb__node:last-child .se-breadcrumb__info--name{color:#0a6ed1}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush,
        encapsulation: core.ViewEncapsulation.None
    }),
    __metadata("design:paramtypes", [NavigationEditorNodeService,
        smarteditcommons.CmsitemsRestService,
        core.ChangeDetectorRef])
], /* @ngInject */ BreadcrumbComponent);

/*
 * Copyright (c) 2022 SAP SE or an SAP affiliate company. All rights reserved.
 */
const SELECTED_NODE = 'selected_node';

window.__smartedit__.addDecoratorPayload("Component", "NavigationNodePickerRenderComponent", {
    selector: 'se-navigation-node-picker-render',
    template: `<div class="se-tree-node__name col-xs-6" [title]="node.name | seL10n | async"><span>{{ node.name | seL10n | async }}</span></div><div class="col-sm-4 pull-right tree-node se-navigation-picker-renderer" (click)="pick(node)" *ngIf="isEditable()"><a translate="se.cms.navigationcomponent.management.node.selection.select.action" class="btn btn-link se-navigation-picker-renderer__btn"></a></div>`
});
let /* @ngInject */ NavigationNodePickerRenderComponent = class /* @ngInject */ NavigationNodePickerRenderComponent {
    constructor(parent, node) {
        this.parent = parent;
        this.node = node;
    }
    ngOnInit() {
        ({ pick: this.pick, isEditable: this.isEditable } = this.parent.nodeActions);
    }
};
NavigationNodePickerRenderComponent.$inject = ["parent", "node"];
/* @ngInject */ NavigationNodePickerRenderComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-navigation-node-picker-render',
        template: `<div class="se-tree-node__name col-xs-6" [title]="node.name | seL10n | async"><span>{{ node.name | seL10n | async }}</span></div><div class="col-sm-4 pull-right tree-node se-navigation-picker-renderer" (click)="pick(node)" *ngIf="isEditable()"><a translate="se.cms.navigationcomponent.management.node.selection.select.action" class="btn btn-link se-navigation-picker-renderer__btn"></a></div>`
    }),
    __param(0, core.Inject(core.forwardRef(() => smarteditcommons.TreeComponent))),
    __param(1, core.Inject(smarteditcommons.TREE_NODE)),
    __metadata("design:paramtypes", [smarteditcommons.TreeComponent, Object])
], /* @ngInject */ NavigationNodePickerRenderComponent);

window.__smartedit__.addDecoratorPayload("Component", "NavigationNodePickerComponent", {
    selector: 'se-navigation-node-picker',
    template: `<div class="categoryTable"><div class="tablehead clearfix hidden-xs se-navigation-editor-tree__head"><div translate="se.ytree.template.header.name" class="se-navigation-editor-tree__name col-md-offset-1 col-sm-5"></div></div><se-tree [nodeUri]="nodeURI" [rootNodeUid]="rootNodeUid" [nodeComponent]="nodePickerRenderComponent" [removeDefaultTemplate]="removeDefaultTemplate" [nodeActions]="actions"></se-tree></div>`,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ NavigationNodePickerComponent = class /* @ngInject */ NavigationNodePickerComponent {
    constructor(cmsitemsRestService, systemEventService) {
        this.cmsitemsRestService = cmsitemsRestService;
        this.systemEventService = systemEventService;
        this.nodePickerRenderComponent = NavigationNodePickerRenderComponent;
        this.removeDefaultTemplate = true;
        this.rootNodeUid = cmscommons.NAVIGATION_NODE_ROOT_NODE_UID;
        this.editable = true;
    }
    ngOnInit() {
        this.nodeURI = new smarteditcommons.URIBuilder(cmscommons.NAVIGATION_MANAGEMENT_RESOURCE_URI)
            .replaceParams(this.uriContext)
            .build();
        this.actions = {
            pick: (treeService, node) => __awaiter(this, void 0, void 0, function* () {
                const requestParams = {
                    pageSize: 10,
                    currentPage: 0,
                    mask: node.uid,
                    typeCode: 'CMSNavigationNode',
                    itemSearchParams: ''
                };
                const result = yield this.cmsitemsRestService.get(requestParams);
                const foundNode = result.response.find((element) => element.uid === node.uid);
                const idObject = {
                    nodeUuid: foundNode === null || foundNode === void 0 ? void 0 : foundNode.uuid,
                    nodeUid: node.uid
                };
                this.systemEventService.publishAsync(SELECTED_NODE, idObject);
            }),
            isEditable: () => this.editable
        };
    }
};
NavigationNodePickerComponent.$inject = ["cmsitemsRestService", "systemEventService"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ NavigationNodePickerComponent.prototype, "uriContext", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], /* @ngInject */ NavigationNodePickerComponent.prototype, "editable", void 0);
/* @ngInject */ NavigationNodePickerComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-navigation-node-picker',
        template: `<div class="categoryTable"><div class="tablehead clearfix hidden-xs se-navigation-editor-tree__head"><div translate="se.ytree.template.header.name" class="se-navigation-editor-tree__name col-md-offset-1 col-sm-5"></div></div><se-tree [nodeUri]="nodeURI" [rootNodeUid]="rootNodeUid" [nodeComponent]="nodePickerRenderComponent" [removeDefaultTemplate]="removeDefaultTemplate" [nodeActions]="actions"></se-tree></div>`,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [smarteditcommons.CmsitemsRestService,
        smarteditcommons.SystemEventService])
], /* @ngInject */ NavigationNodePickerComponent);

window.__smartedit__.addDecoratorPayload("Component", "NavigationNodeSelectorComponent", {
    selector: 'se-navigation-node-selector',
    template: `<div *ngIf="isReady"><div *ngIf="cmsItem[qualifier]" class="se-navigation-mode"><div class="se-navigation__node"><se-breadcrumb class="se-navigation__node-breadcrumb" [nodeUuid]="cmsItem[qualifier]" [uriContext]="uriContext"></se-breadcrumb><div class="se-navigation__node-button"><button class="btn btn-link btn-block se-navigation__button" (click)="remove($event)" [disabled]="!field.editable" translate="se.cms.navigationcomponent.management.node.selection.remove.action"></button></div></div><se-navigation-editor-tree [uriContext]="uriContext" [readOnly]="true" [rootNodeUid]="nodeUid"></se-navigation-editor-tree></div><div *ngIf="!cmsItem[qualifier]"><label translate="se.cms.navigationcomponent.management.node.selection.invite.action"></label><se-navigation-node-picker [uriContext]="uriContext" [editable]="field.editable"></se-navigation-node-picker></div></div>`,
    styles: [`.se-navigation__node{display:flex;background-color:#fafafa;padding:0 20px;margin:0 -20px 20px -20px;border-top:1px solid #eeeeef;border-bottom:1px solid #eeeeef}.se-navigation__node-breadcrumb{flex:10}.se-navigation__node-breadcrumb .se-breadcrumb{margin-bottom:0;border:none}.se-navigation__node-button{flex:2;display:flex}.se-navigation__button{font-size:15px;font-family:"72",web,"Open Sans",sans-serif;font-weight:700;align-self:flex-end;text-transform:capitalize}se-navigation-node-selector .se-navigation-editor-tree{margin:0}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    encapsulation: core.ViewEncapsulation.None
});
let /* @ngInject */ NavigationNodeSelectorComponent = class /* @ngInject */ NavigationNodeSelectorComponent {
    constructor(data, catalogService, cmsitemsRestService, systemEventService, cdr) {
        this.data = data;
        this.catalogService = catalogService;
        this.cmsitemsRestService = cmsitemsRestService;
        this.systemEventService = systemEventService;
        this.cdr = cdr;
        this.isReady = false;
        this.nodeUid = null;
        this.uriContext = null;
        ({ field: this.field, model: this.cmsItem, qualifier: this.qualifier } = this.data);
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const uriContext = yield this.catalogService.retrieveUriContext();
            this.uriContext = uriContext;
            if (this.cmsItem[this.qualifier]) {
                const cmsItem = yield this.cmsitemsRestService.getById(this.cmsItem[this.qualifier]);
                this.nodeUid = cmsItem.uid;
                this.isReady = true;
            }
            else {
                this.isReady = true;
            }
            this.unregisterSubscription = this.systemEventService.subscribe(SELECTED_NODE, (_eventId, { nodeUid, nodeUuid }) => {
                this.nodeUid = nodeUid;
                this.cmsItem[this.qualifier] = nodeUuid;
                if (!this.cdr.destroyed) {
                    this.cdr.detectChanges();
                }
            });
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    ngOnDestroy() {
        this.unregisterSubscription();
    }
    remove() {
        delete this.cmsItem[this.qualifier];
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
    }
};
NavigationNodeSelectorComponent.$inject = ["data", "catalogService", "cmsitemsRestService", "systemEventService", "cdr"];
/* @ngInject */ NavigationNodeSelectorComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-navigation-node-selector',
        template: `<div *ngIf="isReady"><div *ngIf="cmsItem[qualifier]" class="se-navigation-mode"><div class="se-navigation__node"><se-breadcrumb class="se-navigation__node-breadcrumb" [nodeUuid]="cmsItem[qualifier]" [uriContext]="uriContext"></se-breadcrumb><div class="se-navigation__node-button"><button class="btn btn-link btn-block se-navigation__button" (click)="remove($event)" [disabled]="!field.editable" translate="se.cms.navigationcomponent.management.node.selection.remove.action"></button></div></div><se-navigation-editor-tree [uriContext]="uriContext" [readOnly]="true" [rootNodeUid]="nodeUid"></se-navigation-editor-tree></div><div *ngIf="!cmsItem[qualifier]"><label translate="se.cms.navigationcomponent.management.node.selection.invite.action"></label><se-navigation-node-picker [uriContext]="uriContext" [editable]="field.editable"></se-navigation-node-picker></div></div>`,
        styles: [`.se-navigation__node{display:flex;background-color:#fafafa;padding:0 20px;margin:0 -20px 20px -20px;border-top:1px solid #eeeeef;border-bottom:1px solid #eeeeef}.se-navigation__node-breadcrumb{flex:10}.se-navigation__node-breadcrumb .se-breadcrumb{margin-bottom:0;border:none}.se-navigation__node-button{flex:2;display:flex}.se-navigation__button{font-size:15px;font-family:"72",web,"Open Sans",sans-serif;font-weight:700;align-self:flex-end;text-transform:capitalize}se-navigation-node-selector .se-navigation-editor-tree{margin:0}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush,
        encapsulation: core.ViewEncapsulation.None
    }),
    __param(0, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [Object, smarteditcommons.ICatalogService,
        smarteditcommons.CmsitemsRestService,
        smarteditcommons.SystemEventService,
        core.ChangeDetectorRef])
], /* @ngInject */ NavigationNodeSelectorComponent);

window.__smartedit__.addDecoratorPayload("Component", "NavigationEditorLinkComponent", {
    selector: 'se-navigation-editor-link',
    template: `
        <div class="nav-management-link-container">
            <a
                class="nav-management-link-item__link se-catalog-version__link"
                [href]="getLink()"
                translate="se.cms.cataloginfo.navigationmanagement"
                (click)="onClick()"
            ></a>
        </div>
    `
});
let /* @ngInject */ NavigationEditorLinkComponent = class /* @ngInject */ NavigationEditorLinkComponent {
    constructor(catalogDetails, userTrackingService) {
        this.catalogDetails = catalogDetails;
        this.userTrackingService = userTrackingService;
    }
    getLink() {
        const { siteId, catalog: { catalogId }, catalogVersion: { version } } = this.catalogDetails;
        return `#!/${smarteditcommons.NG_ROUTE_PREFIX}/navigations/${siteId}/${catalogId}/${version}`;
    }
    onClick() {
        this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.NAVIGATION, this.catalogDetails.catalogVersion + ' - Navigation');
    }
};
NavigationEditorLinkComponent.$inject = ["catalogDetails", "userTrackingService"];
/* @ngInject */ NavigationEditorLinkComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-navigation-editor-link',
        template: `
        <div class="nav-management-link-container">
            <a
                class="nav-management-link-item__link se-catalog-version__link"
                [href]="getLink()"
                translate="se.cms.cataloginfo.navigationmanagement"
                (click)="onClick()"
            ></a>
        </div>
    `
    }),
    __param(0, core.Inject(smarteditcommons.CATALOG_DETAILS_ITEM_DATA)),
    __metadata("design:paramtypes", [Object, smarteditcommons.UserTrackingService])
], /* @ngInject */ NavigationEditorLinkComponent);

window.__smartedit__.addDecoratorPayload("Component", "NavigationManagementPageComponent", {
    selector: 'se-navigation-management-page',
    template: `<div class="se-navigation-management-page-list-template"><div class="se-toolbar-group"><se-toolbar cssClass="se-toolbar--shell" imageRoot="imageRoot" toolbarName="smartEditHeaderToolbar"></se-toolbar><se-toolbar cssClass="se-toolbar--shell se-toolbar--shortcut" imageRoot="imageRoot" toolbarName="smartEditNavigationToolbar"></se-toolbar></div><div class="se-navigation-editor-wrapper" *ngIf="readOnly !== undefined"><div class="se-navigation-editor-header"><h1 class="se-navigation-editor-header__title" translate="se.cms.navigationmanagement.title"></h1><h4 class="se-navigation-editor-header__sub-title">{{ catalogName | seL10n | async }} - {{ catalogVersion }}</h4></div><se-navigation-editor-tree [uriContext]="uriContext" [readOnly]="readOnly"></se-navigation-editor-tree></div></div>`,
    styles: [`.se-navigation-editor-wrapper{min-height:100vh;padding:95px 30px 30px 30px;background-color:#edeff0}.se-navigation-editor-header{position:relative;min-height:100%;background-color:#fff;font-family:"72",web,"Open Sans",sans-serif;margin:0 -30px 20px -30px;padding:16px 30px}.se-navigation-editor-header__title{font-size:1.7142857143rem;line-height:1.3333333333;font-weight:400;color:#32363a;margin:0;padding:0}.se-navigation-editor-header__sub-title{font-size:1rem;line-height:1.4285714286;font-weight:400;color:#6a6d70;margin:0;padding:5px 0 0 0}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ NavigationManagementPageComponent = class /* @ngInject */ NavigationManagementPageComponent {
    constructor(activatedRoute, urlService, permissionService, catalogService, cdr) {
        this.activatedRoute = activatedRoute;
        this.urlService = urlService;
        this.permissionService = permissionService;
        this.catalogService = catalogService;
        this.cdr = cdr;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const { siteId, catalogId, catalogVersion } = this.activatedRoute.snapshot.params;
            this.catalogVersion = catalogVersion;
            this.uriContext = this.urlService.buildUriContext(siteId, catalogId, catalogVersion);
            yield Promise.all([this.setCatalogName(siteId, catalogId), this.setReadOnly()]);
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    setCatalogName(siteId, catalogId) {
        return __awaiter(this, void 0, void 0, function* () {
            const catalogs = yield this.catalogService.getContentCatalogsForSite(siteId);
            const foundCatalog = catalogs.find((catalog) => catalog.catalogId === catalogId);
            this.catalogName = (foundCatalog === null || foundCatalog === void 0 ? void 0 : foundCatalog.name) || {};
        });
    }
    setReadOnly() {
        return __awaiter(this, void 0, void 0, function* () {
            const isPermissionGranted = yield this.permissionService.isPermitted([
                {
                    names: ['se.edit.navigation']
                }
            ]);
            this.readOnly = !isPermissionGranted;
        });
    }
};
NavigationManagementPageComponent.$inject = ["activatedRoute", "urlService", "permissionService", "catalogService", "cdr"];
/* @ngInject */ NavigationManagementPageComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-navigation-management-page',
        template: `<div class="se-navigation-management-page-list-template"><div class="se-toolbar-group"><se-toolbar cssClass="se-toolbar--shell" imageRoot="imageRoot" toolbarName="smartEditHeaderToolbar"></se-toolbar><se-toolbar cssClass="se-toolbar--shell se-toolbar--shortcut" imageRoot="imageRoot" toolbarName="smartEditNavigationToolbar"></se-toolbar></div><div class="se-navigation-editor-wrapper" *ngIf="readOnly !== undefined"><div class="se-navigation-editor-header"><h1 class="se-navigation-editor-header__title" translate="se.cms.navigationmanagement.title"></h1><h4 class="se-navigation-editor-header__sub-title">{{ catalogName | seL10n | async }} - {{ catalogVersion }}</h4></div><se-navigation-editor-tree [uriContext]="uriContext" [readOnly]="readOnly"></se-navigation-editor-tree></div></div>`,
        styles: [`.se-navigation-editor-wrapper{min-height:100vh;padding:95px 30px 30px 30px;background-color:#edeff0}.se-navigation-editor-header{position:relative;min-height:100%;background-color:#fff;font-family:"72",web,"Open Sans",sans-serif;margin:0 -30px 20px -30px;padding:16px 30px}.se-navigation-editor-header__title{font-size:1.7142857143rem;line-height:1.3333333333;font-weight:400;color:#32363a;margin:0;padding:0}.se-navigation-editor-header__sub-title{font-size:1rem;line-height:1.4285714286;font-weight:400;color:#6a6d70;margin:0;padding:5px 0 0 0}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [router.ActivatedRoute,
        smarteditcommons.IUrlService,
        smarteditcommons.IPermissionService,
        smarteditcommons.ICatalogService,
        core.ChangeDetectorRef])
], /* @ngInject */ NavigationManagementPageComponent);

/**
 * Convenience service to open an editor modal window for a given navigation node's data.
 */
let /* @ngInject */ NavigationNodeEditorModalService = class /* @ngInject */ NavigationNodeEditorModalService {
    constructor(genericEditorModalService, catalogService) {
        this.genericEditorModalService = genericEditorModalService;
        this.catalogService = catalogService;
    }
    /**
     *
     * Opens a modal for creating and editing a navigation node with the CSM items API. Leave the current parameter to trigger
     * a creation operation.
     *
     * @param uriContext The uri context of the navigational node.
     * @param parent The parent navigational node.
     * @param current The current navigational node. If the current node is left empty, the modal
     * will process a creation operation.
     */
    open(uriContext, parent, current) {
        return __awaiter(this, void 0, void 0, function* () {
            // If the current node is provided then the content will resolve null to indicate an editing process.
            let content = null;
            if (!current) {
                const catalogVersion = yield this.catalogService.getCatalogVersionUUid(uriContext);
                content = {
                    catalogVersion,
                    parent: parent.uuid,
                    itemtype: cmscommons.NAVIGATION_NODE_TYPECODE,
                    visible: true
                };
            }
            return this.genericEditorModalService.open({
                componentUuid: current ? current.uuid : null,
                componentType: cmscommons.NAVIGATION_NODE_TYPECODE,
                content,
                title: 'se.cms.navigationmanagement.node.edit.title'
            }, (item) => item, null, {
                modalPanelClass: 'modal-stretched'
            });
        });
    }
};
NavigationNodeEditorModalService.$inject = ["genericEditorModalService", "catalogService"];
/* @ngInject */ NavigationNodeEditorModalService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [exports.GenericEditorModalService,
        smarteditcommons.ICatalogService])
], /* @ngInject */ NavigationNodeEditorModalService);

var /* @ngInject */ NavigationEditorTreeActions_1;
// TODO: unit tests
let /* @ngInject */ NavigationEditorTreeActions = /* @ngInject */ NavigationEditorTreeActions_1 = class /* @ngInject */ NavigationEditorTreeActions {
    constructor(logService, cmsitemsRestService, confirmationModalService, navigationEditorNodeService, navigationNodeEditorModalService, userTrackingService) {
        this.logService = logService;
        this.cmsitemsRestService = cmsitemsRestService;
        this.confirmationModalService = confirmationModalService;
        this.navigationEditorNodeService = navigationEditorNodeService;
        this.navigationNodeEditorModalService = navigationNodeEditorModalService;
        this.userTrackingService = userTrackingService;
    }
    /**
     * Sets fields required for this service to work properly
     */
    setup(readOnly, rootNodeUid, uriContext) {
        this.readOnly = readOnly;
        this.rootNodeUid = rootNodeUid;
        this.uriContext = uriContext;
    }
    /**
     * Exposes methods of this service to a literal object.
     *
     * This literal object is used by `TreeComponent#setNodeActions` (smarteditcommons)
     * It sets new context and "inject" treeService param for all methods using `.bind`
     *
     * It is done this way, so TreeComponent can easily iterate over the methods, if we would passed instance of this class it wouldn't be easy to iterate over these methods
     */
    getActions() {
        return {
            isReadOnly: () => this.isReadOnly(),
            hasChildren: (treeService, nodeData) => this.hasChildren(treeService, nodeData),
            fetchData: (treeService, nodeData) => this.fetchData(treeService, nodeData),
            removeItem: (treeService, nodeData) => this.removeItem(treeService, nodeData),
            performMove: (treeService, nodeData, refreshNodeItself) => this.performMove(treeService, nodeData, refreshNodeItself),
            dragAndDrop: (treeService, event) => this.dragAndDrop(treeService, event),
            moveUp: (treeService, nodeData) => this.moveUp(treeService, nodeData),
            moveDown: (treeService, nodeData) => this.moveDown(treeService, nodeData),
            isMoveUpAllowed: (treeService, nodeData) => this.isMoveUpAllowed(treeService, nodeData),
            isMoveDownAllowed: (treeService, nodeData) => this.isMoveDownAllowed(treeService, nodeData),
            refreshNode: (treeService, nodeData) => this.refreshNode(treeService, nodeData),
            refreshParentNode: (treeService, nodeData) => this.refreshParentNode(treeService, nodeData),
            editNavigationNode: (treeService, nodeData) => this.editNavigationNode(treeService, nodeData),
            addTopLevelNode: (treeService, nodeData) => this.addTopLevelNode(treeService, nodeData),
            getEntryString: (treeService, nodeData) => this.getEntryString(treeService, nodeData),
            getEntryTooltipString: (treeService, nodeData) => this.getEntryTooltipString(treeService, nodeData),
            addNewChild: (treeService, nodeData) => this.addNewChild(treeService, nodeData),
            addNewSibling: (treeService, nodeData) => this.addNewSibling(treeService, nodeData),
            getDropdownItems: (treeService) => this.getDropdownItems(treeService),
            _findNodeById: (treeService, nodeUid) => this._findNodeById(treeService, nodeUid),
            _expandIfNeeded: (treeService, nodeData) => this._expandIfNeeded(treeService, nodeData)
        };
    }
    getNavigationNodeCMSItemByUid(uid) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.cmsitemsRestService.get({
                typeCode: cmscommons.NAVIGATION_NODE_TYPECODE,
                pageSize: 1,
                currentPage: 0,
                itemSearchParams: 'uid:' + uid
            });
            return result.response[0];
        });
    }
    hasNotMoved(source, destinationPosition, destinationParent) {
        return (source.position === destinationPosition && source.parentUid === destinationParent.uid);
    }
    getEntriesCommaSeparated(entries) {
        return entries.map((entry) => `${entry.name} (${entry.itemType})`).join(', ');
    }
    /** Actions */
    isReadOnly() {
        return this.readOnly;
    }
    hasChildren(_treeService, nodeData) {
        return nodeData.hasChildren;
    }
    fetchData(treeService, nodeData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (nodeData.initiated) {
                return nodeData.nodes;
            }
            if (nodeData.uid === cmscommons.NAVIGATION_NODE_ROOT_NODE_UID) {
                nodeData.initiated = false;
                const node = yield this.getNavigationNodeCMSItemByUid(this.rootNodeUid);
                lodash.assign(nodeData, node);
            }
            nodeData.removeAllNodes();
            return treeService.fetchChildren(nodeData);
        });
    }
    removeItem(treeService, node) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.readOnly) {
                throw /* @ngInject */ NavigationEditorTreeActions_1.READY_ONLY_ERROR_I18N;
            }
            this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.NAVIGATION_MANAGEMENT, 'Delete');
            let isConfirmed = true;
            try {
                // IMPORTANT NOTE
                // `confirmationModalService.confirm` resolves to null
                // that's why `isConfirmed` is not set here
                yield this.confirmationModalService.confirm({
                    description: 'se.cms.navigationmanagement.navnode.removenode.confirmation.message',
                    title: 'se.cms.navigationmanagement.navnode.removenode.confirmation.title'
                });
            }
            catch (_a) {
                isConfirmed = false;
            }
            if (isConfirmed) {
                yield this.cmsitemsRestService.delete(node.uuid);
                this.refreshParentNode(treeService, node);
            }
        });
    }
    performMove(treeService, node, refreshNodeItself) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.readOnly) {
                throw /* @ngInject */ NavigationEditorTreeActions_1.READY_ONLY_ERROR_I18N;
            }
            try {
                yield this.navigationEditorNodeService.updateNavigationNodePosition(node);
                if (!node) {
                    yield this.fetchData(treeService, treeService.root);
                }
                else if (refreshNodeItself) {
                    yield this.refreshNode(treeService, node);
                }
                else {
                    yield this.refreshParentNode(treeService, node);
                }
            }
            catch (err) {
                this.logService.error(`Error updating node position:\n${err}`);
            }
        });
    }
    dragAndDrop(treeService, event) {
        return __awaiter(this, void 0, void 0, function* () {
            const nodeData = event.sourceNode;
            const destinationNodes = event.destinationNodes;
            const destination = destinationNodes.find((node) => node.uid !== nodeData.uid);
            // this method is still triggered on drop, even if drop is not allowed
            // so its possible that destination does not exist, in which case we return silently
            if (!destination) {
                return;
            }
            const destinationParent = destination.parent;
            if (this.hasNotMoved(nodeData, event.position, destinationParent)) {
                return;
            }
            nodeData.position = event.position;
            nodeData.setParent(destinationParent);
            yield this.performMove(treeService, nodeData, true);
            if (event.sourceParentNode.uid !== event.destinationParentNode.uid) {
                this.refreshNode(treeService, event.sourceParentNode);
            }
        });
    }
    moveUp(treeService, nodeData) {
        if (this.readOnly) {
            throw /* @ngInject */ NavigationEditorTreeActions_1.READY_ONLY_ERROR_I18N;
        }
        this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.NAVIGATION_MANAGEMENT, 'Move Up');
        nodeData.position = nodeData.position - 1;
        return this.performMove(treeService, nodeData);
    }
    moveDown(treeService, nodeData) {
        if (this.readOnly) {
            throw /* @ngInject */ NavigationEditorTreeActions_1.READY_ONLY_ERROR_I18N;
        }
        this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.NAVIGATION_MANAGEMENT, 'Move Down');
        nodeData.position = nodeData.position + 1;
        return this.performMove(treeService, nodeData);
    }
    isMoveUpAllowed(_treeService, nodeData) {
        return nodeData.position !== 0;
    }
    isMoveDownAllowed(_treeService, nodeData) {
        nodeData.parent.nodes = nodeData.parent.nodes || [];
        return nodeData.position < nodeData.parent.nodes.length - 1;
    }
    refreshNode(treeService, nodeData) {
        nodeData.setInitiated(false);
        return treeService.fetchChildren(nodeData);
    }
    refreshParentNode(treeService, nodeData) {
        return this.refreshNode(treeService, nodeData.parent);
    }
    editNavigationNode(treeService, nodeData) {
        return __awaiter(this, void 0, void 0, function* () {
            this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.NAVIGATION_MANAGEMENT, 'Edit');
            try {
                yield this.navigationNodeEditorModalService.open(this.uriContext, nodeData.parent, nodeData);
                yield this.refreshNode(treeService, nodeData.parent);
                let targetNode;
                if (nodeData.parent.uid === cmscommons.NAVIGATION_NODE_ROOT_NODE_UID) {
                    targetNode = nodeData;
                }
                else {
                    targetNode = nodeData.parent;
                }
                const refreshedNode = yield this.navigationEditorNodeService.getNavigationNode(targetNode.uid, this.uriContext);
                lodash.assign(targetNode, refreshedNode);
                if (nodeData.parent.uid === cmscommons.NAVIGATION_NODE_ROOT_NODE_UID) {
                    return this.refreshNode(treeService, nodeData);
                }
                return this.refreshParentNode(treeService, nodeData);
            }
            catch (_a) {
                this.logService.warn('navigationNodeEditorModalService closed when editing navigation node');
            }
        });
    }
    addTopLevelNode(treeService, nodeData) {
        return __awaiter(this, void 0, void 0, function* () {
            this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.NAVIGATION_MANAGEMENT, 'Create Top Level');
            const created = !!(yield this.addNewChild(treeService, nodeData));
            if (created) {
                const node = yield this.getNavigationNodeCMSItemByUid(this.rootNodeUid);
                yield this.fetchData(treeService, node);
            }
        });
    }
    getEntryString(_treeService, node) {
        return this.getEntriesCommaSeparated(node.entries || []);
    }
    getEntryTooltipString(_treeService, node) {
        return [
            '<div>',
            ...(node.entries || []).map((entry) => `<div>${entry.name} (${entry.itemType})</div>`),
            '</div>'
        ].join('');
    }
    addNewChild(treeService, nodeData) {
        return __awaiter(this, void 0, void 0, function* () {
            this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.NAVIGATION_MANAGEMENT, 'Add a Child');
            const parent = nodeData ? nodeData : this._findNodeById(treeService, this.rootNodeUid);
            yield this._expandIfNeeded(treeService, nodeData);
            try {
                yield this.navigationNodeEditorModalService.open(this.uriContext, parent);
                return this.refreshNode(treeService, parent);
            }
            catch (_a) {
                this.logService.warn('navigationNodeEditorModalService closed when adding new child');
            }
        });
    }
    addNewSibling(treeService, nodeData) {
        return __awaiter(this, void 0, void 0, function* () {
            this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.NAVIGATION_MANAGEMENT, 'Add a Sibling');
            const parent = nodeData.parent;
            try {
                yield this.navigationNodeEditorModalService.open(this.uriContext, parent);
                return this.refreshNode(treeService, parent);
            }
            catch (_a) {
                this.logService.warn('navigationNodeEditorModalService closed when adding new sibling');
            }
        });
    }
    getDropdownItems(treeService) {
        return [
            {
                key: 'se.cms.navigationmanagement.navnode.edit',
                callback: (node) => {
                    this.editNavigationNode(treeService, node);
                }
            },
            {
                key: 'se.cms.navigationmanagement.navnode.removenode',
                customCss: 'se-dropdown-item__delete',
                callback: (node) => {
                    this.removeItem(treeService, node);
                }
            },
            {
                key: 'se.cms.navigationmanagement.navnode.move.up',
                condition: (node) => this.isMoveUpAllowed(treeService, node),
                callback: (node) => {
                    this.moveUp(treeService, node);
                }
            },
            {
                key: 'se.cms.navigationmanagement.navnode.move.down',
                condition: (node) => this.isMoveDownAllowed(treeService, node),
                callback: (node) => {
                    this.moveDown(treeService, node);
                }
            },
            {
                key: 'se.cms.navigationmanagement.navnode.addchild',
                callback: (node) => {
                    this.addNewChild(treeService, node);
                }
            },
            {
                key: 'se.cms.navigationmanagement.navnode.addsibling',
                callback: (node) => {
                    this.addNewSibling(treeService, node);
                }
            }
        ];
    }
    _findNodeById(treeService, nodeUid) {
        return treeService.getNodeById(nodeUid);
    }
    _expandIfNeeded(treeService, nodeData) {
        return nodeData && !nodeData.isExpanded ? treeService.toggle(nodeData) : Promise.resolve();
    }
};
/* @ngInject */ NavigationEditorTreeActions.READY_ONLY_ERROR_I18N = 'navigation.in.readonly.mode';
__decorate([
    smarteditcommons.InvalidateCache(smarteditcommons.cmsitemsEvictionTag),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], /* @ngInject */ NavigationEditorTreeActions.prototype, "getNavigationNodeCMSItemByUid", null);
/* @ngInject */ NavigationEditorTreeActions = /* @ngInject */ NavigationEditorTreeActions_1 = __decorate([
    core.Injectable(),
    __metadata("design:paramtypes", [smarteditcommons.LogService,
        smarteditcommons.CmsitemsRestService,
        smarteditcommons.IConfirmationModalService,
        NavigationEditorNodeService,
        NavigationNodeEditorModalService,
        smarteditcommons.UserTrackingService])
], /* @ngInject */ NavigationEditorTreeActions);

let /* @ngInject */ NavigationEditorTreeDragOptions = class /* @ngInject */ NavigationEditorTreeDragOptions {
    /**
     * Sets the dragAndDrop callback handler
     *
     * @param dragAndDropFunc Function to be called when `onDropCallback` is called
     */
    setup(dragAndDropFunc) {
        this.dragAndDropHandler = dragAndDropFunc;
    }
    /**
     * Exposes methods of this service to a literal object.
     *
     * This literal object is used by `TreeComponent#setNodeActions` (smarteditcommons)
     * It sets new context and "inject" param for all methods using `.bind`
     *
     * It is done this way, so TreeComponent can easily iterate over the methods, if we would passed instance of this class it wouldn't be easy to iterate over these methods
     */
    getDragOptions() {
        return {
            onDropCallback: (event) => this.onDropCallback(event),
            allowDropCallback: this.allowDropCallback,
            beforeDropCallback: this.beforeDropCallback
        };
    }
    onDropCallback(event) {
        this.dragAndDropHandler(event);
    }
    allowDropCallback(event) {
        return event.sourceNode.parent.uid === event.destinationNodes[0].parent.uid;
    }
    beforeDropCallback(event) {
        if (event.sourceNode.parent.uid !== event.destinationNodes[0].parent.uid) {
            return Promise.resolve({
                confirmDropI18nKey: 'se.cms.navigationmanagement.navnode.confirmation'
            });
        }
        return Promise.resolve(true);
    }
};
/* @ngInject */ NavigationEditorTreeDragOptions = __decorate([
    core.Injectable()
], /* @ngInject */ NavigationEditorTreeDragOptions);

window.__smartedit__.addDecoratorPayload("Component", "NavigationNodeComponent", {
    selector: 'se-navigation-node',
    template: `<div class="pull-right dropdown tree-node se-tree-node__actions col-sm-1" [hidden]="isReadOnly"><se-dropdown-menu [dropdownItems]="dropdownItems" [selectedItem]="node" class="pull-right se-tree-node__actions--more-menu"></se-dropdown-menu></div><div class="se-tree-node__name col-xs-3" [title]="node.name | seL10n | async"><span>{{ node.name | seL10n | async }}</span></div><div class="pull-right tree-node se-tree-node__entry col-xs-5"><se-tooltip class="se-dropdown-item__delete-page-popover" [triggers]="['mouseenter', 'mouseleave']" [isChevronVisible]="true" [appendTo]="'body'"><span se-tooltip-trigger class="se-tree-node__popover"><span>{{ entryString }} </span></span><span se-tooltip-body>{{ entryString }}</span></se-tooltip></div><div class="se-tree-node__title col-xs-2"><span [hidden]="!node.title">{{ node.title | seL10n | async }}</span></div>`,
    styles: [`se-navigation-node .se-dropdown-item__delete-page-popover,se-navigation-node .se-dropdown-item__delete-page-popover .se-tooltip{max-width:100%}`],
    encapsulation: core.ViewEncapsulation.None,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let NavigationNodeComponent = class NavigationNodeComponent {
    constructor(parent, node) {
        this.parent = parent;
        this.node = node;
        this.dropdownItems = [];
    }
    ngOnInit() {
        const { getDropdownItems, isReadOnly, getEntryString } = this.parent
            .nodeActions;
        this.dropdownItems = getDropdownItems();
        this.isReadOnly = isReadOnly();
        this.entryString = getEntryString(this.node);
    }
};
NavigationNodeComponent = __decorate([
    core.Component({
        selector: 'se-navigation-node',
        template: `<div class="pull-right dropdown tree-node se-tree-node__actions col-sm-1" [hidden]="isReadOnly"><se-dropdown-menu [dropdownItems]="dropdownItems" [selectedItem]="node" class="pull-right se-tree-node__actions--more-menu"></se-dropdown-menu></div><div class="se-tree-node__name col-xs-3" [title]="node.name | seL10n | async"><span>{{ node.name | seL10n | async }}</span></div><div class="pull-right tree-node se-tree-node__entry col-xs-5"><se-tooltip class="se-dropdown-item__delete-page-popover" [triggers]="['mouseenter', 'mouseleave']" [isChevronVisible]="true" [appendTo]="'body'"><span se-tooltip-trigger class="se-tree-node__popover"><span>{{ entryString }} </span></span><span se-tooltip-body>{{ entryString }}</span></se-tooltip></div><div class="se-tree-node__title col-xs-2"><span [hidden]="!node.title">{{ node.title | seL10n | async }}</span></div>`,
        styles: [`se-navigation-node .se-dropdown-item__delete-page-popover,se-navigation-node .se-dropdown-item__delete-page-popover .se-tooltip{max-width:100%}`],
        encapsulation: core.ViewEncapsulation.None,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(0, core.Inject(core.forwardRef(() => smarteditcommons.TreeComponent))),
    __param(1, core.Inject(smarteditcommons.TREE_NODE)),
    __metadata("design:paramtypes", [smarteditcommons.TreeComponent, Object])
], NavigationNodeComponent);

window.__smartedit__.addDecoratorPayload("Component", "NavigationEditorTreeComponent", {
    selector: 'se-navigation-editor-tree',
    template: `<div class="se-navigation-editor-tree__header" *ngIf="!readOnly"><button class="se-navigation-editor-tree__btn fd-button" (click)="actions.addTopLevelNode()"><span [translate]="'se.cms.navigationmanagement.add.top.level.node'" class="se-navigation-editor-tree__btn--text"></span></button></div><div class="se-navigation-editor-tree categoryTable"><div class="tablehead clearfix hidden-xs se-navigation-editor-tree__head"><div [translate]="'se.ytree.template.header.name'" class="se-navigation-editor-tree__name col-xs-3"></div><div [translate]="'se.ytree.template.header.title'" class="se-navigation-editor-tree__title col-xs-3"></div><div class="col-xs-1 pull-right"></div><div [translate]="'se.ytree.template.header.entry'" class="se-navigation-editor-tree__entry col-xs-5 pull-right"></div></div><se-tree [nodeUri]="nodeURI" [rootNodeUid]="rootNodeUid" [nodeComponent]="nodeComponent" [removeDefaultTemplate]="true" [nodeActions]="actions" [dragOptions]="dragOptions"></se-tree></div>`,
    styles: [`.se-navigation-editor-tree__header{height:55px;width:100%;border-radius:4px 4px 0 0;background-color:#fff;display:flex;align-items:center;justify-content:flex-end;padding-right:1rem}.se-navigation-editor-tree__name{padding-left:45px}.se-navigation-editor-tree__name.col-md-offset-1{margin-left:0}.se-navigation-editor-tree__title{padding-left:60px}.tablehead.se-navigation-editor-tree__head{border-top:1px solid #eeeeef;background-color:#fafafa;font-size:1rem;line-height:1.4285714286;font-weight:400;font-family:"72",web,"Open Sans",sans-serif;color:#6a6d70;height:40px;padding:10px 0}.fd-modal__body .se-navigation-editor-tree__entry,.modal-dialog .se-navigation-editor-tree__entry{width:155px;padding-left:55px}.fd-modal__body .se-navigation-editor-tree__name,.modal-dialog .se-navigation-editor-tree__name{width:200px}.fd-modal__body .se-navigation-editor-tree__head,.modal-dialog .se-navigation-editor-tree__head{margin:0 -20px 0 -20px;padding-left:20px;padding-right:20px}.se-navigation-editor-tree__btn{margin-right:1rem}`],
    providers: [NavigationEditorTreeDragOptions, NavigationEditorTreeActions],
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    encapsulation: core.ViewEncapsulation.None
});
let /* @ngInject */ NavigationEditorTreeComponent = class /* @ngInject */ NavigationEditorTreeComponent {
    constructor(dragOptionsService, actionsService) {
        this.dragOptionsService = dragOptionsService;
        this.actionsService = actionsService;
        this.nodeComponent = NavigationNodeComponent;
    }
    ngOnInit() {
        this.nodeURI = new smarteditcommons.URIBuilder(cmscommons.NAVIGATION_MANAGEMENT_RESOURCE_URI)
            .replaceParams(this.uriContext)
            .build();
        this.rootNodeUid = this.rootNodeUid || cmscommons.NAVIGATION_NODE_ROOT_NODE_UID;
        this.actionsService.setup(this.readOnly, this.rootNodeUid, this.uriContext);
        this.actions = this.actionsService.getActions();
        if (!this.readOnly) {
            this.dragOptionsService.setup((event) => {
                this.actions.dragAndDrop(event);
            });
            this.dragOptions = this.dragOptionsService.getDragOptions();
        }
    }
};
NavigationEditorTreeComponent.$inject = ["dragOptionsService", "actionsService"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ NavigationEditorTreeComponent.prototype, "uriContext", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], /* @ngInject */ NavigationEditorTreeComponent.prototype, "readOnly", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ NavigationEditorTreeComponent.prototype, "rootNodeUid", void 0);
/* @ngInject */ NavigationEditorTreeComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-navigation-editor-tree',
        template: `<div class="se-navigation-editor-tree__header" *ngIf="!readOnly"><button class="se-navigation-editor-tree__btn fd-button" (click)="actions.addTopLevelNode()"><span [translate]="'se.cms.navigationmanagement.add.top.level.node'" class="se-navigation-editor-tree__btn--text"></span></button></div><div class="se-navigation-editor-tree categoryTable"><div class="tablehead clearfix hidden-xs se-navigation-editor-tree__head"><div [translate]="'se.ytree.template.header.name'" class="se-navigation-editor-tree__name col-xs-3"></div><div [translate]="'se.ytree.template.header.title'" class="se-navigation-editor-tree__title col-xs-3"></div><div class="col-xs-1 pull-right"></div><div [translate]="'se.ytree.template.header.entry'" class="se-navigation-editor-tree__entry col-xs-5 pull-right"></div></div><se-tree [nodeUri]="nodeURI" [rootNodeUid]="rootNodeUid" [nodeComponent]="nodeComponent" [removeDefaultTemplate]="true" [nodeActions]="actions" [dragOptions]="dragOptions"></se-tree></div>`,
        styles: [`.se-navigation-editor-tree__header{height:55px;width:100%;border-radius:4px 4px 0 0;background-color:#fff;display:flex;align-items:center;justify-content:flex-end;padding-right:1rem}.se-navigation-editor-tree__name{padding-left:45px}.se-navigation-editor-tree__name.col-md-offset-1{margin-left:0}.se-navigation-editor-tree__title{padding-left:60px}.tablehead.se-navigation-editor-tree__head{border-top:1px solid #eeeeef;background-color:#fafafa;font-size:1rem;line-height:1.4285714286;font-weight:400;font-family:"72",web,"Open Sans",sans-serif;color:#6a6d70;height:40px;padding:10px 0}.fd-modal__body .se-navigation-editor-tree__entry,.modal-dialog .se-navigation-editor-tree__entry{width:155px;padding-left:55px}.fd-modal__body .se-navigation-editor-tree__name,.modal-dialog .se-navigation-editor-tree__name{width:200px}.fd-modal__body .se-navigation-editor-tree__head,.modal-dialog .se-navigation-editor-tree__head{margin:0 -20px 0 -20px;padding-left:20px;padding-right:20px}.se-navigation-editor-tree__btn{margin-right:1rem}`],
        providers: [NavigationEditorTreeDragOptions, NavigationEditorTreeActions],
        changeDetection: core.ChangeDetectionStrategy.OnPush,
        encapsulation: core.ViewEncapsulation.None
    }),
    __metadata("design:paramtypes", [NavigationEditorTreeDragOptions,
        NavigationEditorTreeActions])
], /* @ngInject */ NavigationEditorTreeComponent);

let NavigationModule = class NavigationModule {
};
NavigationModule = __decorate([
    core.NgModule({
        imports: [
            common.CommonModule,
            smarteditcommons.DropdownMenuModule,
            smarteditcommons.L10nPipeModule,
            smarteditcommons.TranslationModule.forChild(),
            smarteditcommons.NgTreeModule,
            smarteditcommons.TooltipModule,
            smarteditcontainer.ToolbarModule
        ],
        declarations: [
            NavigationEditorTreeComponent,
            NavigationNodeComponent,
            NavigationEditorLinkComponent,
            BreadcrumbComponent,
            NavigationNodePickerComponent,
            NavigationNodePickerRenderComponent,
            NavigationNodeSelectorComponent,
            NavigationManagementPageComponent
        ],
        entryComponents: [
            NavigationEditorTreeComponent,
            NavigationNodeComponent,
            NavigationEditorLinkComponent,
            BreadcrumbComponent,
            NavigationNodePickerComponent,
            NavigationNodePickerRenderComponent,
            NavigationNodeSelectorComponent
        ],
        exports: [NavigationEditorTreeComponent],
        providers: [NodeAncestryService, NavigationEditorNodeService, NavigationNodeEditorModalService]
    })
], NavigationModule);

var LinkToOption;
(function (LinkToOption) {
    LinkToOption["content"] = "content";
    LinkToOption["product"] = "product";
    LinkToOption["category"] = "category";
    LinkToOption["external"] = "external";
})(LinkToOption || (LinkToOption = {}));

const SelectOptions = [
    {
        id: LinkToOption.content,
        structureApiMode: 'CONTENT'
    },
    {
        id: LinkToOption.product,
        structureApiMode: 'PRODUCT',
        hasCatalog: true
    },
    {
        id: LinkToOption.category,
        structureApiMode: 'CATEGORY',
        hasCatalog: true
    },
    {
        id: LinkToOption.external,
        structureApiMode: 'EXTERNAL'
    }
];
window.__smartedit__.addDecoratorPayload("Component", "CmsLinkToSelectComponent", {
    selector: 'se-cms-link-to-select',
    template: `<se-generic-editor-dropdown [id]="id" [field]="field" [qualifier]="qualifier" [model]="optionModel"></se-generic-editor-dropdown>`,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let CmsLinkToSelectComponent = class CmsLinkToSelectComponent {
    constructor(cdr, systemEventService, data) {
        this.cdr = cdr;
        this.systemEventService = systemEventService;
        this.data = data;
        ({
            id: this.id,
            field: this.field,
            model: this.optionModel,
            qualifier: this.qualifier
        } = data);
    }
    ngOnInit() {
        const linkTo = this.getLinkToValue(this.optionModel);
        if (linkTo !== null) {
            this.optionModel.linkTo = linkTo;
        }
        this.data.editor.api.considerFormDirty();
        this.data.editor.api.setAlwaysEnableSubmit(true);
        const onSelectValueChangedEventName = `${this.id}${smarteditcommons.LINKED_DROPDOWN}`;
        this.unRegSelectValueChanged = this.systemEventService.subscribe(onSelectValueChangedEventName, (_eventId, data) => this.onLinkToSelectValueChanged(data));
    }
    ngOnDestroy() {
        this.unRegSelectValueChanged();
    }
    onLinkToSelectValueChanged({ optionObject: option, qualifier }) {
        if (this.qualifier !== qualifier) {
            return;
        }
        if (!option) {
            return;
        }
        const optionValue = option.id;
        const selectedOption = SelectOptions.find(({ id }) => id === optionValue);
        if (!selectedOption) {
            throw new Error('Selected option is not supported');
        }
        if (optionValue === this.optionModel.currentSelectedOptionValue) {
            return;
        }
        this.optionModel.currentSelectedOptionValue = optionValue;
        this.optionModel.external = optionValue !== LinkToOption.external;
        this.clearModel(selectedOption);
        this.systemEventService.publishAsync(CMS_LINK_TO_RELOAD_STRUCTURE_EVENT_ID, {
            content: this.optionModel,
            structureApiMode: selectedOption.structureApiMode,
            editorId: this.id
        });
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
    }
    getLinkToValue(model) {
        if (model.product) {
            return LinkToOption.product;
        }
        else if (model.contentPage) {
            return LinkToOption.content;
        }
        else if (model.category) {
            return LinkToOption.category;
        }
        else if (model.url || (model.linkToggle && model.linkToggle.urlLink) || model.urlLink) {
            return LinkToOption.external;
        }
        return null;
    }
    clearModel({ id, hasCatalog }) {
        if (id !== LinkToOption.category) {
            delete this.optionModel.category;
        }
        if (id !== LinkToOption.product) {
            delete this.optionModel.product;
        }
        if (!hasCatalog) {
            delete this.optionModel.productCatalog;
        }
        if (id !== LinkToOption.content) {
            delete this.optionModel.contentPage;
        }
        if (id !== LinkToOption.external) {
            delete this.optionModel.url;
            delete this.optionModel.urlLink;
            if (this.optionModel.linkToggle && this.optionModel.linkToggle.urlLink) {
                delete this.optionModel.linkToggle.urlLink;
            }
        }
    }
};
CmsLinkToSelectComponent = __decorate([
    core.Component({
        selector: 'se-cms-link-to-select',
        template: `<se-generic-editor-dropdown [id]="id" [field]="field" [qualifier]="qualifier" [model]="optionModel"></se-generic-editor-dropdown>`,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(2, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [core.ChangeDetectorRef,
        smarteditcommons.SystemEventService, Object])
], CmsLinkToSelectComponent);

window.__smartedit__.addDecoratorPayload("Component", "InfoPageNameComponent", {
    selector: 'se-info-page-name',
    template: `<div class="se-page-info__name"><se-homepage-icon *ngIf="field.qualifier === 'name'" [cmsPage]="cmsPage" [uriContext]="uriContext"></se-homepage-icon><div id="{{ field.qualifier }}-homepage" class="se-page-info__name-value fd-form-control" [title]="field.qualifier">{{ model[qualifier] }}</div></div>`,
    styles: [`.se-page-info__name{display:flex;flex-direction:row;align-items:center}.se-page-info__name-value{word-break:break-all;white-space:normal}`]
});
let /* @ngInject */ InfoPageNameComponent = class /* @ngInject */ InfoPageNameComponent {
    constructor(catalogService, pageService, data) {
        this.catalogService = catalogService;
        this.pageService = pageService;
        ({ model: this.model, field: this.field, qualifier: this.qualifier } = data);
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const [uriContext, cmsPage] = yield Promise.all([
                this.catalogService.retrieveUriContext(),
                this.pageService.getCurrentPageInfo()
            ]);
            this.uriContext = uriContext;
            this.cmsPage = cmsPage;
        });
    }
};
InfoPageNameComponent.$inject = ["catalogService", "pageService", "data"];
/* @ngInject */ InfoPageNameComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-info-page-name',
        template: `<div class="se-page-info__name"><se-homepage-icon *ngIf="field.qualifier === 'name'" [cmsPage]="cmsPage" [uriContext]="uriContext"></se-homepage-icon><div id="{{ field.qualifier }}-homepage" class="se-page-info__name-value fd-form-control" [title]="field.qualifier">{{ model[qualifier] }}</div></div>`,
        styles: [`.se-page-info__name{display:flex;flex-direction:row;align-items:center}.se-page-info__name-value{word-break:break-all;white-space:normal}`]
    }),
    __param(2, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [smarteditcommons.ICatalogService,
        smarteditcommons.IPageService, Object])
], /* @ngInject */ InfoPageNameComponent);

window.__smartedit__.addDecoratorPayload("Component", "LinkToggleComponent", {
    selector: 'se-link-toggle',
    template: `<div class="se-link-toggle"><div class="se-link-toggle__row"><div class="se-form-control-row se-form-control-row--action"><label class="se-control-label se-link-toggle__label" for="external-link"><input class="fd-form__control se-link-toggle__input" id="external-link" name="linktoggle" type="radio" [(ngModel)]="model.linkToggle.external" (ngModelChange)="clearUrlLink()" [value]="true"/> {{ 'se.editor.linkto.external.label' | translate}}</label></div><div class="se-form-control-row se-form-control-row--action"><label class="se-control-label se-link-toggle__label" for="internal-link"><input class="fd-form__control se-link-toggle__input" id="internal-link" name="linktoggle" type="radio" [(ngModel)]="model.linkToggle.external" (ngModelChange)="clearUrlLink()" [value]="false"/> {{ 'se.editor.linkto.internal.label' | translate}}</label></div></div><input class="fd-form-control" id="urlLink" name="urlLink" type="text" [(ngModel)]="model.linkToggle.urlLink" (ngModelChange)="checkUrlLink()" [ngClass]="{ 'has-error': field.hasErrors }"/></div>`,
    styles: [`.se-link-toggle__row{display:flex;flex-direction:row;align-items:center}.se-form-control-row{margin-right:16px}.se-control-label.se-link-toggle__label{display:flex;flex-direction:row;align-items:center;margin:0}.fd-form__control.se-link-toggle__input{margin:0 4px 0 0}`]
});
let LinkToggleComponent = class LinkToggleComponent {
    constructor(data) {
        ({ field: this.field, model: this.model } = data);
        if (!this.model.linkToggle) {
            this.model.linkToggle = {};
        }
        if (this.model.linkToggle.external === undefined) {
            this.model.linkToggle.external = true;
        }
    }
    clearUrlLink() {
        this.model.linkToggle.urlLink = null;
    }
    checkUrlLink() {
        if (this.model.linkToggle.urlLink === '') {
            this.model.linkToggle.urlLink = null;
        }
    }
};
LinkToggleComponent = __decorate([
    core.Component({
        selector: 'se-link-toggle',
        template: `<div class="se-link-toggle"><div class="se-link-toggle__row"><div class="se-form-control-row se-form-control-row--action"><label class="se-control-label se-link-toggle__label" for="external-link"><input class="fd-form__control se-link-toggle__input" id="external-link" name="linktoggle" type="radio" [(ngModel)]="model.linkToggle.external" (ngModelChange)="clearUrlLink()" [value]="true"/> {{ 'se.editor.linkto.external.label' | translate}}</label></div><div class="se-form-control-row se-form-control-row--action"><label class="se-control-label se-link-toggle__label" for="internal-link"><input class="fd-form__control se-link-toggle__input" id="internal-link" name="linktoggle" type="radio" [(ngModel)]="model.linkToggle.external" (ngModelChange)="clearUrlLink()" [value]="false"/> {{ 'se.editor.linkto.internal.label' | translate}}</label></div></div><input class="fd-form-control" id="urlLink" name="urlLink" type="text" [(ngModel)]="model.linkToggle.urlLink" (ngModelChange)="checkUrlLink()" [ngClass]="{ 'has-error': field.hasErrors }"/></div>`,
        styles: [`.se-link-toggle__row{display:flex;flex-direction:row;align-items:center}.se-form-control-row{margin-right:16px}.se-control-label.se-link-toggle__label{display:flex;flex-direction:row;align-items:center;margin:0}.fd-form__control.se-link-toggle__input{margin:0 4px 0 0}`]
    }),
    __param(0, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [Object])
], LinkToggleComponent);

var MediaActionLabelState;
(function (MediaActionLabelState) {
    MediaActionLabelState["disabled"] = "disabled";
})(MediaActionLabelState || (MediaActionLabelState = {}));
window.__smartedit__.addDecoratorPayload("Component", "MediaActionLabelComponent", {
    selector: 'se-media-action-label',
    template: `<span class="se-media-action-label" [ngClass]="{ 'se-media-action-label--disabled': state === 'disabled' }" [translate]="i18nKey"></span>`,
    styles: [`.se-media-action-label{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;color:#0a6ed1}.se-media-action-label--disabled{color:#6a6d70}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ MediaActionLabelComponent = class /* @ngInject */ MediaActionLabelComponent {
};
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaActionLabelComponent.prototype, "i18nKey", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaActionLabelComponent.prototype, "state", void 0);
/* @ngInject */ MediaActionLabelComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-media-action-label',
        template: `<span class="se-media-action-label" [ngClass]="{ 'se-media-action-label--disabled': state === 'disabled' }" [translate]="i18nKey"></span>`,
        styles: [`.se-media-action-label{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;color:#0a6ed1}.se-media-action-label--disabled{color:#6a6d70}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    })
], /* @ngInject */ MediaActionLabelComponent);

/**
 * This service provides functionality to upload images and to fetch images by code for a specific catalog-catalog version combination.
 */
let /* @ngInject */ MediaUploaderService = class /* @ngInject */ MediaUploaderService {
    constructor(restServiceFactory) {
        this.restServiceFactory = restServiceFactory;
        this.mediaRestService = this.restServiceFactory.get(smarteditcommons.MEDIA_RESOURCE_URI);
    }
    /**
     * Uploads the media to the catalog.
     *
     * @returns Promise that resolves with the media object if request is successful.
     * If the request fails, it resolves with errors from the backend.
     */
    uploadMedia(media) {
        var _a;
        const formData = new FormData();
        lodash.forEach(media, (value, key) => {
            formData.append(key, value);
        });
        return this.mediaRestService.save(formData, {
            headers: { enctype: 'multipart/form-data', fileSize: '' + ((_a = media === null || media === void 0 ? void 0 : media.file) === null || _a === void 0 ? void 0 : _a.size) }
        });
    }
};
MediaUploaderService.$inject = ["restServiceFactory"];
/* @ngInject */ MediaUploaderService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.RestServiceFactory])
], /* @ngInject */ MediaUploaderService);

/** Service to deal with media related CRUD operations. */
let /* @ngInject */ MediaService = class /* @ngInject */ MediaService {
    constructor(restServiceFactory) {
        this.restServiceFactory = restServiceFactory;
    }
    /**
     * Fetches paged search results by making a REST call to the appropriate item endpoint.
     *
     * @param mask for filtering the search.
     * @param pageSize number of items in the page.
     * @param currentPage current page number.
     */
    getPage(mask, pageSize, currentPage, mimeType) {
        return __awaiter(this, void 0, void 0, function* () {
            const contextParams = {
                catalogId: smarteditcommons.CONTEXT_CATALOG,
                catalogVersion: smarteditcommons.CONTEXT_CATALOG_VERSION
            };
            const subParams = this.contextParamsToCommaSeparated(contextParams);
            const payload = {
                mask,
                params: subParams,
                pageSize,
                currentPage,
                mimeType
            };
            const response = yield this.restServiceFactory.get(smarteditcommons.MEDIAS_PATH).get(payload);
            const page = {
                results: [],
                pagination: response.pagination
            };
            page.results = response.media.map((media) => this.mediaDTOtoMedia(media));
            return page;
        });
    }
    /**
     * This method fetches a Media by its UUID.
     * @param uuid uuid of a media (contains catalog information).
     */
    getMedia(uuid) {
        return __awaiter(this, void 0, void 0, function* () {
            // identifier is added to URI and not getByid argument because it contains slashes
            const url = `${smarteditcommons.MEDIA_PATH}/${uuid}`;
            const media = yield this.restServiceFactory.get(url).get();
            return this.mediaDTOtoMedia(media);
        });
    }
    /**
     * Returns comma separated params that will be attached to payload.
     *
     * E.g. "catalogId:CURRENT_CONTEXT_CATALOG,catalogVersion:CURRENT_CONTEXT_CATALOG_VERSION"
     */
    contextParamsToCommaSeparated(params) {
        return Object.keys(params)
            .reduce((accumulator, next) => {
            accumulator += `,${next}:${params[next]}`;
            return accumulator;
        }, '')
            .substring(1);
    }
    mediaDTOtoMedia({ uuid, code, description, altText, url, downloadUrl, mime }) {
        return {
            id: uuid,
            code,
            description,
            altText,
            url,
            downloadUrl,
            mime
        };
    }
};
MediaService.$inject = ["restServiceFactory"];
/* @ngInject */ MediaService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.RestServiceFactory])
], /* @ngInject */ MediaService);

/**
 * Service used to handle standard OCC validation errors received from the backend.
 */
let /* @ngInject */ MediaBackendValidationHandler = class /* @ngInject */ MediaBackendValidationHandler {
    /**
     * Extracts validation errors from the provided response and appends them to a specified contextual errors list.
     *
     * The expected error response from the backend matches the contract of the following response example:
     *
     * ```
     *      var response = {
     *          data: {
     *              errors: [{
     *                  type: 'ValidationError',
     *                  subject: 'mySubject',
     *                  message: 'Some validation exception occurred'
     *              }, {
     *                  type: 'SomeOtherError',
     *                  subject: 'mySubject'
     *                  message: 'Some other exception occurred'
     *              }]
     *          }
     *      }
     * ```
     * or just matched the backend error for media folder
     *      var response = {
     *          data: {
     *              errors: [{
     *                  type: 'UnknownIdentifierError',
     *                  message: 'No media folder with qualifier xxx can be found.'
     *              }, {
     *                  type: 'AmbiguousIdentifierException',
     *                  message: 'More than one media folder with qualifier xxx found.'
     *              }]
     *          }
     *      }
     *
     * Example of use:
     * ```
     *      const errorsContext = [];
     *      mediaBackendValidationHandler.handleResponse(response, errorsContext);
     * ```
     *
     * The resulting errorsContext would be as follows:
     * ```
     *      [{
     *          subject: 'mySubject',
     *          message: 'Some validation exception occurred'
     *      }]
     * ```
     *
     * @param response A response consisting of a list of errors. For details of the expected format, see the example above.
     * @param errorsContext An array that all validation errors are appended to. It is an output parameter.
     * @returns The error context list originally provided, or a new list, appended with the validation errors.
     */
    handleResponse(response, errorsContext) {
        var _a;
        errorsContext = errorsContext || [];
        if ((_a = response === null || response === void 0 ? void 0 : response.error) === null || _a === void 0 ? void 0 : _a.errors) {
            response.error.errors
                .filter((error) => this.isValidationError(error))
                .forEach(({ subject, message }) => {
                if (subject) {
                    errorsContext.push({
                        subject,
                        message
                    });
                }
            });
            response.error.errors
                .filter((error) => this.isMediaFolderError(error))
                .forEach(({ type, message }) => {
                errorsContext.push({
                    subject: 'folder',
                    message
                });
            });
            response.error.errors
                .filter((error) => this.isUploadSizeError(error))
                .forEach(() => {
                errorsContext.push({
                    subject: 'code',
                    message: 'se.max.upload.size.exceeded.error'
                });
            });
        }
        return errorsContext;
    }
    isValidationError(error) {
        return error.type === 'ValidationError';
    }
    isUploadSizeError(error) {
        return error.type === 'MaxUploadSizeExceededError';
    }
    isMediaFolderError(error) {
        return (error.type === 'UnknownIdentifierError' || error.type === 'AmbiguousIdentifierException');
    }
};
/* @ngInject */ MediaBackendValidationHandler = __decorate([
    smarteditcommons.SeDowngradeService()
], /* @ngInject */ MediaBackendValidationHandler);

/**
 * The MediaFolderService is used to access media folders which been created in backoffice
 */
let /* @ngInject */ MediaFolderService = class /* @ngInject */ MediaFolderService {
    constructor(restServiceFactory, settingsService) {
        this.restServiceFactory = restServiceFactory;
        this.settingsService = settingsService;
        this.mediaFolderListService = this.restServiceFactory.get(smarteditcommons.MEDIA_FOLDER_PATH);
        this._mediaFolderFetchStrategy = {
            fetchPage: (mask, pageSize, currentPage) => __awaiter(this, void 0, void 0, function* () { return this.mediaFoldersFetchPage(mask, pageSize, currentPage); }),
            fetchEntity: (id) => __awaiter(this, void 0, void 0, function* () { return Promise.resolve({ id, name: id, qualifier: id }); })
        };
    }
    /**
     * Strategy necessary to display media folder in a paged way.
     * It contains a method to retrieve pages of media folder.
     * Such strategy is necessary to work with media folder in SelectComponent.
     */
    get mediaFoldersFetchStrategy() {
        return this._mediaFolderFetchStrategy;
    }
    getDefaultFolder() {
        return __awaiter(this, void 0, void 0, function* () {
            const { error: getFolderError, data: defaultFolder } = yield smarteditcommons.promiseUtils.attempt(this.settingsService.get('smartedit.mediaUploadDefaultFolder'));
            if (getFolderError) {
                return Promise.resolve('');
            }
            return defaultFolder;
        });
    }
    /**
     * Returns a list of media folders that match the given mask
     */
    getMediaFolders(pageable) {
        return __awaiter(this, void 0, void 0, function* () {
            const list = yield this.mediaFolderListService.get({
                mask: pageable.mask,
                pageSize: pageable.pageSize,
                currentPage: pageable.currentPage
            });
            return list;
        });
    }
    mediaFoldersFetchPage(mask, pageSize, currentPage) {
        return __awaiter(this, void 0, void 0, function* () {
            const { mediaFolders, pagination } = yield this.getMediaFolders({
                mask,
                pageSize,
                currentPage
            });
            const items = mediaFolders.map((folder) => (Object.assign(Object.assign({}, folder), { id: folder.qualifier, name: folder.qualifier })));
            return {
                pagination,
                results: items
            };
        });
    }
};
MediaFolderService.$inject = ["restServiceFactory", "settingsService"];
__decorate([
    smarteditcommons.Cached({
        actions: [smarteditcommons.frequentlyChangingContent],
        tags: [smarteditcommons.userEvictionTag, smarteditcommons.perspectiveChangedEvictionTag, smarteditcommons.pageChangeEvictionTag]
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], /* @ngInject */ MediaFolderService.prototype, "getMediaFolders", null);
/* @ngInject */ MediaFolderService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.RestServiceFactory,
        smarteditcommons.ISettingsService])
], /* @ngInject */ MediaFolderService);

/**
 * This service provides functionality for Media Util.
 */
let /* @ngInject */ MediaUtilService = class /* @ngInject */ MediaUtilService {
    /**
     * Limitation the specified file format against custom field and its allowMediaType.
     *
     * @param fieldAllowMediaType The file format to be validated.
     * @returns string[] list of accepted file types.
     */
    getAcceptedFileTypes(fieldAllowMediaType) {
        const allowMediaType = fieldAllowMediaType || smarteditcommons.GenericEditorMediaType.DEFAULT;
        switch (allowMediaType) {
            case smarteditcommons.GenericEditorMediaType.IMAGE:
                return smarteditcommons.FILE_VALIDATION_CONFIG.ACCEPTED_FILE_TYPES.IMAGE;
            case smarteditcommons.GenericEditorMediaType.VIDEO:
                return smarteditcommons.FILE_VALIDATION_CONFIG.ACCEPTED_FILE_TYPES.VIDEO;
            case smarteditcommons.GenericEditorMediaType.PDF_DOCUMENT:
                return smarteditcommons.FILE_VALIDATION_CONFIG.ACCEPTED_FILE_TYPES.PDF_DOCUMENT;
            default:
                return smarteditcommons.FILE_VALIDATION_CONFIG.ACCEPTED_FILE_TYPES.DEFAULT;
        }
    }
};
/* @ngInject */ MediaUtilService = __decorate([
    smarteditcommons.SeDowngradeService()
], /* @ngInject */ MediaUtilService);

const VIDEO_MIME_PREFIX = 'video';
const MP4_MIME_PREFIX = 'mp4';
window.__smartedit__.addDecoratorPayload("Component", "MediaComponent", {
    selector: 'se-media',
    template: `<div class="se-media"><se-media-selector *ngIf="!image" [id]="mediaSelectorId" [isDisabled]="isFieldDisabled" [mediaId]="mediaIdByLang[lang]" [mimeType]="field.allowMediaType" (mediaIdChange)="onMediaIdChange($event)"></se-media-selector><se-media-file-selector *ngIf="canShowFileSelector()" [labelI18nKey]="'se.upload.image.to.library'" [acceptedFileTypes]="acceptedFileTypes" [selectionMode]="'upload'" [disabled]="isFieldDisabled" (onFileSelect)="onFileSelect($event)"></se-media-file-selector><se-media-upload-form *ngIf="image" class="se-media-upload-form-wrapper" [image]="image" [allowMediaType]="field.allowMediaType" [maxUploadFileSize]="maxUploadFileSize" (onCancel)="resetImage()" (onSelect)="onFileSelect($event)" (onUploadSuccess)="onMediaUploaded($event)"></se-media-upload-form><se-message *ngIf="previewMessage" [type]="'warning'"><ng-container se-message-description>{{ 'se.upload.video.cant.preview' | translate }}</ng-container></se-message><se-media-errors *ngIf="fileErrors.length > 0" [errors]="fileErrors" [maxUploadFileSize]="maxUploadFileSize"></se-media-errors></div>`,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let MediaComponent = class MediaComponent {
    constructor(cdr, fileValidationService, logService, mediaUtilService, mediaService, sharedDataService, data) {
        this.cdr = cdr;
        this.fileValidationService = fileValidationService;
        this.logService = logService;
        this.mediaUtilService = mediaUtilService;
        this.mediaService = mediaService;
        this.sharedDataService = sharedDataService;
        this.previewMessage = false;
        ({ field: this.field, model: this.mediaIdByLang, qualifier: this.lang } = data);
        this.acceptedFileTypes = this.mediaUtilService.getAcceptedFileTypes(this.field.allowMediaType);
        this.fileErrors = [];
        this.image = null;
        this.isFieldDisabled = data.isFieldDisabled();
        this.mediaSelectorId = this.field.qualifier;
        this.field.allowMediaType = this.field.allowMediaType || smarteditcommons.GenericEditorMediaType.DEFAULT;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.mediaIdByLang[this.lang]) {
                yield this.checkMediaPreview(this.mediaIdByLang[this.lang]);
            }
            const maxUploadFileSizeConfiguration = yield this.sharedDataService.get(MAX_UPLOAD_FILE_SIZE);
            this.maxUploadFileSize =
                maxUploadFileSizeConfiguration && typeof maxUploadFileSizeConfiguration === 'number'
                    ? maxUploadFileSizeConfiguration
                    : smarteditcommons.FILE_VALIDATION_CONFIG.DEFAULT_MAX_UPLOAD_FILE_SIZE;
        });
    }
    onMediaIdChange(id) {
        return __awaiter(this, void 0, void 0, function* () {
            this.fileErrors = [];
            this.previewMessage = false;
            this.mediaIdByLang[this.lang] = id;
            if (id) {
                yield this.checkMediaPreview(id);
            }
        });
    }
    onFileSelect(fileList) {
        return __awaiter(this, void 0, void 0, function* () {
            this.mediaIdByLang[this.lang] = undefined;
            this.resetImage();
            const file = fileList[0];
            try {
                yield this.fileValidationService.validate(file, this.maxUploadFileSize, this.fileErrors);
                this.image = file;
            }
            catch (_a) {
                this.logService.warn('Invalid file');
            }
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    onMediaUploaded(id) {
        return __awaiter(this, void 0, void 0, function* () {
            this.resetImage();
            yield this.onMediaIdChange(id);
            if (this.field.initiated) {
                this.field.initiated.length = 0;
            }
        });
    }
    resetImage() {
        this.fileErrors = [];
        this.image = null;
    }
    canShowFileSelector() {
        return this.mediaIdByLang && !this.mediaIdByLang[this.lang] && !this.image;
    }
    canVideoPreview(mime) {
        if (mime && mime.includes(VIDEO_MIME_PREFIX) && mime.indexOf(MP4_MIME_PREFIX) === -1) {
            this.previewMessage = true;
        }
    }
    checkMediaPreview(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const media = yield this.mediaService.getMedia(id);
            this.canVideoPreview(media === null || media === void 0 ? void 0 : media.mime);
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
};
MediaComponent = __decorate([
    core.Component({
        selector: 'se-media',
        template: `<div class="se-media"><se-media-selector *ngIf="!image" [id]="mediaSelectorId" [isDisabled]="isFieldDisabled" [mediaId]="mediaIdByLang[lang]" [mimeType]="field.allowMediaType" (mediaIdChange)="onMediaIdChange($event)"></se-media-selector><se-media-file-selector *ngIf="canShowFileSelector()" [labelI18nKey]="'se.upload.image.to.library'" [acceptedFileTypes]="acceptedFileTypes" [selectionMode]="'upload'" [disabled]="isFieldDisabled" (onFileSelect)="onFileSelect($event)"></se-media-file-selector><se-media-upload-form *ngIf="image" class="se-media-upload-form-wrapper" [image]="image" [allowMediaType]="field.allowMediaType" [maxUploadFileSize]="maxUploadFileSize" (onCancel)="resetImage()" (onSelect)="onFileSelect($event)" (onUploadSuccess)="onMediaUploaded($event)"></se-media-upload-form><se-message *ngIf="previewMessage" [type]="'warning'"><ng-container se-message-description>{{ 'se.upload.video.cant.preview' | translate }}</ng-container></se-message><se-media-errors *ngIf="fileErrors.length > 0" [errors]="fileErrors" [maxUploadFileSize]="maxUploadFileSize"></se-media-errors></div>`,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(6, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [core.ChangeDetectorRef,
        smarteditcommons.IFileValidation,
        smarteditcommons.LogService,
        MediaUtilService,
        MediaService,
        smarteditcommons.ISharedDataService, Object])
], MediaComponent);

const MediaContainerClonePrefix = 'clone_';
var MediaFormatType;
(function (MediaFormatType) {
    MediaFormatType["widescreen"] = "widescreen";
    MediaFormatType["desktop"] = "desktop";
    MediaFormatType["tablet"] = "tablet";
    MediaFormatType["mobile"] = "mobile";
})(MediaFormatType || (MediaFormatType = {}));
window.__smartedit__.addDecoratorPayload("Component", "MediaContainerComponent", {
    selector: 'se-media-container',
    template: `<div *ngIf="hasReadPermissionOnMediaRelatedTypes && advancedMediaContainerManagementEnabled"><se-media-container-selector [eventNameAffix]="selectorEventNameAffix" [isAdvancedCloning]="isAdvancedCloning()" [initialName]="initialMediaContainerName" [name]="getMediaContainerName()" [isEditable]="field.editable" (nameChange)="onMediaContainerNameChange($event)" (onCreate)="onMediaContainerCreate($event)" (onRemove)="onMediaContainerRemove()" (onSelect)="setMediaContainer($event)" (onCreationInProgressChange)="onMediaContainerCreationInProgressChange($event)"></se-media-container-selector></div><div class="se-media-container-field" *ngIf="canShowMediaFormatWithUploadForm()"><div class="se-media-container-field__media-list"><se-media-format class="se-media-container-cell" *ngFor="let format of field.options" [ngClass]="getMediaContainerCellClassName(format.id)" [errorMessages]="field.messages" [isEditable]="field.editable" [isUnderEdit]="isMediaFormatUnderEdit(format.id)" [isFieldDisabled]="isFieldDisabled()" [mediaUuid]="model[lang]?.medias[format.id]" [mediaFormat]="format.id" [mediaLabel]="format.label" [allowMediaType]="field.allowMediaType" (onFileSelect)="onFileSelect($event, format.id)" (onDelete)="removeMediaByFormat(format.id)"></se-media-format></div><se-media-upload-form *ngIf="image" class="se-media-upload-form-wrapper se-media-upload-form-wrapper--spaced" [image]="image.file" [allowMediaType]="field.allowMediaType" [maxUploadFileSize]="maxUploadFileSize" (onCancel)="resetImage()" (onSelect)="onFileSelect($event)" (onUploadSuccess)="onFileUploadSuccess($event, image.format)"></se-media-upload-form><se-media-errors [errors]="fileValidationErrors" [maxUploadFileSize]="maxUploadFileSize"></se-media-errors></div><div *ngIf="!hasReadPermissionOnMediaRelatedTypes"><span translate="se.cms.media.typepermissions.error" [translateParams]="{ containedTypes: field.containedTypes }"></span></div>`
});
let /* @ngInject */ MediaContainerComponent = class /* @ngInject */ MediaContainerComponent {
    constructor(systemEventService, logService, typePermissionsRestService, loadConfigManagerService, fileValidationService, sharedDataService, data) {
        this.systemEventService = systemEventService;
        this.logService = logService;
        this.typePermissionsRestService = typePermissionsRestService;
        this.loadConfigManagerService = loadConfigManagerService;
        this.fileValidationService = fileValidationService;
        this.sharedDataService = sharedDataService;
        this.sessionStorage = window.sessionStorage;
        ({
            field: this.field,
            model: this.model,
            editor: this.editor,
            qualifier: this.lang,
            isFieldDisabled: this.isFieldDisabled
        } = data);
        this.selectorEventNameAffix = `${this.field.qualifier}_${this.lang}`;
        if (this.field.dependsOnField) {
            this.field.hideFieldWidget = true;
            const onDependsOnValueChangedEventName = `${this.editor.id}${this.field.dependsOnField}${smarteditcommons.CLICK_DROPDOWN}`;
            this.unRegDependsOnValueChanged = this.systemEventService.subscribe(onDependsOnValueChangedEventName, (_eventId, value) => this.onDependsOnValueChanged(value));
        }
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.model[this.lang]) {
                this.setMediaContainer({
                    catalogVersion: undefined,
                    medias: {},
                    qualifier: undefined,
                    mediaContainerUuid: undefined
                });
            }
            const maxUploadFileSizeConfiguration = yield this.sharedDataService.get(MAX_UPLOAD_FILE_SIZE);
            this.maxUploadFileSize =
                maxUploadFileSizeConfiguration && typeof maxUploadFileSizeConfiguration === 'number'
                    ? maxUploadFileSizeConfiguration
                    : smarteditcommons.FILE_VALIDATION_CONFIG.DEFAULT_MAX_UPLOAD_FILE_SIZE;
            yield this.initHasReadPermissionOnMediaRelatedTypes();
            yield this.initAdvancedMediaContainerManagementEnabled();
            this.initialMediaContainerNameKey = `${this.editor.id}_InitialMediaContainerName_${this.lang}`;
            this.resetModelForClone();
            this.getInitialMediaContainerName();
        });
    }
    getMediaContainerName() {
        var _a;
        return ((_a = this.model[this.lang]) === null || _a === void 0 ? void 0 : _a.qualifier) || '';
    }
    getInitialMediaContainerName() {
        var _a, _b;
        if (!!this.editor.initialContent.cloneComponent) {
            const initialCloneMediaContainerName = this.sessionStorage.getItem(this.initialMediaContainerNameKey);
            this.initialMediaContainerName =
                initialCloneMediaContainerName || ((_a = this.model[this.lang]) === null || _a === void 0 ? void 0 : _a.qualifier) || '';
        }
        else {
            this.initialMediaContainerName = ((_b = this.model[this.lang]) === null || _b === void 0 ? void 0 : _b.qualifier) || '';
        }
    }
    getMediaContainerCellClassName(format) {
        return `se-media-container-cell--${format}`;
    }
    setMediaContainer(mediaContainer) {
        this.model[this.lang] = mediaContainer;
    }
    canShowMediaFormatWithUploadForm() {
        return (this.hasReadPermissionOnMediaRelatedTypes &&
            (this.isMediaContainerSelected() ||
                this.mediaContainerCreationInProgress ||
                !this.advancedMediaContainerManagementEnabled));
    }
    isMediaFormatUnderEdit(format) {
        var _a;
        return format === ((_a = this.image) === null || _a === void 0 ? void 0 : _a.format);
    }
    onFileSelect(files, format) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const imageFormat = format || ((_a = this.image) === null || _a === void 0 ? void 0 : _a.format);
            this.resetImage();
            try {
                const file = files[0];
                yield this.fileValidationService.validate(file, this.maxUploadFileSize, this.fileValidationErrors);
                this.image = {
                    file,
                    format: imageFormat
                };
            }
            catch (_b) {
                this.logService.warn('Invalid file');
            }
        });
    }
    onFileUploadSuccess(uuid, format) {
        this.setMediaUuidForFormat(uuid, format);
        this.resetErrors();
        this.resetImage();
    }
    resetErrors() {
        if (this.field.hasErrors) {
            this.field.hasErrors = false;
            this.field.messages = [];
            const controls = this.editor.form.group.controls;
            for (const tabName of Object.keys(controls)) {
                controls[tabName].updateValueAndValidity();
            }
        }
    }
    onMediaContainerCreate(name) {
        this.clearModel();
        this.onMediaContainerNameChange(name);
        this.model[this.lang].medias = {};
    }
    onMediaContainerRemove() {
        this.clearModel();
    }
    onMediaContainerNameChange(name) {
        this.model[this.lang].qualifier = name;
    }
    onMediaContainerCreationInProgressChange(inProgress) {
        this.mediaContainerCreationInProgress = inProgress;
    }
    removeMediaByFormat(format) {
        delete this.model[this.lang].medias[format];
    }
    isAdvancedCloning() {
        return !!this.editor.initialContent.cloneComponent;
    }
    onDependsOnValueChanged(value) {
        this.field.hideFieldWidget = value !== this.field.dependsOnValue;
        if (this.field.hideFieldWidget) {
            if (this.model[this.lang]) {
                this.setMediaContainer({
                    catalogVersion: undefined,
                    medias: {},
                    qualifier: undefined,
                    mediaContainerUuid: undefined
                });
            }
            const clearSelectMediaContainerEventName = `mediaContainer_${this.selectorEventNameAffix}_${CMS_CLEAR_MEDIA_CONTAINER_SELECTED_OPTION}`;
            this.systemEventService.publishAsync(clearSelectMediaContainerEventName);
        }
    }
    initAdvancedMediaContainerManagementEnabled() {
        return __awaiter(this, void 0, void 0, function* () {
            const configurations = yield this.loadConfigManagerService.loadAsObject();
            this.advancedMediaContainerManagementEnabled =
                configurations.advancedMediaContainerManagement || false;
        });
    }
    initHasReadPermissionOnMediaRelatedTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const permissionsResult = yield this.typePermissionsRestService.hasAllPermissionsForTypes(this.field.containedTypes);
                this.hasReadPermissionOnMediaRelatedTypes = this.field.containedTypes.every((type) => permissionsResult[type].read);
            }
            catch (error) {
                this.hasReadPermissionOnMediaRelatedTypes = false;
                this.logService.warn('Failed to retrieve type permissions', error);
            }
        });
    }
    setMediaUuidForFormat(uuid, format) {
        this.model[this.lang].medias[format] = uuid;
    }
    isMediaContainerSelected() {
        return !lodash.isEmpty(this.model[this.lang]);
    }
    resetImage() {
        this.fileValidationErrors = [];
        this.image = null;
    }
    clearModel() {
        Object.keys(this.model[this.lang]).forEach((key) => delete this.model[this.lang][key]);
    }
    resetModelForClone() {
        if (!!this.editor.initialContent.cloneComponent) {
            if (this.model[this.lang] &&
                this.model[this.lang].mediaContainerUuid &&
                this.model[this.lang].qualifier) {
                this.sessionStorage.setItem(this.initialMediaContainerNameKey, this.model[this.lang].qualifier);
                const cloneMediaName = `${MediaContainerClonePrefix}${this.model[this.lang].qualifier.trim()}_${Date.now().toString().substr(7, 10)}`;
                this.onMediaContainerNameChange(cloneMediaName);
                delete this.model[this.lang].mediaContainerUuid;
                delete this.model[this.lang].catalogVersion;
            }
        }
    }
};
MediaContainerComponent.$inject = ["systemEventService", "logService", "typePermissionsRestService", "loadConfigManagerService", "fileValidationService", "sharedDataService", "data"];
/* @ngInject */ MediaContainerComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-media-container',
        template: `<div *ngIf="hasReadPermissionOnMediaRelatedTypes && advancedMediaContainerManagementEnabled"><se-media-container-selector [eventNameAffix]="selectorEventNameAffix" [isAdvancedCloning]="isAdvancedCloning()" [initialName]="initialMediaContainerName" [name]="getMediaContainerName()" [isEditable]="field.editable" (nameChange)="onMediaContainerNameChange($event)" (onCreate)="onMediaContainerCreate($event)" (onRemove)="onMediaContainerRemove()" (onSelect)="setMediaContainer($event)" (onCreationInProgressChange)="onMediaContainerCreationInProgressChange($event)"></se-media-container-selector></div><div class="se-media-container-field" *ngIf="canShowMediaFormatWithUploadForm()"><div class="se-media-container-field__media-list"><se-media-format class="se-media-container-cell" *ngFor="let format of field.options" [ngClass]="getMediaContainerCellClassName(format.id)" [errorMessages]="field.messages" [isEditable]="field.editable" [isUnderEdit]="isMediaFormatUnderEdit(format.id)" [isFieldDisabled]="isFieldDisabled()" [mediaUuid]="model[lang]?.medias[format.id]" [mediaFormat]="format.id" [mediaLabel]="format.label" [allowMediaType]="field.allowMediaType" (onFileSelect)="onFileSelect($event, format.id)" (onDelete)="removeMediaByFormat(format.id)"></se-media-format></div><se-media-upload-form *ngIf="image" class="se-media-upload-form-wrapper se-media-upload-form-wrapper--spaced" [image]="image.file" [allowMediaType]="field.allowMediaType" [maxUploadFileSize]="maxUploadFileSize" (onCancel)="resetImage()" (onSelect)="onFileSelect($event)" (onUploadSuccess)="onFileUploadSuccess($event, image.format)"></se-media-upload-form><se-media-errors [errors]="fileValidationErrors" [maxUploadFileSize]="maxUploadFileSize"></se-media-errors></div><div *ngIf="!hasReadPermissionOnMediaRelatedTypes"><span translate="se.cms.media.typepermissions.error" [translateParams]="{ containedTypes: field.containedTypes }"></span></div>`
    }),
    __param(6, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [smarteditcommons.SystemEventService,
        smarteditcommons.LogService,
        cmscommons.TypePermissionsRestService,
        smarteditcontainer.LoadConfigManagerService,
        smarteditcommons.IFileValidation,
        smarteditcommons.ISharedDataService, Object])
], /* @ngInject */ MediaContainerComponent);

const ImagePlaceholderUrl = `${cmscommons.IMAGES_URL}/image_placeholder.png`;
window.__smartedit__.addDecoratorPayload("Component", "MediaContainerSelectorItemComponent", {
    selector: 'se-media-container-selector-item',
    template: `<div class="media-container-selector-item__row"><img class="media-container-selector-item__img" [ngClass]="{ 'media-container-selector-item__img--selected': isSelected }" [src]="getThumbnailUrl(item.thumbnailUrl)"/><div class="media-container-selector-item__label">{{ item.qualifier }}</div></div>`,
    styles: [`.media-container-selector-item__row{display:grid;grid-template-columns:2fr 4fr;grid-column-gap:12px;width:100%;align-items:center;padding:0 8px}.media-container-selector-item__img{max-width:90%;max-height:100%;margin:12px}.media-container-selector-item__img--selected{max-width:35%;height:30px;margin:0}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let MediaContainerSelectorItemComponent = class MediaContainerSelectorItemComponent {
    constructor(data) {
        ({ item: this.item, selected: this.isSelected } = data);
    }
    getThumbnailUrl(thumbnailUrl) {
        return thumbnailUrl || ImagePlaceholderUrl;
    }
};
MediaContainerSelectorItemComponent = __decorate([
    core.Component({
        selector: 'se-media-container-selector-item',
        template: `<div class="media-container-selector-item__row"><img class="media-container-selector-item__img" [ngClass]="{ 'media-container-selector-item__img--selected': isSelected }" [src]="getThumbnailUrl(item.thumbnailUrl)"/><div class="media-container-selector-item__label">{{ item.qualifier }}</div></div>`,
        styles: [`.media-container-selector-item__row{display:grid;grid-template-columns:2fr 4fr;grid-column-gap:12px;width:100%;align-items:center;padding:0 8px}.media-container-selector-item__img{max-width:90%;max-height:100%;margin:12px}.media-container-selector-item__img--selected{max-width:35%;height:30px;margin:0}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(0, core.Inject(smarteditcommons.ITEM_COMPONENT_DATA_TOKEN)),
    __metadata("design:paramtypes", [Object])
], MediaContainerSelectorItemComponent);

const MediaContainersUri = '/cmswebservices/v1/catalogs/CURRENT_CONTEXT_CATALOG/versions/CURRENT_CONTEXT_CATALOG_VERSION/mediacontainers';
const FieldQualifier = 'mediaContainer';
window.__smartedit__.addDecoratorPayload("Component", "MediaContainerSelectorComponent", {
    selector: 'se-media-container-selector',
    template: `<se-generic-editor-dropdown [id]="id" [field]="field" [qualifier]="field.qualifier" [model]="mediaContainerNameModel" [showRemoveButton]="true" [itemComponent]="itemComponent" [actionableSearchItem]="actionableSearchItem" [(reset)]="reset"></se-generic-editor-dropdown><div *ngIf="isSelected() || creationInProgress"><label [for]="'media-container-qualifier-' + id" class="se-control-label required se-media-container-name-label">{{ 'se.cms.media.responsive.name' | lowercase | translate }}</label> <input type="text" name="media-container-qualifier" [id]="'media-container-qualifier-' + id" class="fd-form-control" [ngModel]="name" (ngModelChange)="onNameChange($event)" [readOnly]="isNameReadOnly()" [disabled]="!field.editable"/></div>`,
    styles: [`se-media-container-selector .se-media-container-name-label{margin-top:9px}se-media-container-selector .se-generic-editor-dropdown .se-item-printer{width:100%}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    encapsulation: core.ViewEncapsulation.None
});
let MediaContainerSelectorComponent = class MediaContainerSelectorComponent {
    constructor(cdr, systemEventService) {
        this.cdr = cdr;
        this.systemEventService = systemEventService;
        this.nameChange = new core.EventEmitter();
        this.onCreate = new core.EventEmitter();
        this.onRemove = new core.EventEmitter();
        this.onSelect = new core.EventEmitter();
        this.onCreationInProgressChange = new core.EventEmitter();
        this.field = {
            cmsStructureType: 'EditableDropdown',
            qualifier: FieldQualifier,
            required: true,
            uri: MediaContainersUri,
            idAttribute: 'qualifier',
            editable: true,
            paged: true
        };
        this.creationInProgress = false;
        this.itemComponent = MediaContainerSelectorItemComponent;
    }
    ngOnInit() {
        this.id = `${FieldQualifier}_${this.eventNameAffix}`;
        this.field.editable = this.isEditable;
        this.mediaContainerNameModel = {
            [FieldQualifier]: this.initialName
        };
        const selectMediaContainerEventName = `${this.id}${smarteditcommons.LINKED_DROPDOWN}`;
        this.unRegSelectMediaContainer = this.systemEventService.subscribe(selectMediaContainerEventName, (_eventId, selectedItem) => this.onSelectItem(selectedItem));
        const clearSelectMediaContainerEventName = `${this.id}_${CMS_CLEAR_MEDIA_CONTAINER_SELECTED_OPTION}`;
        this.unRegClearSelectMediaContainer = this.systemEventService.subscribe(clearSelectMediaContainerEventName, (_eventId, date) => this.clearSelectOption());
        const createMediaContainerEventName = `CREATE_MEDIA_CONTAINER_BUTTON_PRESSED_EVENT_${this.eventNameAffix}`;
        this.actionableSearchItem = {
            eventId: createMediaContainerEventName
        };
        this.unRegCreateMediaContainer = this.systemEventService.subscribe(createMediaContainerEventName, (_eventId, name) => this.onCreateMediaContainer(name));
    }
    ngOnDestroy() {
        this.unRegSelectMediaContainer();
        this.unRegCreateMediaContainer();
        this.unRegClearSelectMediaContainer();
    }
    onNameChange(name) {
        this.nameChange.emit(name);
    }
    isNameReadOnly() {
        return !this.isAdvancedCloning && !this.creationInProgress && this.isSelected();
    }
    isSelected() {
        return !!this.mediaContainerNameModel[FieldQualifier];
    }
    onSelectItem({ optionObject: selectedMediaContainer }) {
        this.setCreationInProgressAndEmit(false);
        if (!this.mediaContainerNameModel.mediaContainer) {
            this.onSelect.emit({
                catalogVersion: undefined,
                medias: {},
                qualifier: undefined,
                mediaContainerUuid: undefined
            });
            this.onRemove.emit();
        }
        else if (!!selectedMediaContainer) {
            this.onSelect.emit(selectedMediaContainer);
        }
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
    }
    onCreateMediaContainer(name) {
        this.clearSelectOption();
        this.setCreationInProgressAndEmit(true);
        this.onCreate.emit(name);
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
    }
    setCreationInProgressAndEmit(isInProgress) {
        this.creationInProgress = isInProgress;
        this.onCreationInProgressChange.emit(isInProgress);
    }
    clearSelectOption() {
        this.initialName = undefined;
        this.resetSelector();
    }
    resetSelector() {
        if (typeof this.reset === 'function') {
            this.reset(true);
        }
    }
};
__decorate([
    core.Input(),
    __metadata("design:type", String)
], MediaContainerSelectorComponent.prototype, "eventNameAffix", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], MediaContainerSelectorComponent.prototype, "isAdvancedCloning", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], MediaContainerSelectorComponent.prototype, "name", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], MediaContainerSelectorComponent.prototype, "initialName", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], MediaContainerSelectorComponent.prototype, "isEditable", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], MediaContainerSelectorComponent.prototype, "nameChange", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], MediaContainerSelectorComponent.prototype, "onCreate", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], MediaContainerSelectorComponent.prototype, "onRemove", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], MediaContainerSelectorComponent.prototype, "onSelect", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], MediaContainerSelectorComponent.prototype, "onCreationInProgressChange", void 0);
MediaContainerSelectorComponent = __decorate([
    core.Component({
        selector: 'se-media-container-selector',
        template: `<se-generic-editor-dropdown [id]="id" [field]="field" [qualifier]="field.qualifier" [model]="mediaContainerNameModel" [showRemoveButton]="true" [itemComponent]="itemComponent" [actionableSearchItem]="actionableSearchItem" [(reset)]="reset"></se-generic-editor-dropdown><div *ngIf="isSelected() || creationInProgress"><label [for]="'media-container-qualifier-' + id" class="se-control-label required se-media-container-name-label">{{ 'se.cms.media.responsive.name' | lowercase | translate }}</label> <input type="text" name="media-container-qualifier" [id]="'media-container-qualifier-' + id" class="fd-form-control" [ngModel]="name" (ngModelChange)="onNameChange($event)" [readOnly]="isNameReadOnly()" [disabled]="!field.editable"/></div>`,
        styles: [`se-media-container-selector .se-media-container-name-label{margin-top:9px}se-media-container-selector .se-generic-editor-dropdown .se-item-printer{width:100%}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush,
        encapsulation: core.ViewEncapsulation.None
    }),
    __metadata("design:paramtypes", [core.ChangeDetectorRef,
        smarteditcommons.SystemEventService])
], MediaContainerSelectorComponent);

window.__smartedit__.addDecoratorPayload("Component", "MediaErrorsComponent", {
    selector: 'se-media-errors',
    template: `<div class="se-media-error field-errors"><div *ngFor="let error of errors">{{ error.message | translate: { sizeLimitationOfFile: maxUploadFileSize } }}</div></div>`,
    styles: [`.se-media-error{color:#b00!important}`]
});
let /* @ngInject */ MediaErrorsComponent = class /* @ngInject */ MediaErrorsComponent {
};
__decorate([
    core.Input(),
    __metadata("design:type", Array)
], /* @ngInject */ MediaErrorsComponent.prototype, "errors", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Number)
], /* @ngInject */ MediaErrorsComponent.prototype, "maxUploadFileSize", void 0);
/* @ngInject */ MediaErrorsComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-media-errors',
        template: `<div class="se-media-error field-errors"><div *ngFor="let error of errors">{{ error.message | translate: { sizeLimitationOfFile: maxUploadFileSize } }}</div></div>`,
        styles: [`.se-media-error{color:#b00!important}`]
    })
], /* @ngInject */ MediaErrorsComponent);

window.__smartedit__.addDecoratorPayload("Component", "MediaFormatComponent", {
    selector: 'se-media-format',
    template: `<div class="se-media-format" [ngClass]="mediaFormat"><div *ngIf="mediaLabel" class="se-media-format__screen-type" [translate]="mediaFormatI18nKey"></div><se-media-format-uploaded *ngIf="isMediaPreviewEnabled()" [media]="media" [replaceLabelI18nKey]="mediaSelectorI18nKeys.REPLACE" [acceptedFileTypes]="acceptedFileTypes" [isFieldDisabled]="isFieldDisabled" (onFileSelect)="onFileSelectorFileSelect($event)" (onDelete)="onRemoveButtonClick()"></se-media-format-uploaded><div class="se-media--absent" *ngIf="isMediaAbsent()"><se-media-file-selector *ngIf="isEditable" [selectionMode]="'upload'" [labelI18nKey]="mediaSelectorI18nKeys.UPLOAD" [acceptedFileTypes]="acceptedFileTypes" [customClass]="isFieldDisabled ? 'file-selector-disabled' : ''" [disabled]="isFieldDisabled" (onFileSelect)="onFileSelectorFileSelect($event)"></se-media-file-selector><se-media-file-selector *ngIf="!isEditable" [selectionMode]="'upload'" [labelI18nKey]="mediaSelectorI18nKeys.UPLOAD" [acceptedFileTypes]="acceptedFileTypes" [customClass]="!isEditable ? 'file-selector-disabled' : ''" [disabled]="!isEditable" (onFileSelect)="onFileSelectorFileSelect($event)"></se-media-file-selector></div><div *ngIf="isUnderEdit" class="se-media--edit-wrapper"><se-media-file-selector class="se-media--edit" [labelI18nKey]="mediaSelectorI18nKeys.UPLOAD" [acceptedFileTypes]="acceptedFileTypes" [customClass]="'file-selector-disabled'" [disabled]="true" (onFileSelect)="onFileSelectorFileSelect($event)"></se-media-file-selector><span class="se-media-preview--edit" [translate]="mediaSelectorI18nKeys.UNDER_EDIT"></span></div><ng-container *ngIf="!isUnderEdit"><div class="error-input se-media-format__error" *ngFor="let error of getErrors()"><span>{{ error }}</span></div></ng-container></div>`,
    styles: [`.se-media-format{height:100%}.se-media-format__screen-type{font-weight:700;padding-top:4px;padding-bottom:10px;color:#32363a}.se-media-format__error{color:#b00}.se-media--absent{display:flex;flex-direction:row;align-items:center;justify-content:center;height:75px;border:1px dashed #d9d9d9}.se-media--edit-wrapper{height:100%}.se-media--edit{display:flex;flex-direction:row;align-items:center;justify-content:center}.se-media-preview--edit{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;display:block;font-style:italic}`, `.se-media-preview-container{position:relative}.se-media-preview-container .se-media-preview__image-wrapper{display:flex;flex-direction:row;align-items:center;justify-content:center;height:75px;background-color:#edeff0}.se-media-preview-container .se-media-preview__image-thumbnail{max-width:100%;max-height:100%}`],
    encapsulation: core.ViewEncapsulation.None
});
let /* @ngInject */ MediaFormatComponent = class /* @ngInject */ MediaFormatComponent {
    constructor(mediaService, mediaUtilService, mediaSelectorI18nKey) {
        this.mediaService = mediaService;
        this.mediaUtilService = mediaUtilService;
        this.onFileSelect = new core.EventEmitter();
        this.onDelete = new core.EventEmitter();
        this.media = null;
        this.mediaSelectorI18nKeys = mediaSelectorI18nKey;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.acceptedFileTypes = this.mediaUtilService.getAcceptedFileTypes(this.allowMediaType);
            this.mediaFormatI18nKey = `se.media.format.${this.mediaFormat}`;
            if (this.mediaUuid) {
                return this.fetchAndSetMedia();
            }
        });
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            const mediaUuidChange = changes.mediaUuid;
            if (mediaUuidChange && !mediaUuidChange.firstChange) {
                if (this.mediaUuid) {
                    return this.fetchAndSetMedia();
                }
                else {
                    this.media = null;
                }
            }
        });
    }
    onFileSelectorFileSelect(file) {
        this.onFileSelect.emit(file);
    }
    onRemoveButtonClick() {
        this.onDelete.emit();
    }
    isMediaPreviewEnabled() {
        var _a;
        return this.mediaUuid && !this.isUnderEdit && !!((_a = this.media) === null || _a === void 0 ? void 0 : _a.code);
    }
    isMediaAbsent() {
        return !this.mediaUuid && !this.isUnderEdit;
    }
    getErrors() {
        return (this.errorMessages || [])
            .filter((error) => error.format === this.mediaFormat)
            .map((error) => error.message);
    }
    fetchAndSetMedia() {
        return __awaiter(this, void 0, void 0, function* () {
            this.media = yield this.mediaService.getMedia(this.mediaUuid);
        });
    }
};
MediaFormatComponent.$inject = ["mediaService", "mediaUtilService", "mediaSelectorI18nKey"];
__decorate([
    core.Input(),
    __metadata("design:type", Array)
], /* @ngInject */ MediaFormatComponent.prototype, "errorMessages", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], /* @ngInject */ MediaFormatComponent.prototype, "isEditable", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], /* @ngInject */ MediaFormatComponent.prototype, "isUnderEdit", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], /* @ngInject */ MediaFormatComponent.prototype, "isFieldDisabled", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaFormatComponent.prototype, "mediaUuid", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaFormatComponent.prototype, "mediaFormat", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaFormatComponent.prototype, "mediaLabel", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaFormatComponent.prototype, "allowMediaType", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ MediaFormatComponent.prototype, "onFileSelect", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ MediaFormatComponent.prototype, "onDelete", void 0);
/* @ngInject */ MediaFormatComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-media-format',
        template: `<div class="se-media-format" [ngClass]="mediaFormat"><div *ngIf="mediaLabel" class="se-media-format__screen-type" [translate]="mediaFormatI18nKey"></div><se-media-format-uploaded *ngIf="isMediaPreviewEnabled()" [media]="media" [replaceLabelI18nKey]="mediaSelectorI18nKeys.REPLACE" [acceptedFileTypes]="acceptedFileTypes" [isFieldDisabled]="isFieldDisabled" (onFileSelect)="onFileSelectorFileSelect($event)" (onDelete)="onRemoveButtonClick()"></se-media-format-uploaded><div class="se-media--absent" *ngIf="isMediaAbsent()"><se-media-file-selector *ngIf="isEditable" [selectionMode]="'upload'" [labelI18nKey]="mediaSelectorI18nKeys.UPLOAD" [acceptedFileTypes]="acceptedFileTypes" [customClass]="isFieldDisabled ? 'file-selector-disabled' : ''" [disabled]="isFieldDisabled" (onFileSelect)="onFileSelectorFileSelect($event)"></se-media-file-selector><se-media-file-selector *ngIf="!isEditable" [selectionMode]="'upload'" [labelI18nKey]="mediaSelectorI18nKeys.UPLOAD" [acceptedFileTypes]="acceptedFileTypes" [customClass]="!isEditable ? 'file-selector-disabled' : ''" [disabled]="!isEditable" (onFileSelect)="onFileSelectorFileSelect($event)"></se-media-file-selector></div><div *ngIf="isUnderEdit" class="se-media--edit-wrapper"><se-media-file-selector class="se-media--edit" [labelI18nKey]="mediaSelectorI18nKeys.UPLOAD" [acceptedFileTypes]="acceptedFileTypes" [customClass]="'file-selector-disabled'" [disabled]="true" (onFileSelect)="onFileSelectorFileSelect($event)"></se-media-file-selector><span class="se-media-preview--edit" [translate]="mediaSelectorI18nKeys.UNDER_EDIT"></span></div><ng-container *ngIf="!isUnderEdit"><div class="error-input se-media-format__error" *ngFor="let error of getErrors()"><span>{{ error }}</span></div></ng-container></div>`,
        styles: [`.se-media-format{height:100%}.se-media-format__screen-type{font-weight:700;padding-top:4px;padding-bottom:10px;color:#32363a}.se-media-format__error{color:#b00}.se-media--absent{display:flex;flex-direction:row;align-items:center;justify-content:center;height:75px;border:1px dashed #d9d9d9}.se-media--edit-wrapper{height:100%}.se-media--edit{display:flex;flex-direction:row;align-items:center;justify-content:center}.se-media-preview--edit{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;display:block;font-style:italic}`, `.se-media-preview-container{position:relative}.se-media-preview-container .se-media-preview__image-wrapper{display:flex;flex-direction:row;align-items:center;justify-content:center;height:75px;background-color:#edeff0}.se-media-preview-container .se-media-preview__image-thumbnail{max-width:100%;max-height:100%}`],
        encapsulation: core.ViewEncapsulation.None
    }),
    __param(2, core.Inject(smarteditcommons.MEDIA_SELECTOR_I18N_KEY_TOKEN)),
    __metadata("design:paramtypes", [MediaService,
        MediaUtilService, Object])
], /* @ngInject */ MediaFormatComponent);

window.__smartedit__.addDecoratorPayload("Component", "MediaFormatUploadedComponent", {
    selector: 'se-media-format-uploaded',
    template: `<div class="se-media--present"><div class="se-media--present-img-container se-media-preview-container"><div *ngIf="isImage()" class="se-media-preview__image-wrapper"><se-media-preview [imageUrl]="getSafeUrl()"></se-media-preview><img class="se-media-preview__image-thumbnail" [src]="getSafeUrl()"/></div><div *ngIf="isVideo()" class="se-media-preview__image-wrapper"><video class="se-media-preview__image-thumbnail" controls><source [src]="getSafeUrl()" type="video/mp4"/></video></div><div *ngIf="isPdf()" class="se-media-preview__image-wrapper"><iframe class="se-media-preview__image-thumbnail" [src]="getSafeUrl()" style="width: 100%;height: 100%;border: none;"></iframe></div></div><se-media-advanced-properties [code]="media.code" [description]="media.description" [altText]="media.altText"></se-media-advanced-properties><se-media-file-selector [labelI18nKey]="replaceLabelI18nKey" [acceptedFileTypes]="acceptedFileTypes" [customClass]="'media-format-present-replace' + (isFieldDisabled ? ' file-selector-disabled' : '')" [disabled]="isFieldDisabled" (onFileSelect)="onFileSelectorFileSelect($event)"></se-media-file-selector><se-media-remove-button [isDisabled]="isFieldDisabled" (clickHandler)="onRemoveButtonClick()"></se-media-remove-button></div>`,
    styles: [`.se-media-preview-container{position:relative}.se-media-preview-container .se-media-preview__image-wrapper{display:flex;flex-direction:row;align-items:center;justify-content:center;height:75px;background-color:#edeff0}.se-media-preview-container .se-media-preview__image-thumbnail{max-width:100%;max-height:100%}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ MediaFormatUploadedComponent = class /* @ngInject */ MediaFormatUploadedComponent {
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
        this.onFileSelect = new core.EventEmitter();
        this.onDelete = new core.EventEmitter();
    }
    onFileSelectorFileSelect(file) {
        this.onFileSelect.emit(file);
    }
    onRemoveButtonClick() {
        this.onDelete.emit();
    }
    isImage() {
        return !this.isVideo() && !this.isPdf();
    }
    isVideo() {
        return this.media.mime && this.media.mime.includes(smarteditcommons.GenericEditorMediaType.VIDEO);
    }
    isPdf() {
        return this.media.mime && this.media.mime.includes(smarteditcommons.GenericEditorMediaType.PDF_DOCUMENT);
    }
    getSafeUrl() {
        return this.sanitizer.bypassSecurityTrustResourceUrl(this.media.url);
    }
};
MediaFormatUploadedComponent.$inject = ["sanitizer"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ MediaFormatUploadedComponent.prototype, "media", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaFormatUploadedComponent.prototype, "replaceLabelI18nKey", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Array)
], /* @ngInject */ MediaFormatUploadedComponent.prototype, "acceptedFileTypes", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], /* @ngInject */ MediaFormatUploadedComponent.prototype, "isFieldDisabled", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ MediaFormatUploadedComponent.prototype, "onFileSelect", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ MediaFormatUploadedComponent.prototype, "onDelete", void 0);
/* @ngInject */ MediaFormatUploadedComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-media-format-uploaded',
        template: `<div class="se-media--present"><div class="se-media--present-img-container se-media-preview-container"><div *ngIf="isImage()" class="se-media-preview__image-wrapper"><se-media-preview [imageUrl]="getSafeUrl()"></se-media-preview><img class="se-media-preview__image-thumbnail" [src]="getSafeUrl()"/></div><div *ngIf="isVideo()" class="se-media-preview__image-wrapper"><video class="se-media-preview__image-thumbnail" controls><source [src]="getSafeUrl()" type="video/mp4"/></video></div><div *ngIf="isPdf()" class="se-media-preview__image-wrapper"><iframe class="se-media-preview__image-thumbnail" [src]="getSafeUrl()" style="width: 100%;height: 100%;border: none;"></iframe></div></div><se-media-advanced-properties [code]="media.code" [description]="media.description" [altText]="media.altText"></se-media-advanced-properties><se-media-file-selector [labelI18nKey]="replaceLabelI18nKey" [acceptedFileTypes]="acceptedFileTypes" [customClass]="'media-format-present-replace' + (isFieldDisabled ? ' file-selector-disabled' : '')" [disabled]="isFieldDisabled" (onFileSelect)="onFileSelectorFileSelect($event)"></se-media-file-selector><se-media-remove-button [isDisabled]="isFieldDisabled" (clickHandler)="onRemoveButtonClick()"></se-media-remove-button></div>`,
        styles: [`.se-media-preview-container{position:relative}.se-media-preview-container .se-media-preview__image-wrapper{display:flex;flex-direction:row;align-items:center;justify-content:center;height:75px;background-color:#edeff0}.se-media-preview-container .se-media-preview__image-thumbnail{max-width:100%;max-height:100%}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [platformBrowser.DomSanitizer])
], /* @ngInject */ MediaFormatUploadedComponent);

var MediaFileSelectionMode;
(function (MediaFileSelectionMode) {
    MediaFileSelectionMode["replace"] = "replace";
    MediaFileSelectionMode["upload"] = "upload";
})(MediaFileSelectionMode || (MediaFileSelectionMode = {}));
window.__smartedit__.addDecoratorPayload("Component", "MediaFileSelectorComponent", {
    selector: 'se-media-file-selector',
    template: `<div class="se-file-selector" [ngClass]="customClass"><label *ngIf="!disabled" class="se-button se-button--text" [ngClass]="{ 'se-button--disabled': disabled,
                     'se-file-selector__custombtn': customComponent, 
                     'se-file-selector__btn': !customComponent }"><ng-container *ngIf="customComponent"><ng-container *ngComponentOutlet="customComponent.component; injector: customComponent.injector"></ng-container></ng-container><span class="sap-icon--share se-media__action-icon" [ngClass]="{
        'sap-icon--share': isReplaceMode(),
        'sap-icon--upload': !isReplaceMode()
    }"></span> <span class="se-file-selector__label">{{ labelI18nKey | translate }}</span><ng-container *ngIf="!customComponent"><input type="file" class="hide se-file-selector__input" [accept]="buildAcceptedFileTypesList()" (change)="onSelect($event.target.files)"/></ng-container></label></div>`,
    styles: [`.se-media-container-field__media-list{display:grid;grid-template-columns:repeat(4,1fr);grid-gap:0 16px}.se-media-container-cell--mobile{order:4}.se-media-container-cell--desktop{order:2}.se-media-container-cell--tablet{order:3}.se-media-container-cell--widescreen{order:1}.se-media__action-icon{color:#0a6ed1;margin-right:8px;width:12px}.se-media__action-icon--basic{font-size:1.1428571429rem;line-height:1.25;font-weight:400}.se-media__action-icon--basic::before{vertical-align:middle}.se-media__action-icon--delete{color:#b00}.se-media-action-btn{display:flex;flex-direction:row;align-items:center;padding:0;margin:0;border:none;box-shadow:none;outline:0;background-color:transparent;text-decoration:none;height:32px}.se-media-action-btn[disabled]{cursor:not-allowed;opacity:.4}.se-media-upload-form-wrapper{display:block}.se-media-upload-form-wrapper--spaced{margin-top:16px}.se-media-upload-form__header-folder fd-popover-control .selected-container .se-item-printer{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:156px}.se-media-upload-form__header-folder.is-invalid fd-popover-control .selected-container .fd-button{border-color:#b00}.se-file-selector{display:flex;flex-direction:row;align-items:center}.se-file-selector--disabled .se-file-selector__btn:focus,.se-file-selector--disabled .se-file-selector__btn:hover{cursor:not-allowed}.se-file-selector__btn{display:flex;flex-direction:row;align-items:center;padding:0;margin:0;border:none;box-shadow:none;outline:0;background-color:transparent;text-decoration:none;height:32px;position:relative}.se-file-selector__btn[disabled]{cursor:not-allowed;opacity:.4}.se-file-selector--disabled .se-file-selector__btn:focus,.se-file-selector--disabled .se-file-selector__btn:hover{cursor:not-allowed}.se-file-selector__btn>:first-child{display:block;top:0}.se-file-selector__custombtn{display:flex;flex-direction:row;align-items:center;padding:0;margin:0;border:none;box-shadow:none;outline:0;background-color:transparent;text-decoration:none;height:32px;position:relative}.se-file-selector__custombtn[disabled]{cursor:not-allowed;opacity:.4}.se-file-selector--disabled .se-file-selector__custombtn:focus,.se-file-selector--disabled .se-file-selector__custombtn:hover{cursor:not-allowed}.se-file-selector__custombtn>:first-child{position:absolute;width:100%;height:100%}.se-file-selector__label{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;color:var(--sapInformativeColor)}`],
    encapsulation: core.ViewEncapsulation.None,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ MediaFileSelectorComponent = class /* @ngInject */ MediaFileSelectorComponent {
    constructor(injector, customSelector) {
        this.injector = injector;
        this.onFileSelect = new core.EventEmitter();
        if (customSelector) {
            this.initCustomComponent(customSelector);
        }
    }
    ngOnInit() {
        this.disabled = this.disabled || false;
        this.customClass = this.customClass || '';
        this.selectionMode = this.selectionMode || MediaFileSelectionMode.replace;
    }
    buildAcceptedFileTypesList() {
        return this.acceptedFileTypes.map((fileType) => `.${fileType}`).join(',');
    }
    isReplaceMode() {
        return this.selectionMode === MediaFileSelectionMode.replace;
    }
    onSelect(fileList) {
        this.onFileSelect.emit(fileList);
    }
    initCustomComponent({ component }) {
        this.customComponent = {
            component,
            injector: core.Injector.create({
                parent: this.injector,
                providers: [
                    {
                        provide: smarteditcommons.MEDIA_FILE_SELECTOR_CUSTOM_INJECTOR_TOKEN,
                        useValue: {
                            onSelect: (fileList) => this.onSelect(fileList)
                        }
                    }
                ]
            })
        };
    }
};
MediaFileSelectorComponent.$inject = ["injector", "customSelector"];
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaFileSelectorComponent.prototype, "selectionMode", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaFileSelectorComponent.prototype, "labelI18nKey", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Array)
], /* @ngInject */ MediaFileSelectorComponent.prototype, "acceptedFileTypes", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaFileSelectorComponent.prototype, "customClass", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], /* @ngInject */ MediaFileSelectorComponent.prototype, "disabled", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ MediaFileSelectorComponent.prototype, "onFileSelect", void 0);
/* @ngInject */ MediaFileSelectorComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-media-file-selector',
        template: `<div class="se-file-selector" [ngClass]="customClass"><label *ngIf="!disabled" class="se-button se-button--text" [ngClass]="{ 'se-button--disabled': disabled,
                     'se-file-selector__custombtn': customComponent, 
                     'se-file-selector__btn': !customComponent }"><ng-container *ngIf="customComponent"><ng-container *ngComponentOutlet="customComponent.component; injector: customComponent.injector"></ng-container></ng-container><span class="sap-icon--share se-media__action-icon" [ngClass]="{
        'sap-icon--share': isReplaceMode(),
        'sap-icon--upload': !isReplaceMode()
    }"></span> <span class="se-file-selector__label">{{ labelI18nKey | translate }}</span><ng-container *ngIf="!customComponent"><input type="file" class="hide se-file-selector__input" [accept]="buildAcceptedFileTypesList()" (change)="onSelect($event.target.files)"/></ng-container></label></div>`,
        styles: [`.se-media-container-field__media-list{display:grid;grid-template-columns:repeat(4,1fr);grid-gap:0 16px}.se-media-container-cell--mobile{order:4}.se-media-container-cell--desktop{order:2}.se-media-container-cell--tablet{order:3}.se-media-container-cell--widescreen{order:1}.se-media__action-icon{color:#0a6ed1;margin-right:8px;width:12px}.se-media__action-icon--basic{font-size:1.1428571429rem;line-height:1.25;font-weight:400}.se-media__action-icon--basic::before{vertical-align:middle}.se-media__action-icon--delete{color:#b00}.se-media-action-btn{display:flex;flex-direction:row;align-items:center;padding:0;margin:0;border:none;box-shadow:none;outline:0;background-color:transparent;text-decoration:none;height:32px}.se-media-action-btn[disabled]{cursor:not-allowed;opacity:.4}.se-media-upload-form-wrapper{display:block}.se-media-upload-form-wrapper--spaced{margin-top:16px}.se-media-upload-form__header-folder fd-popover-control .selected-container .se-item-printer{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:156px}.se-media-upload-form__header-folder.is-invalid fd-popover-control .selected-container .fd-button{border-color:#b00}.se-file-selector{display:flex;flex-direction:row;align-items:center}.se-file-selector--disabled .se-file-selector__btn:focus,.se-file-selector--disabled .se-file-selector__btn:hover{cursor:not-allowed}.se-file-selector__btn{display:flex;flex-direction:row;align-items:center;padding:0;margin:0;border:none;box-shadow:none;outline:0;background-color:transparent;text-decoration:none;height:32px;position:relative}.se-file-selector__btn[disabled]{cursor:not-allowed;opacity:.4}.se-file-selector--disabled .se-file-selector__btn:focus,.se-file-selector--disabled .se-file-selector__btn:hover{cursor:not-allowed}.se-file-selector__btn>:first-child{display:block;top:0}.se-file-selector__custombtn{display:flex;flex-direction:row;align-items:center;padding:0;margin:0;border:none;box-shadow:none;outline:0;background-color:transparent;text-decoration:none;height:32px;position:relative}.se-file-selector__custombtn[disabled]{cursor:not-allowed;opacity:.4}.se-file-selector--disabled .se-file-selector__custombtn:focus,.se-file-selector--disabled .se-file-selector__custombtn:hover{cursor:not-allowed}.se-file-selector__custombtn>:first-child{position:absolute;width:100%;height:100%}.se-file-selector__label{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;color:var(--sapInformativeColor)}`],
        encapsulation: core.ViewEncapsulation.None,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(1, core.Optional()),
    __param(1, core.Inject(smarteditcommons.MEDIA_FILE_SELECTOR_CUSTOM_TOKEN)),
    __metadata("design:paramtypes", [core.Injector, Object])
], /* @ngInject */ MediaFileSelectorComponent);

window.__smartedit__.addDecoratorPayload("Component", "MediaPreviewComponent", {
    selector: 'se-media-preview',
    template: `<se-tooltip [appendTo]="'body'" [placement]="'bottom'" [isChevronVisible]="true" [triggers]="['click']"><span se-tooltip-trigger><div class="sap-icon--search se-media-preview__icon"></div></span><div se-tooltip-body><img class="se-media-preview__image" [src]="imageUrl"/></div></se-tooltip>`,
    styles: [`.se-media-preview{display:block;cursor:pointer;position:absolute;height:24px;width:24px;top:0;right:0}.se-media-preview__icon{display:flex;flex-direction:row;align-items:center;justify-content:center;font-size:1.1428571429rem;line-height:1.25;font-weight:400;outline:0;background-color:#0a6ed1;color:#fff;height:24px;width:24px}.se-media-preview__image{width:160px;height:auto}`],
    encapsulation: core.ViewEncapsulation.None,
    host: {
        '[class.se-media-preview]': 'true'
    },
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ MediaPreviewComponent = class /* @ngInject */ MediaPreviewComponent {
};
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaPreviewComponent.prototype, "imageUrl", void 0);
/* @ngInject */ MediaPreviewComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-media-preview',
        template: `<se-tooltip [appendTo]="'body'" [placement]="'bottom'" [isChevronVisible]="true" [triggers]="['click']"><span se-tooltip-trigger><div class="sap-icon--search se-media-preview__icon"></div></span><div se-tooltip-body><img class="se-media-preview__image" [src]="imageUrl"/></div></se-tooltip>`,
        styles: [`.se-media-preview{display:block;cursor:pointer;position:absolute;height:24px;width:24px;top:0;right:0}.se-media-preview__icon{display:flex;flex-direction:row;align-items:center;justify-content:center;font-size:1.1428571429rem;line-height:1.25;font-weight:400;outline:0;background-color:#0a6ed1;color:#fff;height:24px;width:24px}.se-media-preview__image{width:160px;height:auto}`],
        encapsulation: core.ViewEncapsulation.None,
        host: {
            '[class.se-media-preview]': 'true'
        },
        changeDetection: core.ChangeDetectionStrategy.OnPush
    })
], /* @ngInject */ MediaPreviewComponent);

window.__smartedit__.addDecoratorPayload("Component", "MediaRemoveButtonComponent", {
    selector: 'se-media-remove-button',
    template: `<button type="button" class="se-media-action-btn se-media-remove-btn" [disabled]="isDisabled" (click)="clickHandler.emit($event)"><span class="se-media__action-icon se-media__action-icon--delete sap-icon--delete"></span> <span class="se-media-remove-btn-txt" [ngClass]="{ 'se-media-remove-btn-txt--disabled': isDisabled }" translate="se.media.format.remove"></span></button>`,
    styles: [`.se-media-remove-btn-txt{color:#b00}.se-media-remove-btn-txt--disabled{color:#6a6d70}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ MediaRemoveButtonComponent = class /* @ngInject */ MediaRemoveButtonComponent {
    constructor() {
        this.clickHandler = new core.EventEmitter();
    }
};
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], /* @ngInject */ MediaRemoveButtonComponent.prototype, "isDisabled", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", Object)
], /* @ngInject */ MediaRemoveButtonComponent.prototype, "clickHandler", void 0);
/* @ngInject */ MediaRemoveButtonComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-media-remove-button',
        template: `<button type="button" class="se-media-action-btn se-media-remove-btn" [disabled]="isDisabled" (click)="clickHandler.emit($event)"><span class="se-media__action-icon se-media__action-icon--delete sap-icon--delete"></span> <span class="se-media-remove-btn-txt" [ngClass]="{ 'se-media-remove-btn-txt--disabled': isDisabled }" translate="se.media.format.remove"></span></button>`,
        styles: [`.se-media-remove-btn-txt{color:#b00}.se-media-remove-btn-txt--disabled{color:#6a6d70}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    })
], /* @ngInject */ MediaRemoveButtonComponent);

window.__smartedit__.addDecoratorPayload("Component", "MediaAdvancedPropertiesComponent", {
    selector: 'se-media-advanced-properties',
    template: `<se-tooltip [appendTo]="'body'" [placement]="'bottom'" [isChevronVisible]="true" [triggers]="['click']" class="se-media-advanced-info"><span se-tooltip-trigger class="se-media-advanced-info__trigger"><span class="sap-icon--message-information se-media__action-icon se-media__action-icon--basic" [title]="i18nKeys.INFORMATION | translate"></span><se-media-action-label [i18nKey]="i18nKeys.INFORMATION"></se-media-action-label></span><div se-tooltip-body><div class="se-media-advanced-info-body"><div class="se-media-advanced-info-row advanced-information-description" *ngIf="description"><div class="se-media-advanced-info-row__label se-control-label" [translate]="i18nKeys.DESCRIPTION"></div><div class="se-media-advanced-info-row__description">{{ description }}</div></div><div class="se-media-advanced-info-row advanced-information-code"><div class="se-media-advanced-info-row__label se-control-label" [translate]="i18nKeys.CODE"></div><div class="se-media-advanced-info-row__description">{{ code }}</div></div><div class="se-media-advanced-info-row advanced-information-alt-text" *ngIf="altText"><div class="se-media-advanced-info-row__label se-control-label" [translate]="i18nKeys.ALT_TEXT"></div><div class="se-media-advanced-info-row__description">{{ altText }}</div></div></div></div></se-tooltip>`,
    styles: [`.se-media-container-field__media-list{display:grid;grid-template-columns:repeat(4,1fr);grid-gap:0 16px}.se-media-container-cell--mobile{order:4}.se-media-container-cell--desktop{order:2}.se-media-container-cell--tablet{order:3}.se-media-container-cell--widescreen{order:1}.se-media__action-icon{color:#0a6ed1;margin-right:8px;width:12px}.se-media__action-icon--basic{font-size:1.1428571429rem;line-height:1.25;font-weight:400}.se-media__action-icon--basic::before{vertical-align:middle}.se-media__action-icon--delete{color:#b00}.se-media-action-btn{display:flex;flex-direction:row;align-items:center;padding:0;margin:0;border:none;box-shadow:none;outline:0;background-color:transparent;text-decoration:none;height:32px}.se-media-action-btn[disabled]{cursor:not-allowed;opacity:.4}.se-media-upload-form-wrapper{display:block}.se-media-upload-form-wrapper--spaced{margin-top:16px}.se-media-upload-form__header-folder fd-popover-control .selected-container .se-item-printer{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:156px}.se-media-upload-form__header-folder.is-invalid fd-popover-control .selected-container .fd-button{border-color:#b00}.se-media-advanced-info{display:flex;flex-direction:row;align-items:center;display:inline-flex;height:32px;outline:0}.se-media-advanced-info__trigger{display:flex;align-items:center}.se-media-advanced-info-body{padding:11px}.se-media-advanced-info-row:not(:last-child){margin-bottom:16px}.se-media-advanced-info-row__description{color:#32363a;word-break:break-all;max-width:95%}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ MediaAdvancedPropertiesComponent = class /* @ngInject */ MediaAdvancedPropertiesComponent {
    constructor() {
        this.i18nKeys = {
            DESCRIPTION: 'se.media.advanced.information.description',
            CODE: 'se.media.advanced.information.code',
            ALT_TEXT: 'se.media.advanced.information.alt.text',
            ADVANCED_INFORMATION: 'se.media.advanced.information',
            INFORMATION: 'se.media.information'
        };
    }
};
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaAdvancedPropertiesComponent.prototype, "code", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaAdvancedPropertiesComponent.prototype, "description", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaAdvancedPropertiesComponent.prototype, "altText", void 0);
/* @ngInject */ MediaAdvancedPropertiesComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-media-advanced-properties',
        template: `<se-tooltip [appendTo]="'body'" [placement]="'bottom'" [isChevronVisible]="true" [triggers]="['click']" class="se-media-advanced-info"><span se-tooltip-trigger class="se-media-advanced-info__trigger"><span class="sap-icon--message-information se-media__action-icon se-media__action-icon--basic" [title]="i18nKeys.INFORMATION | translate"></span><se-media-action-label [i18nKey]="i18nKeys.INFORMATION"></se-media-action-label></span><div se-tooltip-body><div class="se-media-advanced-info-body"><div class="se-media-advanced-info-row advanced-information-description" *ngIf="description"><div class="se-media-advanced-info-row__label se-control-label" [translate]="i18nKeys.DESCRIPTION"></div><div class="se-media-advanced-info-row__description">{{ description }}</div></div><div class="se-media-advanced-info-row advanced-information-code"><div class="se-media-advanced-info-row__label se-control-label" [translate]="i18nKeys.CODE"></div><div class="se-media-advanced-info-row__description">{{ code }}</div></div><div class="se-media-advanced-info-row advanced-information-alt-text" *ngIf="altText"><div class="se-media-advanced-info-row__label se-control-label" [translate]="i18nKeys.ALT_TEXT"></div><div class="se-media-advanced-info-row__description">{{ altText }}</div></div></div></div></se-tooltip>`,
        styles: [`.se-media-container-field__media-list{display:grid;grid-template-columns:repeat(4,1fr);grid-gap:0 16px}.se-media-container-cell--mobile{order:4}.se-media-container-cell--desktop{order:2}.se-media-container-cell--tablet{order:3}.se-media-container-cell--widescreen{order:1}.se-media__action-icon{color:#0a6ed1;margin-right:8px;width:12px}.se-media__action-icon--basic{font-size:1.1428571429rem;line-height:1.25;font-weight:400}.se-media__action-icon--basic::before{vertical-align:middle}.se-media__action-icon--delete{color:#b00}.se-media-action-btn{display:flex;flex-direction:row;align-items:center;padding:0;margin:0;border:none;box-shadow:none;outline:0;background-color:transparent;text-decoration:none;height:32px}.se-media-action-btn[disabled]{cursor:not-allowed;opacity:.4}.se-media-upload-form-wrapper{display:block}.se-media-upload-form-wrapper--spaced{margin-top:16px}.se-media-upload-form__header-folder fd-popover-control .selected-container .se-item-printer{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:156px}.se-media-upload-form__header-folder.is-invalid fd-popover-control .selected-container .fd-button{border-color:#b00}.se-media-advanced-info{display:flex;flex-direction:row;align-items:center;display:inline-flex;height:32px;outline:0}.se-media-advanced-info__trigger{display:flex;align-items:center}.se-media-advanced-info-body{padding:11px}.se-media-advanced-info-row:not(:last-child){margin-bottom:16px}.se-media-advanced-info-row__description{color:#32363a;word-break:break-all;max-width:95%}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    })
], /* @ngInject */ MediaAdvancedPropertiesComponent);

window.__smartedit__.addDecoratorPayload("Component", "MediaPrinterComponent", {
    selector: 'se-media-printer',
    template: `<div class="se-media-selector" *ngIf="isSelected"><span class="se-media-selector__left-section se-media-preview-container"><div *ngIf="isImage()" class="se-media-selector__left-section se-media-preview-container"><se-media-preview [imageUrl]="getSafeUrl()"></se-media-preview><img class="se-media-preview__image-thumbnail" [alt]="media.code" [src]="getSafeUrl()"/></div><div *ngIf="isVideo()" class="se-media-selector__left-section se-media-preview-container"><video class="se-media-preview__image-thumbnail" controls><source [src]="getSafeUrl()" type="video/mp4"/></video></div><div *ngIf="isPdf()" class="se-media-selector__left-section se-media-preview-container"><iframe class="se-media-preview__image-thumbnail" [src]="getSafeUrl()" style="width: 100%;height: 100%;border: none;"></iframe></div></span><span class="se-media-selector__right-section"><se-media-advanced-properties [code]="media.code" [description]="media.description" [altText]="media.altText"></se-media-advanced-properties><button class="se-media-action-btn replace-image" [disabled]="isDisabled()"><span class="sap-icon--share se-media__action-icon"></span><se-media-action-label [state]="isDisabled() ? 'disabled' : null" [i18nKey]="'se.upload.image.replace'"></se-media-action-label></button><se-media-remove-button [isDisabled]="isDisabled()" (clickHandler)="select.removeSelectedOption($event, media)"></se-media-remove-button></span></div><div class="se-media-selector__search" *ngIf="!isSelected"><div *ngIf="isImage()" class="se-media-selector__search-img-wrapper"><img [src]="getSafeUrl()" class="se-media-selector__search-img" [alt]="media.code"/></div><div *ngIf="isVideo()" class="se-media-selector__search-img-wrapper"><video class="se-media-selector__search-img" controls><source [src]="getSafeUrl()" type="video/mp4"/></video></div><div *ngIf="isPdf()" class="se-media-selector__search-img-wrapper"><iframe class="se-media-selector__search-img" [src]="getSafeUrl()" style="width: 100%;height: 100%;border: none;"></iframe></div><div class="se-media-selector__search-name">{{ media.code }}</div></div>`,
    styles: [`se-media-printer .se-media-selector{display:flex;flex-direction:row;align-items:center;position:relative}se-media-printer .se-media-selector__left-section{display:flex;flex-direction:row;align-items:center;justify-content:center;background-color:#eeeeef;position:relative;width:135px;height:80px}se-media-printer .se-media-selector__right-section{display:flex;flex-direction:column;margin-left:20px}se-media-printer .se-media-selector__search{display:flex;flex-direction:row;align-items:center}se-media-printer .se-media-selector__search-img-wrapper{display:flex;flex-direction:row;align-items:center;justify-content:center;background-color:#eeeeef;width:135px;height:80px;margin-right:16px}se-media-printer .se-media-selector__search-img{max-width:100%;max-height:100%;margin:5px}se-media-printer .se-media-selector__search-name{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;max-width:70%}`, `.se-media-preview-container{position:relative}.se-media-preview-container .se-media-preview__image-wrapper{display:flex;flex-direction:row;align-items:center;justify-content:center;height:75px;background-color:#edeff0}.se-media-preview-container .se-media-preview__image-thumbnail{max-width:100%;max-height:100%}`],
    encapsulation: core.ViewEncapsulation.None,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let MediaPrinterComponent = class MediaPrinterComponent {
    constructor(data, sanitizer) {
        this.data = data;
        this.sanitizer = sanitizer;
        ({ item: this.media, selected: this.isSelected, select: this.select } = data);
    }
    isDisabled() {
        return this.select.isReadOnly;
    }
    isImage() {
        return !this.isVideo() && !this.isPdf();
    }
    isVideo() {
        return this.media.mime && this.media.mime.includes(smarteditcommons.GenericEditorMediaType.VIDEO);
    }
    isPdf() {
        return this.media.mime && this.media.mime.includes(smarteditcommons.GenericEditorMediaType.PDF_DOCUMENT);
    }
    getSafeUrl() {
        return this.sanitizer.bypassSecurityTrustResourceUrl(this.media.url);
    }
};
MediaPrinterComponent = __decorate([
    core.Component({
        selector: 'se-media-printer',
        template: `<div class="se-media-selector" *ngIf="isSelected"><span class="se-media-selector__left-section se-media-preview-container"><div *ngIf="isImage()" class="se-media-selector__left-section se-media-preview-container"><se-media-preview [imageUrl]="getSafeUrl()"></se-media-preview><img class="se-media-preview__image-thumbnail" [alt]="media.code" [src]="getSafeUrl()"/></div><div *ngIf="isVideo()" class="se-media-selector__left-section se-media-preview-container"><video class="se-media-preview__image-thumbnail" controls><source [src]="getSafeUrl()" type="video/mp4"/></video></div><div *ngIf="isPdf()" class="se-media-selector__left-section se-media-preview-container"><iframe class="se-media-preview__image-thumbnail" [src]="getSafeUrl()" style="width: 100%;height: 100%;border: none;"></iframe></div></span><span class="se-media-selector__right-section"><se-media-advanced-properties [code]="media.code" [description]="media.description" [altText]="media.altText"></se-media-advanced-properties><button class="se-media-action-btn replace-image" [disabled]="isDisabled()"><span class="sap-icon--share se-media__action-icon"></span><se-media-action-label [state]="isDisabled() ? 'disabled' : null" [i18nKey]="'se.upload.image.replace'"></se-media-action-label></button><se-media-remove-button [isDisabled]="isDisabled()" (clickHandler)="select.removeSelectedOption($event, media)"></se-media-remove-button></span></div><div class="se-media-selector__search" *ngIf="!isSelected"><div *ngIf="isImage()" class="se-media-selector__search-img-wrapper"><img [src]="getSafeUrl()" class="se-media-selector__search-img" [alt]="media.code"/></div><div *ngIf="isVideo()" class="se-media-selector__search-img-wrapper"><video class="se-media-selector__search-img" controls><source [src]="getSafeUrl()" type="video/mp4"/></video></div><div *ngIf="isPdf()" class="se-media-selector__search-img-wrapper"><iframe class="se-media-selector__search-img" [src]="getSafeUrl()" style="width: 100%;height: 100%;border: none;"></iframe></div><div class="se-media-selector__search-name">{{ media.code }}</div></div>`,
        styles: [`se-media-printer .se-media-selector{display:flex;flex-direction:row;align-items:center;position:relative}se-media-printer .se-media-selector__left-section{display:flex;flex-direction:row;align-items:center;justify-content:center;background-color:#eeeeef;position:relative;width:135px;height:80px}se-media-printer .se-media-selector__right-section{display:flex;flex-direction:column;margin-left:20px}se-media-printer .se-media-selector__search{display:flex;flex-direction:row;align-items:center}se-media-printer .se-media-selector__search-img-wrapper{display:flex;flex-direction:row;align-items:center;justify-content:center;background-color:#eeeeef;width:135px;height:80px;margin-right:16px}se-media-printer .se-media-selector__search-img{max-width:100%;max-height:100%;margin:5px}se-media-printer .se-media-selector__search-name{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;max-width:70%}`, `.se-media-preview-container{position:relative}.se-media-preview-container .se-media-preview__image-wrapper{display:flex;flex-direction:row;align-items:center;justify-content:center;height:75px;background-color:#edeff0}.se-media-preview-container .se-media-preview__image-thumbnail{max-width:100%;max-height:100%}`],
        encapsulation: core.ViewEncapsulation.None,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(0, core.Inject(smarteditcommons.ITEM_COMPONENT_DATA_TOKEN)),
    __metadata("design:paramtypes", [Object, platformBrowser.DomSanitizer])
], MediaPrinterComponent);

window.__smartedit__.addDecoratorPayload("Component", "MediaSelectorComponent", {
    selector: 'se-media-selector',
    template: `<div class="media-selector"><se-select [id]="id" [(model)]="mediaId" (modelChange)="onMediaIdChange($event)" [fetchStrategy]="fetchStrategy" [isReadOnly]="isDisabled" [itemComponent]="mediaPrinterComponent"></se-select></div>`,
    styles: [`se-media-selector .se-select [has-selected-option] .toggle-button{min-height:100px}`],
    encapsulation: core.ViewEncapsulation.None,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ MediaSelectorComponent = class /* @ngInject */ MediaSelectorComponent {
    constructor(mediaService) {
        this.mediaService = mediaService;
        this.mediaPrinterComponent = MediaPrinterComponent;
        this.mediaIdChange = new core.EventEmitter();
    }
    ngOnInit() {
        this.fetchStrategy = {
            fetchEntity: (uuid) => this.mediaService.getMedia(uuid),
            fetchPage: (search, pageSize, currentPage) => this.mediaService.getPage(search, pageSize, currentPage, this.mimeType)
        };
    }
    onMediaIdChange(id) {
        this.mediaId = id;
        this.mediaIdChange.emit(id);
    }
};
MediaSelectorComponent.$inject = ["mediaService"];
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaSelectorComponent.prototype, "id", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaSelectorComponent.prototype, "mediaId", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaSelectorComponent.prototype, "mimeType", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ MediaSelectorComponent.prototype, "mediaIdChange", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], /* @ngInject */ MediaSelectorComponent.prototype, "isDisabled", void 0);
/* @ngInject */ MediaSelectorComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-media-selector',
        template: `<div class="media-selector"><se-select [id]="id" [(model)]="mediaId" (modelChange)="onMediaIdChange($event)" [fetchStrategy]="fetchStrategy" [isReadOnly]="isDisabled" [itemComponent]="mediaPrinterComponent"></se-select></div>`,
        styles: [`se-media-selector .se-select [has-selected-option] .toggle-button{min-height:100px}`],
        encapsulation: core.ViewEncapsulation.None,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [MediaService])
], /* @ngInject */ MediaSelectorComponent);

window.__smartedit__.addDecoratorPayload("Component", "MediaUploadFormComponent", {
    selector: 'se-media-upload-form',
    template: `<div class="se-media-upload-form"><div class="se-media-upload-form__header"><div class="se-media-upload-form__header-content"><div class="se-media-upload-form__header-title" translate="se.upload.image.to.folder"></div><se-select id="se-media-upload-form__header-folder" class="se-media-upload-form__header-folder" [ngClass]="{ 'is-invalid': hasError() }" [multiSelect]="false" [controls]="false" [(model)]="folderSelected" (modelChange)="folderSelectedChanged($event)" [fetchStrategy]="folderFetchStrategy" [placeholder]="folderSelected"></se-select><div class="se-media-upload-form__header-actions"><button type="button" class="fd-button--light se-media-upload-btn__cancel fd-button--compact" translate="se.upload.image.cancel" (click)="cancel()"></button> <button type="button" class="fd-button se-media-upload-btn__submit fd-button--compact" translate="se.upload.image.submit" (click)="uploadMedia()"></button></div></div><div class="se-media-upload-form__header-error"><span class="upload-field-error fd-form__message fd-form__message--error" *ngFor="let error of folderErrors">{{ error | translate }}</span></div></div><div class="se-media-upload-form__replace-file"><div class="se-media-upload-form__file-name">{{ image.name }}</div><se-media-file-selector [labelI18nKey]="'se.upload.image.replace'" [acceptedFileTypes]="acceptedFileTypes" (onFileSelect)="onFileSelect($event)"></se-media-file-selector></div><form class="se-media-upload-form__file-info"><se-media-upload-field [fieldName]="'code'" [fieldValue]="imageParams?.code" [fieldErrors]="getErrorsForFieldByCode('code')" [isRequired]="true" [labelI18nKey]="'se.uploaded.image.code'" (fieldValueChange)="onChangeFieldValue($event, 'code')"></se-media-upload-field><se-media-upload-field [fieldName]="'description'" [fieldValue]="imageParams?.description" [fieldErrors]="getErrorsForFieldByCode('description')" [isRequired]="true" [labelI18nKey]="'se.uploaded.image.description'" (fieldValueChange)="onChangeFieldValue($event, 'description')"></se-media-upload-field><se-media-upload-field [fieldName]="'alt-text'" [fieldValue]="imageParams?.altText" [fieldErrors]="getErrorsForFieldByCode('altText')" [isRequired]="true" [labelI18nKey]="'se.uploaded.image.alt.text'" (fieldValueChange)="onChangeFieldValue($event, 'altText')"></se-media-upload-field></form><se-spinner [isSpinning]="isUploading"></se-spinner></div>`,
    styles: [`.se-media-upload-form{box-shadow:0 6px 12px rgba(0,0,0,.175);border-radius:4px}.se-media-upload-form__header{border-bottom:1px solid #d9d9d9;display:flex;flex-direction:column}.se-media-upload-form__header-content{display:flex;flex-direction:row;align-items:center;justify-content:space-between;height:53px;padding:20px}.se-media-upload-form__header-title{font-size:1.1428571429rem;line-height:1.25;font-weight:400;color:#32363a}.se-media-upload-form__header-folder{width:200px;margin-left:8px;margin-right:auto}.se-media-upload-form__header-error{padding-left:20px}.se-media-upload-form__replace-file{display:flex;flex-direction:row;align-items:center;justify-content:space-between;padding:16px 20px 0}.se-media-upload-form__file-name{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;max-width:80%}.se-media-upload-form__file-info{display:grid;grid-template-columns:repeat(2,1fr);grid-gap:16px;padding:20px}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ MediaUploadFormComponent = class /* @ngInject */ MediaUploadFormComponent {
    constructor(cdr, fileValidatorFactory, mediaBackendValidationHandler, mediaUploaderService, mediaFolderService, mediaUtilService) {
        this.cdr = cdr;
        this.fileValidatorFactory = fileValidatorFactory;
        this.mediaBackendValidationHandler = mediaBackendValidationHandler;
        this.mediaUploaderService = mediaUploaderService;
        this.mediaFolderService = mediaFolderService;
        this.mediaUtilService = mediaUtilService;
        this.onCancel = new core.EventEmitter();
        this.onSelect = new core.EventEmitter();
        this.onUploadSuccess = new core.EventEmitter();
        this.fieldErrors = [];
        this.imageParams = null;
        this.fileValidator = this.fileValidatorFactory.build([
            {
                subject: 'code',
                message: 'se.uploaded.image.code.is.required',
                validate: (code) => !!code
            }
        ]);
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.acceptedFileTypes = this.mediaUtilService.getAcceptedFileTypes(this.allowMediaType);
            this.folderFetchStrategy = this.mediaFolderService.mediaFoldersFetchStrategy;
            this.folderSelected = yield this.mediaFolderService.getDefaultFolder();
            this.cdr.markForCheck();
        });
    }
    ngOnChanges(changes) {
        const imageChange = changes.image;
        if (imageChange) {
            const { name: imageName } = this.image;
            this.imageParams = {
                code: imageName,
                description: imageName,
                altText: imageName
            };
        }
    }
    getErrorsForFieldByCode(code) {
        return this.fieldErrors
            .filter((error) => error.subject === code)
            .map((error) => error.message);
    }
    uploadMedia() {
        return __awaiter(this, void 0, void 0, function* () {
            this.fieldErrors = [];
            if (!this.fileValidator.validate(this.imageParams, this.maxUploadFileSize, this.fieldErrors)) {
                return;
            }
            const validate = this.acceptedFileTypes.filter((type) => this.image && this.image.type && this.image.type.includes(type));
            if (!validate || (validate && validate.length < 1)) {
                this.fieldErrors.push({
                    subject: 'code',
                    message: smarteditcommons.FILE_VALIDATION_CONFIG.I18N_KEYS.FILE_TYPE_INVALID
                });
                return;
            }
            this.isUploading = true;
            try {
                const uploadedMedia = yield this.mediaUploaderService.uploadMedia({
                    file: this.image,
                    code: smarteditcommons.stringUtils.escapeHtml(this.imageParams.code),
                    description: smarteditcommons.stringUtils.escapeHtml(this.imageParams.description),
                    altText: smarteditcommons.stringUtils.escapeHtml(this.imageParams.altText),
                    folder: this.folderSelected ? this.folderSelected : ''
                });
                this.onMediaUploadSuccess(uploadedMedia);
            }
            catch (error) {
                this.onMediaUploadFail(error);
            }
            finally {
                this.isUploading = false;
            }
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    cancel() {
        this.reset();
        this.onCancel.emit();
    }
    onChangeFieldValue(value, paramName) {
        this.imageParams[paramName] = value;
    }
    onFileSelect(fileList) {
        this.onSelect.emit(fileList);
    }
    hasError() {
        var _a;
        return ((_a = this.folderErrors) === null || _a === void 0 ? void 0 : _a.length) > 0;
    }
    folderSelectedChanged(folder) {
        this.folderErrors = [];
    }
    onMediaUploadSuccess({ uuid }) {
        this.reset();
        this.onUploadSuccess.emit(uuid);
    }
    onMediaUploadFail(response) {
        this.mediaBackendValidationHandler.handleResponse(response, this.fieldErrors);
        this.folderErrors = this.fieldErrors
            .filter((error) => error.subject === 'folder')
            .map((error) => error.message);
    }
    reset() {
        this.imageParams = null;
        this.fieldErrors = [];
        this.isUploading = false;
    }
};
MediaUploadFormComponent.$inject = ["cdr", "fileValidatorFactory", "mediaBackendValidationHandler", "mediaUploaderService", "mediaFolderService", "mediaUtilService"];
__decorate([
    core.Input(),
    __metadata("design:type", File)
], /* @ngInject */ MediaUploadFormComponent.prototype, "image", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaUploadFormComponent.prototype, "allowMediaType", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Number)
], /* @ngInject */ MediaUploadFormComponent.prototype, "maxUploadFileSize", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ MediaUploadFormComponent.prototype, "onCancel", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ MediaUploadFormComponent.prototype, "onSelect", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ MediaUploadFormComponent.prototype, "onUploadSuccess", void 0);
/* @ngInject */ MediaUploadFormComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-media-upload-form',
        template: `<div class="se-media-upload-form"><div class="se-media-upload-form__header"><div class="se-media-upload-form__header-content"><div class="se-media-upload-form__header-title" translate="se.upload.image.to.folder"></div><se-select id="se-media-upload-form__header-folder" class="se-media-upload-form__header-folder" [ngClass]="{ 'is-invalid': hasError() }" [multiSelect]="false" [controls]="false" [(model)]="folderSelected" (modelChange)="folderSelectedChanged($event)" [fetchStrategy]="folderFetchStrategy" [placeholder]="folderSelected"></se-select><div class="se-media-upload-form__header-actions"><button type="button" class="fd-button--light se-media-upload-btn__cancel fd-button--compact" translate="se.upload.image.cancel" (click)="cancel()"></button> <button type="button" class="fd-button se-media-upload-btn__submit fd-button--compact" translate="se.upload.image.submit" (click)="uploadMedia()"></button></div></div><div class="se-media-upload-form__header-error"><span class="upload-field-error fd-form__message fd-form__message--error" *ngFor="let error of folderErrors">{{ error | translate }}</span></div></div><div class="se-media-upload-form__replace-file"><div class="se-media-upload-form__file-name">{{ image.name }}</div><se-media-file-selector [labelI18nKey]="'se.upload.image.replace'" [acceptedFileTypes]="acceptedFileTypes" (onFileSelect)="onFileSelect($event)"></se-media-file-selector></div><form class="se-media-upload-form__file-info"><se-media-upload-field [fieldName]="'code'" [fieldValue]="imageParams?.code" [fieldErrors]="getErrorsForFieldByCode('code')" [isRequired]="true" [labelI18nKey]="'se.uploaded.image.code'" (fieldValueChange)="onChangeFieldValue($event, 'code')"></se-media-upload-field><se-media-upload-field [fieldName]="'description'" [fieldValue]="imageParams?.description" [fieldErrors]="getErrorsForFieldByCode('description')" [isRequired]="true" [labelI18nKey]="'se.uploaded.image.description'" (fieldValueChange)="onChangeFieldValue($event, 'description')"></se-media-upload-field><se-media-upload-field [fieldName]="'alt-text'" [fieldValue]="imageParams?.altText" [fieldErrors]="getErrorsForFieldByCode('altText')" [isRequired]="true" [labelI18nKey]="'se.uploaded.image.alt.text'" (fieldValueChange)="onChangeFieldValue($event, 'altText')"></se-media-upload-field></form><se-spinner [isSpinning]="isUploading"></se-spinner></div>`,
        styles: [`.se-media-upload-form{box-shadow:0 6px 12px rgba(0,0,0,.175);border-radius:4px}.se-media-upload-form__header{border-bottom:1px solid #d9d9d9;display:flex;flex-direction:column}.se-media-upload-form__header-content{display:flex;flex-direction:row;align-items:center;justify-content:space-between;height:53px;padding:20px}.se-media-upload-form__header-title{font-size:1.1428571429rem;line-height:1.25;font-weight:400;color:#32363a}.se-media-upload-form__header-folder{width:200px;margin-left:8px;margin-right:auto}.se-media-upload-form__header-error{padding-left:20px}.se-media-upload-form__replace-file{display:flex;flex-direction:row;align-items:center;justify-content:space-between;padding:16px 20px 0}.se-media-upload-form__file-name{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;max-width:80%}.se-media-upload-form__file-info{display:grid;grid-template-columns:repeat(2,1fr);grid-gap:16px;padding:20px}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [core.ChangeDetectorRef,
        smarteditcommons.FileValidatorFactory,
        MediaBackendValidationHandler,
        MediaUploaderService,
        MediaFolderService,
        MediaUtilService])
], /* @ngInject */ MediaUploadFormComponent);

window.__smartedit__.addDecoratorPayload("Component", "MediaUploadFieldComponent", {
    selector: 'se-media-upload-field',
    template: `<div class="se-media-upload__file-info-field" [ngClass]="getContainerClassName()"><label class="se-control-label" [ngClass]="{ 'se-media-upload-has-error': hasError(), required: isRequired }" [translate]="labelI18nKey"></label> <input type="text" [ngClass]="{ 'is-invalid': hasError() }" class="fd-form__control" [attr.name]="fieldName" [ngModel]="fieldValue" (ngModelChange)="onChangeValue($event)"/> <span class="upload-field-error fd-form__message fd-form__message--error" [ngClass]="getErrorClassName()" *ngFor="let error of fieldErrors">{{ error | translate }}</span></div>`,
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ MediaUploadFieldComponent = class /* @ngInject */ MediaUploadFieldComponent {
    constructor() {
        this.isRequired = false;
        this.fieldValueChange = new core.EventEmitter();
    }
    onChangeValue(value) {
        this.fieldValueChange.emit(value);
    }
    hasError() {
        var _a;
        return ((_a = this.fieldErrors) === null || _a === void 0 ? void 0 : _a.length) > 0;
    }
    getContainerClassName() {
        return `se-media-upload__file-info-field--${this.fieldName}`;
    }
    getErrorClassName() {
        return `upload-field-error--${this.fieldName}`;
    }
};
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaUploadFieldComponent.prototype, "fieldValue", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaUploadFieldComponent.prototype, "fieldName", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Array)
], /* @ngInject */ MediaUploadFieldComponent.prototype, "fieldErrors", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ MediaUploadFieldComponent.prototype, "isRequired", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ MediaUploadFieldComponent.prototype, "labelI18nKey", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", Object)
], /* @ngInject */ MediaUploadFieldComponent.prototype, "fieldValueChange", void 0);
/* @ngInject */ MediaUploadFieldComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-media-upload-field',
        template: `<div class="se-media-upload__file-info-field" [ngClass]="getContainerClassName()"><label class="se-control-label" [ngClass]="{ 'se-media-upload-has-error': hasError(), required: isRequired }" [translate]="labelI18nKey"></label> <input type="text" [ngClass]="{ 'is-invalid': hasError() }" class="fd-form__control" [attr.name]="fieldName" [ngModel]="fieldValue" (ngModelChange)="onChangeValue($event)"/> <span class="upload-field-error fd-form__message fd-form__message--error" [ngClass]="getErrorClassName()" *ngFor="let error of fieldErrors">{{ error | translate }}</span></div>`,
        changeDetection: core.ChangeDetectionStrategy.OnPush
    })
], /* @ngInject */ MediaUploadFieldComponent);

let MediaModule = class MediaModule {
};
MediaModule = __decorate([
    core.NgModule({
        imports: [
            smarteditcommons.TranslationModule.forChild(),
            common.CommonModule,
            forms.FormsModule,
            smarteditcommons.TooltipModule,
            smarteditcommons.SelectModule,
            smarteditcommons.SpinnerModule,
            smarteditcommons.GenericEditorDropdownModule,
            smarteditcommons.MessageModule
        ],
        providers: [
            MediaService,
            MediaUploaderService,
            MediaBackendValidationHandler,
            MediaFolderService,
            MediaUtilService,
            {
                provide: smarteditcommons.MEDIA_SELECTOR_I18N_KEY_TOKEN,
                useValue: smarteditcommons.MEDIA_SELECTOR_I18N_KEY
            },
            smarteditcommons.moduleUtils.bootstrap((_fileValidation) => { }, [smarteditcommons.IFileValidation])
        ],
        declarations: [
            MediaErrorsComponent,
            MediaFileSelectorComponent,
            MediaPreviewComponent,
            MediaAdvancedPropertiesComponent,
            MediaSelectorComponent,
            MediaPrinterComponent,
            MediaActionLabelComponent,
            MediaRemoveButtonComponent,
            MediaFormatComponent,
            MediaFormatUploadedComponent,
            MediaUploadFormComponent,
            MediaUploadFieldComponent,
            MediaComponent,
            MediaContainerComponent,
            MediaContainerSelectorComponent,
            MediaContainerSelectorItemComponent
        ],
        entryComponents: [
            MediaErrorsComponent,
            MediaFileSelectorComponent,
            MediaPreviewComponent,
            MediaAdvancedPropertiesComponent,
            MediaSelectorComponent,
            MediaPrinterComponent,
            MediaActionLabelComponent,
            MediaRemoveButtonComponent,
            MediaFormatComponent,
            MediaFormatUploadedComponent,
            MediaUploadFormComponent,
            MediaUploadFieldComponent,
            MediaComponent,
            MediaContainerComponent,
            MediaContainerSelectorItemComponent
        ]
    })
], MediaModule);

window.__smartedit__.addDecoratorPayload("Component", "MissingPrimaryContentPageComponent", {
    selector: 'se-component-missing-primary-content-page',
    template: `<div><div><label class="missing-primary-content-page-message__label" [translate]="'se.cms.page.restore.content.page.noprimaryforvariation.msg'"></label></div><se-select id="se-page-restore-change-primary-selector-dropdown" [(model)]="cmsPage.label" [fetchStrategy]="fetchStrategy"></se-select></div>`,
    styles: [`.missing-primary-content-page-message__label{font-style:italic;padding-bottom:10px;display:block}`]
});
let MissingPrimaryContentPageComponent = class MissingPrimaryContentPageComponent {
    constructor(data, pageService, logService) {
        this.data = data;
        this.pageService = pageService;
        this.logService = logService;
        this.CONTENT_PAGE_TYPE_CODE = 'ContentPage';
        this.ERROR_MSG = '[MissingPrimaryContentPageComponent] - Cannot retrieve list of alternative content primary pages.';
        ({ model: this.cmsPage } = data);
    }
    ngOnInit() {
        this.fetchStrategy = {
            fetchEntity: () => this.fetchEntity(),
            fetchPage: (search, pageSize, currentPage) => this.fetchPage(search, pageSize, currentPage)
        };
    }
    fetchEntity() {
        return Promise.resolve(this.getSelectItemFromPrimaryPage(this.cmsPage));
    }
    fetchPage(search, pageSize, currentPage) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const page = yield this.pageService.getPaginatedPrimaryPagesForPageType(this.CONTENT_PAGE_TYPE_CODE, null, {
                    search,
                    pageSize,
                    currentPage
                });
                const targetPage = {
                    pagination: page.pagination,
                    results: null
                };
                targetPage.results = page.response.map((rawPage) => this.getSelectItemFromPrimaryPage(rawPage));
                return targetPage;
            }
            catch (error) {
                this.logService.warn(this.ERROR_MSG, error);
            }
        });
    }
    getSelectItemFromPrimaryPage(page) {
        return {
            id: page.label,
            label: page.name
        };
    }
};
MissingPrimaryContentPageComponent = __decorate([
    core.Component({
        selector: 'se-component-missing-primary-content-page',
        template: `<div><div><label class="missing-primary-content-page-message__label" [translate]="'se.cms.page.restore.content.page.noprimaryforvariation.msg'"></label></div><se-select id="se-page-restore-change-primary-selector-dropdown" [(model)]="cmsPage.label" [fetchStrategy]="fetchStrategy"></se-select></div>`,
        styles: [`.missing-primary-content-page-message__label{font-style:italic;padding-bottom:10px;display:block}`]
    }),
    __param(0, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [Object, smarteditcommons.IPageService,
        smarteditcommons.LogService])
], MissingPrimaryContentPageComponent);

window.__smartedit__.addDecoratorPayload("Component", "DuplicatePrimaryNonContentPageComponent", {
    selector: 'se-component-duplicate-primary-non-content-page',
    template: `<div><label [translate]="label"></label></div>`
});
let DuplicatePrimaryNonContentPageComponent = class DuplicatePrimaryNonContentPageComponent {
    constructor(data) {
        this.data = data;
        this.PRODUCT_PAGE = 'ProductPage';
        this.labelI18nKeys = {
            restoreCategory: 'se.cms.page.restore.category.duplicate.primaryforvariation.error',
            restoreProduct: 'se.cms.page.restore.product.duplicate.primaryforvariation.error'
        };
        ({ model: this.page } = data);
    }
    ngOnInit() {
        this.page.replace = true;
        this.label =
            this.page.typeCode === this.PRODUCT_PAGE
                ? this.labelI18nKeys.restoreProduct
                : this.labelI18nKeys.restoreCategory;
    }
};
DuplicatePrimaryNonContentPageComponent = __decorate([
    core.Component({
        selector: 'se-component-duplicate-primary-non-content-page',
        template: `<div><label [translate]="label"></label></div>`
    }),
    __param(0, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [Object])
], DuplicatePrimaryNonContentPageComponent);

window.__smartedit__.addDecoratorPayload("Component", "DuplicatePrimaryContentPageLabelComponent", {
    selector: 'se-component-duplicate-primary-content-page-label',
    template: `<div><div class="fd-form__item fd-form__item--check"><input class="fd-form__control" type="radio" name="duplicateResolution" id="overwritePrimaryPageOption" [(ngModel)]="conflictResolution" (click)="selectResolution(RESOLUTION_OPTIONS.overwritePage)" [value]="RESOLUTION_OPTIONS.overwritePage"/> <label for="overwritePrimaryPageOption" class="fd-form__label" [translate]="'se.cms.page.restore.content.duplicate.primaryforvariation.option.overwrite'"></label></div><div class="fd-form__item fd-form__item--check"><input class="fd-form__control" type="radio" name="duplicateResolution" id="renamePrimaryPageOption" [(ngModel)]="conflictResolution" (click)="selectResolution(RESOLUTION_OPTIONS.renamePageLabel)" [value]="RESOLUTION_OPTIONS.renamePageLabel"/> <label for="renamePrimaryPageOption" class="fd-form__label" [translate]="'se.cms.page.restore.content.duplicate.primaryforvariation.option.rename'"></label></div><div class="rename-label-section" *ngIf="conflictResolution === RESOLUTION_OPTIONS.renamePageLabel"><label [translate]="'se.cms.page.restore.page.label'"></label> <input type="text" class="form-control" [(ngModel)]="page['label']"/></div></div>`,
    styles: [`.rename-label-section{display:block}`]
});
let DuplicatePrimaryContentPageLabelComponent = class DuplicatePrimaryContentPageLabelComponent {
    constructor(data) {
        this.data = data;
        this.conflictResolution = null;
        this.RESOLUTION_OPTIONS = {
            overwritePage: 1,
            renamePageLabel: 2
        };
        ({ model: this.page } = data);
        this.conflictResolution = this.RESOLUTION_OPTIONS.overwritePage;
        this.page.replace = true;
    }
    selectResolution(resolutionSelected) {
        this.page.replace = resolutionSelected === this.RESOLUTION_OPTIONS.overwritePage;
    }
};
DuplicatePrimaryContentPageLabelComponent = __decorate([
    core.Component({
        selector: 'se-component-duplicate-primary-content-page-label',
        template: `<div><div class="fd-form__item fd-form__item--check"><input class="fd-form__control" type="radio" name="duplicateResolution" id="overwritePrimaryPageOption" [(ngModel)]="conflictResolution" (click)="selectResolution(RESOLUTION_OPTIONS.overwritePage)" [value]="RESOLUTION_OPTIONS.overwritePage"/> <label for="overwritePrimaryPageOption" class="fd-form__label" [translate]="'se.cms.page.restore.content.duplicate.primaryforvariation.option.overwrite'"></label></div><div class="fd-form__item fd-form__item--check"><input class="fd-form__control" type="radio" name="duplicateResolution" id="renamePrimaryPageOption" [(ngModel)]="conflictResolution" (click)="selectResolution(RESOLUTION_OPTIONS.renamePageLabel)" [value]="RESOLUTION_OPTIONS.renamePageLabel"/> <label for="renamePrimaryPageOption" class="fd-form__label" [translate]="'se.cms.page.restore.content.duplicate.primaryforvariation.option.rename'"></label></div><div class="rename-label-section" *ngIf="conflictResolution === RESOLUTION_OPTIONS.renamePageLabel"><label [translate]="'se.cms.page.restore.page.label'"></label> <input type="text" class="form-control" [(ngModel)]="page['label']"/></div></div>`,
        styles: [`.rename-label-section{display:block}`]
    }),
    __param(0, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [Object])
], DuplicatePrimaryContentPageLabelComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageTypeEditorComponent", {
    selector: 'se-page-type-editor',
    template: `<div class="se-edit-page-info__basic-tab"><div class="se-edit-page-info__page-type"><label class="se-control-label" translate="se.cms.pageinfo.page.type"></label><div class="form-readonly-text form-readonly-text__tight">{{ model.typeCode }}</div></div><div class="se-edit-page-info__page-template"><label class="se-control-label" translate="se.cms.pageinfo.page.template"></label><div class="form-readonly-text form-readonly-text__tight">{{ model.template }}</div></div></div>`,
    styles: [`.se-edit-page-info__basic-tab{display:grid;grid-template-columns:repeat(1,1fr)}`]
});
let PageTypeEditorComponent = class PageTypeEditorComponent {
    constructor(data) {
        ({ model: this.model } = data);
    }
};
PageTypeEditorComponent = __decorate([
    core.Component({
        selector: 'se-page-type-editor',
        template: `<div class="se-edit-page-info__basic-tab"><div class="se-edit-page-info__page-type"><label class="se-control-label" translate="se.cms.pageinfo.page.type"></label><div class="form-readonly-text form-readonly-text__tight">{{ model.typeCode }}</div></div><div class="se-edit-page-info__page-template"><label class="se-control-label" translate="se.cms.pageinfo.page.template"></label><div class="form-readonly-text form-readonly-text__tight">{{ model.template }}</div></div></div>`,
        styles: [`.se-edit-page-info__basic-tab{display:grid;grid-template-columns:repeat(1,1fr)}`]
    }),
    __param(0, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [Object])
], PageTypeEditorComponent);

window.__smartedit__.addDecoratorPayload("Component", "RestrictionsListComponent", {
    selector: 'se-restrictions-list',
    template: `<div class="restrictions-list"><div class="restrictions-list__info"><label translate="se.cms.restrictions.criteria"></label> <span>&nbsp;{{ pageInfo.restrictionsCriteria }}</span></div><div class="restrictions-list__items" *ngFor="let restriction of restrictions"><div class="restrictions-list__item"><div class="restrictions-list__item-name">{{ restriction.name }}</div><div class="restrictions-list__item-type">{{ restriction.type | seL10n | async }}</div><div class="restrictions-list__item-description">{{ restriction.description }}</div></div></div></div>`
});
let RestrictionsListComponent = class RestrictionsListComponent {
    constructor(data, cmsitemsRestService, cdr) {
        this.data = data;
        this.cmsitemsRestService = cmsitemsRestService;
        this.cdr = cdr;
        ({ model: this.pageInfo } = data);
        this.restrictions = [];
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const restrictionsData = yield this.cmsitemsRestService.getByIdsNoCache(this.pageInfo.restrictions, 'FULL');
            this.restrictions = (restrictionsData.response
                ? restrictionsData.response
                : [restrictionsData]);
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
};
RestrictionsListComponent = __decorate([
    core.Component({
        selector: 'se-restrictions-list',
        template: `<div class="restrictions-list"><div class="restrictions-list__info"><label translate="se.cms.restrictions.criteria"></label> <span>&nbsp;{{ pageInfo.restrictionsCriteria }}</span></div><div class="restrictions-list__items" *ngFor="let restriction of restrictions"><div class="restrictions-list__item"><div class="restrictions-list__item-name">{{ restriction.name }}</div><div class="restrictions-list__item-type">{{ restriction.type | seL10n | async }}</div><div class="restrictions-list__item-description">{{ restriction.description }}</div></div></div></div>`
    }),
    __param(0, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [Object, smarteditcommons.CmsitemsRestService,
        core.ChangeDetectorRef])
], RestrictionsListComponent);

window.__smartedit__.addDecoratorPayload("Component", "SingeActiveCatalogAwareItemSelectorItemRendererComponent", {
    selector: 'se-single-active-catalog-aware-item-selector-item-renderer',
    template: `
        <span class="se-single-catalog-item">
            <span
                class="se-single-catalog-item__label"
                title="{{ data.item.label | seL10n | async }}"
                >{{ data.item.label | seL10n | async }}</span
            >
            <span
                class="se-single-catalog-item__code"
                title="{{ data.item.code | seL10n | async }}"
            >
                {{ data.item.code }}</span
            >
            <span
                class="se-single-catalog-item__version"
                title="{{ data.item.catalogId | seL10n | async }}"
                >{{ data.item.catalogId }}</span
            >
        </span>
    `
});
let SingeActiveCatalogAwareItemSelectorItemRendererComponent = class SingeActiveCatalogAwareItemSelectorItemRendererComponent {
    constructor(data) {
        this.data = data;
    }
};
SingeActiveCatalogAwareItemSelectorItemRendererComponent = __decorate([
    core.Component({
        selector: 'se-single-active-catalog-aware-item-selector-item-renderer',
        template: `
        <span class="se-single-catalog-item">
            <span
                class="se-single-catalog-item__label"
                title="{{ data.item.label | seL10n | async }}"
                >{{ data.item.label | seL10n | async }}</span
            >
            <span
                class="se-single-catalog-item__code"
                title="{{ data.item.code | seL10n | async }}"
            >
                {{ data.item.code }}</span
            >
            <span
                class="se-single-catalog-item__version"
                title="{{ data.item.catalogId | seL10n | async }}"
                >{{ data.item.catalogId }}</span
            >
        </span>
    `
    }),
    __param(0, core.Inject(smarteditcommons.ITEM_COMPONENT_DATA_TOKEN)),
    __metadata("design:paramtypes", [Object])
], SingeActiveCatalogAwareItemSelectorItemRendererComponent);

var SINGLE_CATALOG_AWARE_ITEM_MAPPING;
(function (SINGLE_CATALOG_AWARE_ITEM_MAPPING) {
    SINGLE_CATALOG_AWARE_ITEM_MAPPING["SingleOnlineProductSelector"] = "product";
    SINGLE_CATALOG_AWARE_ITEM_MAPPING["SingleOnlineCategorySelector"] = "category";
})(SINGLE_CATALOG_AWARE_ITEM_MAPPING || (SINGLE_CATALOG_AWARE_ITEM_MAPPING = {}));
window.__smartedit__.addDecoratorPayload("Component", "SingleActiveCatalogAwareItemSelectorComponent", {
    selector: 'se-single-active-catalog-aware-item-selector',
    template: `<div *ngIf="propertyType"><div id="product-catalog"><label class="se-control-label" [ngClass]="{ 'required': field.required }" *ngIf="catalogs.length === 1">{{ catalogName | seL10n | async }}</label><se-generic-editor-dropdown id="se-catalog-selector-dropdown" *ngIf="catalogs.length > 1" [field]="productCatalogField" [qualifier]="'productCatalog'" [model]="model"></se-generic-editor-dropdown></div><div><label class="se-control-label" [translate]="mainDropDownI18nKey"></label><se-generic-editor-dropdown id="se-items-selector-dropdown" [field]="field" [qualifier]="qualifier" [model]="model" [itemComponent]="itemComponent" [(reset)]="reset"></se-generic-editor-dropdown></div></div><div class="product-catalog-item-type-missing" *ngIf="!propertyType" translate="se.cms.catalogawareitem.itemtype.notsupported"></div>`,
    styles: [`se-single-active-catalog-aware-item-selector .se-single-catalog-item{display:grid;grid-template-columns:2fr 1fr 2fr;grid-column-gap:1rem}se-single-active-catalog-aware-item-selector .se-single-catalog-item__code,se-single-active-catalog-aware-item-selector .se-single-catalog-item__label,se-single-active-catalog-aware-item-selector .se-single-catalog-item__version{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}se-single-active-catalog-aware-item-selector .selected-item>.se-item-printer{width:100%;padding-right:12px}`],
    encapsulation: core.ViewEncapsulation.None
});
let SingleActiveCatalogAwareItemSelectorComponent = class SingleActiveCatalogAwareItemSelectorComponent {
    constructor(data, catalogService) {
        this.data = data;
        this.catalogService = catalogService;
        ({
            editor: this.editor,
            field: this.field,
            model: this.model,
            qualifier: this.qualifier
        } = this.data);
        this.catalogName = {};
        this.catalogs = [];
        this.itemComponent = SingeActiveCatalogAwareItemSelectorItemRendererComponent;
        this.initProductCatalog = this.model.productCatalog;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.augmentDropdownAttributes();
            return this.initProductCatalogs();
        });
    }
    ngDoCheck() {
        if (this.catalogs.length > 1 && this.initProductCatalog !== this.model.productCatalog) {
            this.initProductCatalog = this.model.productCatalog;
            this.resetSelector();
        }
    }
    augmentDropdownAttributes() {
        this.propertyType = this.getFieldPropertyType(this.field);
        if (this.propertyType) {
            this.productCatalogField = {
                idAttribute: 'catalogId',
                labelAttributes: ['name'],
                editable: this.field.editable,
                propertyType: 'productCatalog'
            };
            this.mainDropDownI18nKey = this.field.i18nKey;
            delete this.field.i18nKey;
            this.field.paged = true;
            this.field.idAttribute = 'uid';
            this.field.labelAttributes = ['name'];
            this.field.dependsOn = 'productCatalog';
            this.field.propertyType = this.propertyType;
        }
    }
    initProductCatalogs() {
        return __awaiter(this, void 0, void 0, function* () {
            const catalogs = yield this.catalogService.getProductCatalogsBySiteKey(cmscommons.CONTEXT_SITE_ID);
            this.catalogs = catalogs;
            if (this.catalogs.length === 1) {
                this.model.productCatalog = this.catalogs[0].catalogId;
                this.editor.form.pristine.productCatalog = this.catalogs[0].catalogId;
                this.catalogName = this.catalogs[0].name;
            }
        });
    }
    getFieldPropertyType(field) {
        const type = field.cmsStructureType;
        return SINGLE_CATALOG_AWARE_ITEM_MAPPING[type];
    }
    resetSelector() {
        if (typeof this.reset === 'function') {
            this.reset(true);
        }
    }
};
SingleActiveCatalogAwareItemSelectorComponent = __decorate([
    core.Component({
        selector: 'se-single-active-catalog-aware-item-selector',
        template: `<div *ngIf="propertyType"><div id="product-catalog"><label class="se-control-label" [ngClass]="{ 'required': field.required }" *ngIf="catalogs.length === 1">{{ catalogName | seL10n | async }}</label><se-generic-editor-dropdown id="se-catalog-selector-dropdown" *ngIf="catalogs.length > 1" [field]="productCatalogField" [qualifier]="'productCatalog'" [model]="model"></se-generic-editor-dropdown></div><div><label class="se-control-label" [translate]="mainDropDownI18nKey"></label><se-generic-editor-dropdown id="se-items-selector-dropdown" [field]="field" [qualifier]="qualifier" [model]="model" [itemComponent]="itemComponent" [(reset)]="reset"></se-generic-editor-dropdown></div></div><div class="product-catalog-item-type-missing" *ngIf="!propertyType" translate="se.cms.catalogawareitem.itemtype.notsupported"></div>`,
        styles: [`se-single-active-catalog-aware-item-selector .se-single-catalog-item{display:grid;grid-template-columns:2fr 1fr 2fr;grid-column-gap:1rem}se-single-active-catalog-aware-item-selector .se-single-catalog-item__code,se-single-active-catalog-aware-item-selector .se-single-catalog-item__label,se-single-active-catalog-aware-item-selector .se-single-catalog-item__version{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}se-single-active-catalog-aware-item-selector .selected-item>.se-item-printer{width:100%;padding-right:12px}`],
        encapsulation: core.ViewEncapsulation.None
    }),
    __param(0, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [Object, smarteditcommons.ICatalogService])
], SingleActiveCatalogAwareItemSelectorComponent);

var CloneAction;
(function (CloneAction) {
    CloneAction["clone"] = "clone";
    CloneAction["useExisting"] = "reference";
    CloneAction["remove"] = "remove";
})(CloneAction || (CloneAction = {}));
window.__smartedit__.addDecoratorPayload("Component", "SlotSharedCloneActionFieldComponent", {
    selector: 'se-component-slot-shared-clone-action-field',
    template: `<div class="fd-form__set"><div class="fd-form__item fd-form__item--check"><label for="components-in-slot-options" class="se-control-label" [translate]="'se.cms.slot.shared.replace.editor.componentsinslot'"></label><div id="components-in-slot-options"><div class="se-form-control-row"><input class="fd-form__control" type="radio" name="componentsInSlot" id="clone-all" [(ngModel)]="page.cloneAction" [value]="cloneAction.clone"/> <label for="clone-all" [translate]="'se.cms.slot.shared.replace.editor.componentsinslot.cloneall'"></label></div><div class="se-form-control-row"><input class="fd-form__control" type="radio" name="componentsInSlot" id="use-existing" [(ngModel)]="page.cloneAction" [value]="cloneAction.useExisting"/> <label for="use-existing" [translate]="'se.cms.slot.shared.replace.editor.componentsinslot.useexisting'"></label></div><div class="se-form-control-row"><input class="fd-form__control" type="radio" name="componentsInSlot" id="remove-all" [(ngModel)]="page.cloneAction" [value]="cloneAction.remove"/> <label for="remove-all" [translate]="'se.cms.slot.shared.replace.editor.componentsinslot.removeall'"></label></div></div></div></div>`,
    styles: [`slot-shared-clone-action-field .fd-form__item--check{display:flex;align-items:baseline;flex-direction:column}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let SlotSharedCloneActionFieldComponent = class SlotSharedCloneActionFieldComponent {
    constructor(data) {
        this.data = data;
        this.cloneAction = CloneAction;
        ({ model: this.page } = data);
    }
};
SlotSharedCloneActionFieldComponent = __decorate([
    core.Component({
        selector: 'se-component-slot-shared-clone-action-field',
        template: `<div class="fd-form__set"><div class="fd-form__item fd-form__item--check"><label for="components-in-slot-options" class="se-control-label" [translate]="'se.cms.slot.shared.replace.editor.componentsinslot'"></label><div id="components-in-slot-options"><div class="se-form-control-row"><input class="fd-form__control" type="radio" name="componentsInSlot" id="clone-all" [(ngModel)]="page.cloneAction" [value]="cloneAction.clone"/> <label for="clone-all" [translate]="'se.cms.slot.shared.replace.editor.componentsinslot.cloneall'"></label></div><div class="se-form-control-row"><input class="fd-form__control" type="radio" name="componentsInSlot" id="use-existing" [(ngModel)]="page.cloneAction" [value]="cloneAction.useExisting"/> <label for="use-existing" [translate]="'se.cms.slot.shared.replace.editor.componentsinslot.useexisting'"></label></div><div class="se-form-control-row"><input class="fd-form__control" type="radio" name="componentsInSlot" id="remove-all" [(ngModel)]="page.cloneAction" [value]="cloneAction.remove"/> <label for="remove-all" [translate]="'se.cms.slot.shared.replace.editor.componentsinslot.removeall'"></label></div></div></div></div>`,
        styles: [`slot-shared-clone-action-field .fd-form__item--check{display:flex;align-items:baseline;flex-direction:column}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(0, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [Object])
], SlotSharedCloneActionFieldComponent);

window.__smartedit__.addDecoratorPayload("Component", "SlotSharedSlotTypeFieldComponent", {
    selector: 'se-component-slot-shared-slot-type-field',
    template: `<div class="fd-form__set"><div class="fd-form__item fd-form__item--check"><label for="slot-replacement-type-options" class="se-control-label" [translate]="'se.cms.slot.shared.replace.editor.slotreplacementtype'"></label><div id="slot-replacement-type-options"><div class="se-form-control-row"><input class="fd-form__control" type="radio" name="slotReplacementType" id="slot-type-custom" [(ngModel)]="page.isSlotCustom" [value]="true"/> <label for="slot-type-custom" [translate]="'se.cms.slot.shared.replace.editor.slotreplacementtype.nonshared'"></label></div><div class="se-form-control-row"><input class="fd-form__control" type="radio" name="slotReplacementType" id="slot-type-local" [(ngModel)]="page.isSlotCustom" [value]="false"/> <label for="slot-type-local" [translate]="'se.cms.slot.shared.replace.editor.slotreplacementtype.local'"></label></div></div></div></div>`,
    styles: [`slot-shared-slot-type-field .fd-form__item--check{display:flex;align-items:baseline;flex-direction:column}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let SlotSharedSlotTypeFieldComponent = class SlotSharedSlotTypeFieldComponent {
    constructor(data) {
        this.data = data;
        ({ model: this.page } = data);
    }
};
SlotSharedSlotTypeFieldComponent = __decorate([
    core.Component({
        selector: 'se-component-slot-shared-slot-type-field',
        template: `<div class="fd-form__set"><div class="fd-form__item fd-form__item--check"><label for="slot-replacement-type-options" class="se-control-label" [translate]="'se.cms.slot.shared.replace.editor.slotreplacementtype'"></label><div id="slot-replacement-type-options"><div class="se-form-control-row"><input class="fd-form__control" type="radio" name="slotReplacementType" id="slot-type-custom" [(ngModel)]="page.isSlotCustom" [value]="true"/> <label for="slot-type-custom" [translate]="'se.cms.slot.shared.replace.editor.slotreplacementtype.nonshared'"></label></div><div class="se-form-control-row"><input class="fd-form__control" type="radio" name="slotReplacementType" id="slot-type-local" [(ngModel)]="page.isSlotCustom" [value]="false"/> <label for="slot-type-local" [translate]="'se.cms.slot.shared.replace.editor.slotreplacementtype.local'"></label></div></div></div></div>`,
        styles: [`slot-shared-slot-type-field .fd-form__item--check{display:flex;align-items:baseline;flex-direction:column}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(0, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [Object])
], SlotSharedSlotTypeFieldComponent);

var ThumbnailSelectOption;
(function (ThumbnailSelectOption) {
    ThumbnailSelectOption["uploadThumbnail"] = "UPLOAD_THUMBNAIL";
    ThumbnailSelectOption["noThumbnail"] = "NO_THUMBNAIL";
})(ThumbnailSelectOption || (ThumbnailSelectOption = {}));
window.__smartedit__.addDecoratorPayload("Component", "ThumbnailSelectComponent", {
    selector: 'se-thumbnail-select',
    template: `<se-generic-editor-dropdown [id]="id" [field]="field" [qualifier]="qualifier" [model]="model"></se-generic-editor-dropdown>`
});
let ThumbnailSelectComponent = class ThumbnailSelectComponent {
    constructor(systemEventService, widget) {
        this.systemEventService = systemEventService;
        this.widget = widget;
        ({ id: this.id, field: this.field, model: this.model, qualifier: this.qualifier } = widget);
        if (this.field.dependsOnField) {
            const onDependsOnValueChangedEventName = `${this.id}${this.field.dependsOnField}${smarteditcommons.CLICK_DROPDOWN}`;
            this.unRegDependsOnValueChanged = this.systemEventService.subscribe(onDependsOnValueChangedEventName, (_eventId, data) => this.onDependsOnValueChanged(data));
        }
        this.optionEventId = `${this.id}${this.qualifier}${smarteditcommons.CLICK_DROPDOWN}`;
        const onSelectValueChangedEventName = `${this.id}${smarteditcommons.LINKED_DROPDOWN}`;
        this.unRegSelectValueChanged = this.systemEventService.subscribe(onSelectValueChangedEventName, (_eventId, data) => this.onThumbnailSelectValueChanged(data));
    }
    ngOnDestroy() {
        this.unRegSelectValueChanged();
        this.unRegDependsOnValueChanged();
    }
    onThumbnailSelectValueChanged({ optionObject: option, qualifier }) {
        if (this.qualifier !== qualifier) {
            return;
        }
        if (!option) {
            return;
        }
        const optionValue = option.id;
        const selectedOption = Object.values(ThumbnailSelectOption).includes(optionValue);
        if (!selectedOption) {
            throw new Error('Selected option is not supported');
        }
        if (!this.field.hideFieldWidget) {
            this.systemEventService.publishAsync(this.optionEventId, optionValue);
        }
    }
    onDependsOnValueChanged(data) {
        this.field.hideFieldWidget = data !== this.field.dependsOnValue;
        if (this.field.hideFieldWidget) {
            this.systemEventService.publishAsync(this.optionEventId, null);
        }
        else {
            this.systemEventService.publishAsync(this.optionEventId, this.model[this.qualifier]);
        }
    }
};
ThumbnailSelectComponent = __decorate([
    core.Component({
        selector: 'se-thumbnail-select',
        template: `<se-generic-editor-dropdown [id]="id" [field]="field" [qualifier]="qualifier" [model]="model"></se-generic-editor-dropdown>`
    }),
    __param(1, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [smarteditcommons.SystemEventService, Object])
], ThumbnailSelectComponent);

window.__smartedit__.addDecoratorPayload("Component", "MuteBooleanComponent", {
    selector: 'se-mute-boolean',
    template: `<div class="se-boolean fd-form__item fd-form__item--check"><span class="fd-toggle fd-toggle--xs fd-form__control"><label class="fd-form__label" for="{{widget.qualifier}}-checkbox"><input type="checkbox" id="{{widget.qualifier}}-checkbox" class="se-boolean__input" [placeholder]="(widget.field.tooltip || '') | translate" [attr.name]="widget.qualifier" [disabled]="!widget.field.editable" [(ngModel)]="widget.model[widget.qualifier]"/> <span class="fd-toggle__switch" role="presentation"></span></label></span><p *ngIf="widget.field.labelText && !widget.model[widget.qualifier]" class="se-boolean__text">{{widget.field.labelText| translate}}</p></div>`
});
let MuteBooleanComponent = class MuteBooleanComponent {
    constructor(systemEventService, widget) {
        this.systemEventService = systemEventService;
        this.widget = widget;
        if (this.widget.field.dependsOnField) {
            this.widget.field.hideFieldWidget = true;
            const onClickEventName = `${this.widget.id}${this.widget.field.dependsOnField}${smarteditcommons.CLICK_DROPDOWN}`;
            this.unRegClickValueChanged = this.systemEventService.subscribe(onClickEventName, (eventId, data) => this.onDependencyValueChangedEvent(data));
        }
    }
    onDependencyValueChangedEvent(checked) {
        this.widget.field.hideFieldWidget = checked !== this.widget.field.dependsOnValue;
        if (this.widget.field.hideFieldWidget) {
            this.widget.model[this.widget.qualifier] = false;
        }
    }
};
MuteBooleanComponent = __decorate([
    core.Component({
        selector: 'se-mute-boolean',
        template: `<div class="se-boolean fd-form__item fd-form__item--check"><span class="fd-toggle fd-toggle--xs fd-form__control"><label class="fd-form__label" for="{{widget.qualifier}}-checkbox"><input type="checkbox" id="{{widget.qualifier}}-checkbox" class="se-boolean__input" [placeholder]="(widget.field.tooltip || '') | translate" [attr.name]="widget.qualifier" [disabled]="!widget.field.editable" [(ngModel)]="widget.model[widget.qualifier]"/> <span class="fd-toggle__switch" role="presentation"></span></label></span><p *ngIf="widget.field.labelText && !widget.model[widget.qualifier]" class="se-boolean__text">{{widget.field.labelText| translate}}</p></div>`
    }),
    __param(1, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [smarteditcommons.SystemEventService, Object])
], MuteBooleanComponent);

window.__smartedit__.addDecoratorPayload("Component", "WorkflowCreateVersionFieldComponent", {
    selector: 'se-workflow-create-version-field',
    template: `<div class="fd-form__set"><div class="fd-form__item fd-form__item--check"><label class="fd-form__label"><input type="checkbox" class="fd-form__control" name="createVersion" [(ngModel)]="model.createVersion"/> {{ 'se.cms.workflow.editor.create.version' | translate }}</label></div><div class="fd-form__item" *ngIf="model.createVersion"><label class="fd-form__label version-label__title" for="versionLabel" translate="se.cms.workflow.editor.create.version.label"></label> <input type="text" name="versionLabel" class="fd-form__control" [class.has-error]="field.hasErrors" [(ngModel)]="model.versionLabel"/></div></div>`,
    providers: [smarteditcommons.L10nPipe],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let WorkflowCreateVersionFieldComponent = class WorkflowCreateVersionFieldComponent {
    constructor(workflowService, data, cdr, l10nPipe) {
        this.workflowService = workflowService;
        this.data = data;
        this.cdr = cdr;
        this.l10nPipe = l10nPipe;
        ({ field: this.field, model: this.model, editor: this.editor } = data);
    }
    ngOnInit() {
        this.unregisterOnChangeEvent = this.editor.api.addContentChangeEvent(() => this.onCreateVersionChange());
    }
    ngOnDestroy() {
        this.unregisterOnChangeEvent();
    }
    onCreateVersionChange() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.model.createVersion === false) {
                this.model.versionLabel = null;
                if (!this.cdr.destroyed) {
                    this.cdr.detectChanges();
                }
                return;
            }
            if (!lodash.isEmpty(this.model.versionLabel)) {
                return;
            }
            if (this.model.decisionCode) {
                const workflowActions = yield this.workflowService.getAllActionsForWorkflowCode(this.model.workflowCode);
                const workflowAction = workflowActions.find((action) => action.code === this.model.actionCode);
                const workflowDecision = workflowAction.decisions.find((decision) => decision.code === this.model.decisionCode);
                const [workflowDecisionName, workflowActionName] = yield Promise.all([
                    this.l10nPipe.transform(workflowDecision.name).pipe(operators.take(1)).toPromise(),
                    this.l10nPipe.transform(workflowAction.name).pipe(operators.take(1)).toPromise()
                ]);
                this.model.versionLabel = `${workflowDecisionName} for ${workflowActionName}`;
                if (!this.cdr.destroyed) {
                    this.cdr.detectChanges();
                }
                return;
            }
            const workflow = yield this.workflowService.getWorkflowTemplateByCode(this.model.templateCode);
            if (workflow) {
                const workflowName = yield this.l10nPipe
                    .transform(workflow.name)
                    .pipe(operators.take(1))
                    .toPromise();
                this.model.versionLabel = `${workflowName} workflow started`;
                if (!this.cdr.destroyed) {
                    this.cdr.detectChanges();
                }
            }
        });
    }
};
WorkflowCreateVersionFieldComponent = __decorate([
    core.Component({
        selector: 'se-workflow-create-version-field',
        template: `<div class="fd-form__set"><div class="fd-form__item fd-form__item--check"><label class="fd-form__label"><input type="checkbox" class="fd-form__control" name="createVersion" [(ngModel)]="model.createVersion"/> {{ 'se.cms.workflow.editor.create.version' | translate }}</label></div><div class="fd-form__item" *ngIf="model.createVersion"><label class="fd-form__label version-label__title" for="versionLabel" translate="se.cms.workflow.editor.create.version.label"></label> <input type="text" name="versionLabel" class="fd-form__control" [class.has-error]="field.hasErrors" [(ngModel)]="model.versionLabel"/></div></div>`,
        providers: [smarteditcommons.L10nPipe],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __param(1, core.Inject(smarteditcommons.GENERIC_EDITOR_WIDGET_DATA)),
    __metadata("design:paramtypes", [smarteditcommons.WorkflowService, Object, core.ChangeDetectorRef,
        smarteditcommons.L10nPipe])
], WorkflowCreateVersionFieldComponent);

let /* @ngInject */ CmsGenericEditorConfigurationService = class /* @ngInject */ CmsGenericEditorConfigurationService {
    constructor(editorFieldMappingService, genericEditorTabService) {
        this.editorFieldMappingService = editorFieldMappingService;
        this.genericEditorTabService = genericEditorTabService;
        this.DEFAULT_PAGE_TAB_ID = 'information';
        this.CATEGORIES = {
            PAGE: 'PAGE',
            COMPONENT: 'COMPONENT'
        };
        this.defaultTabPredicate = (componentTypeStructure) => componentTypeStructure.category === this.CATEGORIES.PAGE ? this.DEFAULT_PAGE_TAB_ID : null;
        this.isPagePredicate = (componentType, field, componentTypeStructure) => componentTypeStructure.category === this.CATEGORIES.PAGE;
        this.isComponentPredicate = (componentType, field, componentTypeStructure) => componentTypeStructure.category === this.CATEGORIES.COMPONENT;
    }
    setDefaultEditorFieldMappings() {
        this.editorFieldMappingService.addFieldMapping('Media', null, null, {
            component: MediaComponent
        });
        this.editorFieldMappingService.addFieldMapping('MediaContainer', null, null, {
            component: MediaContainerComponent
        });
        this.editorFieldMappingService.addFieldMapping('NavigationNodeSelector', null, null, {
            component: NavigationNodeSelectorComponent
        });
        this.editorFieldMappingService.addFieldMapping('MultiProductSelector', null, null, {
            component: MultiProductSelectorComponent
        });
        this.editorFieldMappingService.addFieldMapping('MultiCategorySelector', null, null, {
            component: MultiCategorySelectorComponent
        });
        this.editorFieldMappingService.addFieldMapping('CMSLinkToSelect', null, null, {
            component: CmsLinkToSelectComponent
        });
        this.editorFieldMappingService.addFieldMapping('OptionalCMSLinkToSelect', null, null, {
            component: CmsLinkToSelectComponent,
            tooltip: 'se.cms.linkto.tooltip'
        });
        this.editorFieldMappingService.addFieldMapping('SingleOnlineProductSelector', null, null, {
            component: SingleActiveCatalogAwareItemSelectorComponent
        });
        this.editorFieldMappingService.addFieldMapping('SingleOnlineCategorySelector', null, null, {
            component: SingleActiveCatalogAwareItemSelectorComponent
        });
        this.editorFieldMappingService.addFieldMapping('CMSItemDropdown', null, null, {
            component: exports.CmsComponentDropdownComponent
        });
        this.editorFieldMappingService.addFieldMapping('CMSComponentRestrictionsEditor', null, null, {
            component: exports.ComponentRestrictionsEditorComponent
        });
        this.editorFieldMappingService.addFieldMapping('PageRestrictionsEditor', null, 'restrictions', {
            component: exports.PageRestrictionsEditorComponent
        });
        // for editing modal only, not used for create/clone
        this.editorFieldMappingService.addFieldMapping('DisplayConditionEditor', null, 'displayCondition', {
            component: DisplayConditionsEditorComponent,
            hidePrefixLabel: true
        });
        this.editorFieldMappingService.addFieldMapping('ShortString', this.isPagePredicate, 'typeCode', {
            component: PageTypeEditorComponent,
            hidePrefixLabel: true
        });
        this.editorFieldMappingService.addFieldMapping('InfoPageName', this.isPagePredicate, null, {
            component: InfoPageNameComponent
        });
        this.editorFieldMappingService.addFieldMapping('Boolean', null, 'visible', {
            component: smarteditcommons.BooleanComponent,
            i18nKey: 'type.component.abstractcmscomponent.visible.name'
        });
        this.editorFieldMappingService.addFieldMapping('LinkToggle', null, null, {
            component: LinkToggleComponent
        });
        this.editorFieldMappingService.addFieldMapping('RestrictionsList', null, null, {
            component: RestrictionsListComponent,
            hidePrefixLabel: true
        });
        this.editorFieldMappingService.addFieldMapping('Video', null, null, {
            component: MediaComponent,
            allowMediaType: smarteditcommons.GenericEditorMediaType.VIDEO,
            tooltip: 'se.cms.video.tooltip'
        });
        this.editorFieldMappingService.addFieldMapping('VideoMute', null, null, {
            component: MuteBooleanComponent,
            hideFieldWidget: true,
            dependsOnField: 'autoPlay',
            dependsOnValue: 'true'
        });
        this.editorFieldMappingService.addFieldMapping('VideoThumbnailSelector', null, null, {
            component: ThumbnailSelectComponent,
            hideFieldWidget: false,
            dependsOnField: 'autoPlay',
            dependsOnValue: 'false'
        });
        this.editorFieldMappingService.addFieldMapping('Thumbnail', null, null, {
            component: MediaContainerComponent,
            hideFieldWidget: true,
            hidePrefixLabel: true,
            dependsOnField: 'thumbnailSelector',
            dependsOnValue: ThumbnailSelectOption.uploadThumbnail,
            allowMediaType: smarteditcommons.GenericEditorMediaType.IMAGE
        });
        this.editorFieldMappingService.addFieldMapping('PDFFile', null, null, {
            component: MediaComponent,
            allowMediaType: smarteditcommons.GenericEditorMediaType.PDF_DOCUMENT
        });
        // Page restore widgets.
        this.editorFieldMappingService.addFieldMapping('DuplicatePrimaryNonContentPageMessage', null, null, {
            component: DuplicatePrimaryNonContentPageComponent,
            hidePrefixLabel: true
        });
        this.editorFieldMappingService.addFieldMapping('DuplicatePrimaryContentPage', null, null, {
            component: DuplicatePrimaryContentPageLabelComponent,
            hidePrefixLabel: false
        });
        this.editorFieldMappingService.addFieldMapping('MissingPrimaryContentPage', null, null, {
            component: MissingPrimaryContentPageComponent,
            hidePrefixLabel: false
        });
        this.editorFieldMappingService.addFieldMapping('WorkflowCreateVersionField', null, null, {
            component: WorkflowCreateVersionFieldComponent,
            hidePrefixLabel: false
        });
        this.editorFieldMappingService.addFieldMapping('SlotSharedCloneActionField', null, null, {
            component: SlotSharedCloneActionFieldComponent,
            hidePrefixLabel: false
        });
        this.editorFieldMappingService.addFieldMapping('SlotSharedSlotTypeField', null, null, {
            component: SlotSharedSlotTypeFieldComponent,
            hidePrefixLabel: false
        });
    }
    setDefaultTabsConfiguration() {
        this.genericEditorTabService.configureTab('default', {
            priority: 5
        });
        this.genericEditorTabService.configureTab('information', {
            priority: 5
        });
        this.genericEditorTabService.configureTab('administration', {
            priority: 4
        });
    }
    setDefaultTabFieldMappings() {
        // Set default tab.
        this.genericEditorTabService.addComponentTypeDefaultTabPredicate(this.defaultTabPredicate);
        // Set tabs
        this.editorFieldMappingService.addFieldTabMapping(null, this.isComponentPredicate, 'visible', 'visibility');
        this.editorFieldMappingService.addFieldTabMapping(null, this.isComponentPredicate, 'restrictions', 'visibility');
        this.editorFieldMappingService.addFieldTabMapping(null, this.isComponentPredicate, 'onlyOneRestrictionMustApply', 'visibility');
        this.editorFieldMappingService.addFieldTabMapping(null, this.isComponentPredicate, 'uid', 'basicinfo');
        this.editorFieldMappingService.addFieldTabMapping(null, this.isComponentPredicate, 'id', 'basicinfo');
        this.editorFieldMappingService.addFieldTabMapping(null, this.isComponentPredicate, 'modifiedtime', 'basicinfo');
        this.editorFieldMappingService.addFieldTabMapping('DateTime', this.isComponentPredicate, 'creationtime', 'basicinfo');
        // Page Tabs
        this.editorFieldMappingService.addFieldTabMapping('DisplayConditionEditor', this.isPagePredicate, 'displayCondition', 'displaycondition');
        this.editorFieldMappingService.addFieldTabMapping(null, this.isPagePredicate, 'restrictions', 'restrictions');
    }
};
CmsGenericEditorConfigurationService.$inject = ["editorFieldMappingService", "genericEditorTabService"];
/* @ngInject */ CmsGenericEditorConfigurationService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.EditorFieldMappingService,
        smarteditcommons.GenericEditorTabService])
], /* @ngInject */ CmsGenericEditorConfigurationService);

let /* @ngInject */ ProductDropdownPopulator = class /* @ngInject */ ProductDropdownPopulator extends smarteditcommons.DropdownPopulatorInterface {
    constructor(contextAwareCatalogService, languageService, translateService, uriDropdownPopulator) {
        super(lodash__namespace, languageService, translateService);
        this.contextAwareCatalogService = contextAwareCatalogService;
        this.uriDropdownPopulator = uriDropdownPopulator;
    }
    fetchPage(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const uri = yield this.contextAwareCatalogService.getProductSearchUri(payload.model.productCatalog);
            payload.field.uri = uri;
            return this.uriDropdownPopulator.fetchPage(payload);
        });
    }
    isPaged() {
        return true;
    }
    getItem(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const uri = yield this.contextAwareCatalogService.getProductItemUri();
            payload.field.uri = uri;
            return this.uriDropdownPopulator.getItem(payload);
        });
    }
};
ProductDropdownPopulator.$inject = ["contextAwareCatalogService", "languageService", "translateService", "uriDropdownPopulator"];
/* @ngInject */ ProductDropdownPopulator = __decorate([
    core.Injectable(),
    __metadata("design:paramtypes", [exports.ContextAwareCatalogService,
        smarteditcommons.LanguageService,
        core$1.TranslateService,
        smarteditcommons.UriDropdownPopulator])
], /* @ngInject */ ProductDropdownPopulator);

let /* @ngInject */ ProductCatalogDropdownPopulator = class /* @ngInject */ ProductCatalogDropdownPopulator extends smarteditcommons.DropdownPopulatorInterface {
    constructor(catalogService, languageService, optionsDropdownPopulator, translateService) {
        super(lodash__namespace, languageService, translateService);
        this.catalogService = catalogService;
        this.optionsDropdownPopulator = optionsDropdownPopulator;
    }
    fetchAll(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const catalogs = yield this.catalogService.getProductCatalogsBySiteKey(smarteditcommons.CONTEXT_SITE_ID);
            payload.field.options = catalogs.filter((catalog) => this.hasCatalogOneActiveVersion(catalog));
            return this.optionsDropdownPopulator.fetchAll(payload);
        });
    }
    isPaged() {
        return false;
    }
    hasCatalogOneActiveVersion(catalog) {
        const activeVersions = catalog.versions.filter((version) => version.active === true);
        return activeVersions.length === 1;
    }
};
ProductCatalogDropdownPopulator.$inject = ["catalogService", "languageService", "optionsDropdownPopulator", "translateService"];
/* @ngInject */ ProductCatalogDropdownPopulator = __decorate([
    core.Injectable(),
    __metadata("design:paramtypes", [smarteditcommons.ICatalogService,
        smarteditcommons.LanguageService,
        smarteditcommons.OptionsDropdownPopulator,
        core$1.TranslateService])
], /* @ngInject */ ProductCatalogDropdownPopulator);

let /* @ngInject */ CategoryDropdownPopulator = class /* @ngInject */ CategoryDropdownPopulator extends smarteditcommons.DropdownPopulatorInterface {
    constructor(contextAwareCatalogService, languageService, translateService, uriDropdownPopulator) {
        super(lodash__namespace, languageService, translateService);
        this.contextAwareCatalogService = contextAwareCatalogService;
        this.uriDropdownPopulator = uriDropdownPopulator;
    }
    fetchPage(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            if (payload.model.productCatalog === undefined) {
                throw new Error('"productCatalog" is required but it was not provided.');
            }
            const uri = yield this.contextAwareCatalogService.getProductCategorySearchUri(payload.model.productCatalog);
            payload.field.uri = uri;
            const langIsoCode = yield this.languageService.getResolveLocale();
            payload.field.params.langIsoCode = langIsoCode;
            return this.uriDropdownPopulator.fetchPage(payload);
        });
    }
    getItem(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const uri = yield this.contextAwareCatalogService.getProductCategoryItemUri();
            payload.field.uri = uri;
            return this.uriDropdownPopulator.getItem(payload);
        });
    }
    isPaged() {
        return true;
    }
};
CategoryDropdownPopulator.$inject = ["contextAwareCatalogService", "languageService", "translateService", "uriDropdownPopulator"];
/* @ngInject */ CategoryDropdownPopulator = __decorate([
    core.Injectable(),
    __metadata("design:paramtypes", [exports.ContextAwareCatalogService,
        smarteditcommons.LanguageService,
        core$1.TranslateService,
        smarteditcommons.UriDropdownPopulator])
], /* @ngInject */ CategoryDropdownPopulator);

/**
 * TODO: It might be deleted because it seems that it has been replaced by CMSItemDropdownDropdownPopulator.
 */
let /* @ngInject */ CmsLinkComponentContentPageDropdownPopulator = class /* @ngInject */ CmsLinkComponentContentPageDropdownPopulator extends smarteditcommons.DropdownPopulatorInterface {
    constructor(contextAwareCatalogService, languageService, translateService, uriDropdownPopulator) {
        super(lodash__namespace, languageService, translateService);
        this.contextAwareCatalogService = contextAwareCatalogService;
        this.uriDropdownPopulator = uriDropdownPopulator;
    }
    fetchPage(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const uri = yield this.contextAwareCatalogService.getContentPageSearchUri();
            payload.field.uri = uri;
            return this.uriDropdownPopulator.fetchPage(payload);
        });
    }
    getItem(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const uri = yield this.contextAwareCatalogService.getContentPageItemUri();
            payload.field.uri = uri;
            return this.uriDropdownPopulator.getItem(payload);
        });
    }
    isPaged() {
        return true;
    }
};
CmsLinkComponentContentPageDropdownPopulator.$inject = ["contextAwareCatalogService", "languageService", "translateService", "uriDropdownPopulator"];
/* @ngInject */ CmsLinkComponentContentPageDropdownPopulator = __decorate([
    core.Injectable(),
    __metadata("design:paramtypes", [exports.ContextAwareCatalogService,
        smarteditcommons.LanguageService,
        core$1.TranslateService,
        smarteditcommons.UriDropdownPopulator])
], /* @ngInject */ CmsLinkComponentContentPageDropdownPopulator);

let GenericEditorWidgetsModule = class GenericEditorWidgetsModule {
};
GenericEditorWidgetsModule = __decorate([
    core.NgModule({
        imports: [
            smarteditcommons.TranslationModule.forChild(),
            forms.FormsModule,
            common.CommonModule,
            smarteditcommons.L10nPipeModule,
            smarteditcommons.SelectModule,
            smarteditcommons.GenericEditorDropdownModule,
            CatalogModule,
            PageComponentsModule
        ],
        providers: [
            CmsGenericEditorConfigurationService,
            {
                provide: smarteditcommons.CustomDropdownPopulatorsToken,
                useClass: ProductDropdownPopulator,
                multi: true
            },
            {
                provide: smarteditcommons.CustomDropdownPopulatorsToken,
                useClass: ProductCatalogDropdownPopulator,
                multi: true
            },
            {
                provide: smarteditcommons.CustomDropdownPopulatorsToken,
                useClass: CategoryDropdownPopulator,
                multi: true
            },
            {
                provide: smarteditcommons.CustomDropdownPopulatorsToken,
                useClass: CmsLinkComponentContentPageDropdownPopulator,
                multi: true
            }
        ],
        declarations: [
            WorkflowCreateVersionFieldComponent,
            MissingPrimaryContentPageComponent,
            DuplicatePrimaryNonContentPageComponent,
            DuplicatePrimaryContentPageLabelComponent,
            RestrictionsListComponent,
            SlotSharedCloneActionFieldComponent,
            SlotSharedSlotTypeFieldComponent,
            CmsLinkToSelectComponent,
            PageTypeEditorComponent,
            SingleActiveCatalogAwareItemSelectorComponent,
            SingeActiveCatalogAwareItemSelectorItemRendererComponent,
            LinkToggleComponent,
            InfoPageNameComponent,
            ThumbnailSelectComponent,
            MuteBooleanComponent
        ],
        entryComponents: [
            WorkflowCreateVersionFieldComponent,
            MissingPrimaryContentPageComponent,
            DuplicatePrimaryNonContentPageComponent,
            DuplicatePrimaryContentPageLabelComponent,
            RestrictionsListComponent,
            SlotSharedCloneActionFieldComponent,
            SlotSharedSlotTypeFieldComponent,
            CmsLinkToSelectComponent,
            PageTypeEditorComponent,
            SingleActiveCatalogAwareItemSelectorComponent,
            SingeActiveCatalogAwareItemSelectorItemRendererComponent,
            LinkToggleComponent,
            InfoPageNameComponent,
            ThumbnailSelectComponent,
            MuteBooleanComponent
        ],
        exports: [WorkflowCreateVersionFieldComponent, CatalogModule]
    })
], GenericEditorWidgetsModule);

window.__smartedit__.addDecoratorPayload("Component", "TrashedPageListComponent", {
    selector: 'se-trashed-page-list',
    template: `<div class="se-page-list"><se-toolbar cssClass="se-toolbar--shell" imageRoot="imageRoot" toolbarName="smartEditHeaderToolbar"></se-toolbar><se-toolbar cssClass="se-toolbar--shell ySmartEditTrashPageToolbar" imageRoot="imageRoot" toolbarName="smartEditTrashPageToolbar"></se-toolbar><div class="se-page-list__header"><span class="se-page-list__catalog-name" translate="se.cms.trashedpagelist.title"></span><p class="se-page-list__sub-title">{{ catalogName | seL10n | async }} - {{ catalogVersion }}</p></div><div class="se-page-list__body"><div class="se-page-list__table-header"><span class="se-paged-list__page-count-wrapper"><span class="span-page-list__page-count-text" translate="se.pagelist.countsearchresult"></span> <span>&nbsp;</span> <span class="se-page-list__page-count">({{ count }})</span></span><div class="fd-form__group se-page-list__search"><div class="se-input-group"><input type="search" class="se-input-group__input-area ySEPage-list-search-input" placeholder="{{ 'se.cms.pagelist.searchplaceholder' | translate }}" [ngModel]="mask" (ngModelChange)="onMaskChange($event)" name="mask"/> <span class="sap-icon--search se-input-group__addon"></span><div *ngIf="mask" aria-label="clear" class="se-input-group__addon se-input-group__clear-btn" (click)="reset()"><span class="sap-icon--decline"></span></div></div></div></div><div class="se-page-list__table-body"><se-dynamic-paged-list class="se-trashed-pages" [config]="trashedPageListConfig" [mask]="mask" (getApi)="getApi($event);" (onItemsUpdate)="onPageItemsUpdate($event.pagination)"></se-dynamic-paged-list></div></div></div>`,
    styles: [`.se-page-list{background-color:#edeff0;min-height:100vh;height:100%}.se-page-list__page-link-anchor{text-decoration:none!important;color:#51555a}.se-page-list__page-link-anchor:hover{color:#0a6ed1}.se-page-list__header{padding:16px 30px;background-color:#fff}.se-page-list__page-link-icon{font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;color:#51555a}.se-page-list__catalog-name{font-size:1.7142857143rem;line-height:1.3333333333;font-weight:400;display:block;margin-bottom:4px}.se-page-list__sub-title{color:#6a6d70}.se-page-list__body{padding:20px 20px 70px}.se-page-list__page-link--left{cursor:pointer}.se-page-list__page-link--left .se-page-list__page-link-anchor{margin-left:3px}.se-page-list__page-link--right{cursor:pointer}.se-page-list__page-link--right .se-page-list__page-link-anchor{margin-right:3px}.se-page-list__table-header{display:flex;flex-direction:row;align-items:center;justify-content:space-between;background-color:#fff;height:56px;padding:20px;border-radius:4px 4px 0 0}.se-page-list__table-header--right{display:flex;flex-direction:row;align-items:center}.se-page-list__table-header .se-paged-list__page-count-wrapper{font-size:1.1428571429rem;line-height:1.25;font-weight:400;margin-right:auto}.se-page-list__table-body{padding-bottom:16px}.se-page-list__table-body .se-data-table__arrow{margin-left:2px}.se-page-list__table-body .se-paged-list-item{cursor:default}.se-page-list__search{margin-right:16px;width:380px}.se-page-list__add{text-transform:capitalize}.se-paged-list__header{font-size:1rem;line-height:1.4285714286;font-weight:400}.se-paged-list__header-dropdownitems,.se-paged-list__header-pageStatus,.se-paged-list__header-syncStatus{cursor:default}.se-paged-list-item-name a{text-decoration:none!important}.se-sync-btn__status--done{color:#0a7e3e}.se-sync-btn__status--not{color:#e9730c}.ySmartEditTrashPageToolbar{background-color:#fff}.fd-table td.se-paged-list-item-numberOfRestrictions,.fd-table td.se-paged-list-item-syncStatus,.fd-table th.se-paged-list__header-numberOfRestrictions,.fd-table th.se-paged-list__header-syncStatus{text-align:center}.fd-table td.se-paged-list-item-syncStatus{font-size:1.1428571429rem;line-height:1.25;font-weight:400}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    encapsulation: core.ViewEncapsulation.None
});
let /* @ngInject */ TrashedPageListComponent = class /* @ngInject */ TrashedPageListComponent {
    constructor(catalogService, route, urlService, systemEventService, cdr) {
        this.catalogService = catalogService;
        this.route = route;
        this.urlService = urlService;
        this.systemEventService = systemEventService;
        this.cdr = cdr;
        this.mask = '';
        this.dropdownItems = [];
        this.count = 0;
        this.maskSubject$ = new Subject.Subject();
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.initialize();
            this.unsubscribeEventListener = this.systemEventService.subscribe(smarteditcommons.EVENT_CONTENT_CATALOG_UPDATE, this.onContentCatalogUpdate.bind(this));
            this.maskSubscription = this.maskSubject$
                .pipe(operators$1.debounceTime(500), operators$1.distinctUntilChanged())
                .subscribe((newValue) => {
                this.mask = newValue;
                if (!this.cdr.destroyed) {
                    this.cdr.detectChanges();
                }
            });
        });
    }
    ngOnDestroy() {
        this.unsubscribeEventListener();
        this.maskSubscription.unsubscribe();
    }
    onMaskChange(newValue) {
        this.maskSubject$.next(newValue);
    }
    onPageItemsUpdate(pagination) {
        this.count = pagination.totalCount;
    }
    reset() {
        this.mask = '';
    }
    getApi($api) {
        this.dynamicPagedListApi = $api;
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this.setSiteParams();
            this.setUriContext();
            this.setTrashedListConfigBasis();
            this.setTrashedListColumns();
            return this.setCatalogName();
        });
    }
    onContentCatalogUpdate() {
        if (this.dynamicPagedListApi) {
            this.dynamicPagedListApi.reloadItems();
        }
    }
    setSiteParams() {
        this.siteUID = this.route.snapshot.params.siteId;
        this.catalogId = this.route.snapshot.params.catalogId;
        this.catalogVersion = this.route.snapshot.params.catalogVersion;
    }
    setUriContext() {
        this.uriContext = this.urlService.buildUriContext(this.siteUID, this.catalogId, this.catalogVersion);
    }
    setTrashedListConfigBasis() {
        this.trashedPageListConfig = {
            sortBy: 'name',
            reversed: false,
            itemsPerPage: 10,
            displayCount: true,
            uri: smarteditcommons.cmsitemsUri,
            queryParams: {
                catalogId: this.catalogId,
                catalogVersion: this.catalogVersion,
                typeCode: 'AbstractPage',
                itemSearchParams: 'pageStatus:deleted'
            },
            keys: []
        };
    }
    setCatalogName() {
        return __awaiter(this, void 0, void 0, function* () {
            const catalogs = yield this.catalogService.getContentCatalogsForSite(this.siteUID);
            this.catalogName = catalogs.find((catalog) => catalog.catalogId === this.catalogId).name;
        });
    }
    setTrashedListColumns() {
        this.trashedPageListConfig.keys = [
            {
                property: 'name',
                i18n: 'se.cms.pagelist.headerpagename',
                sortable: true
            },
            {
                property: 'uid',
                i18n: 'se.cms.pagelist.headerpageid',
                sortable: true
            },
            {
                property: 'itemtype',
                i18n: 'se.cms.pagelist.headerpagetype',
                sortable: true
            },
            {
                property: 'label',
                i18n: 'se.cms.pagelist.headerpagelable',
                sortable: false
            },
            {
                property: 'numberOfRestrictions',
                i18n: 'se.cms.pagelist.headerrestrictions',
                sortable: false,
                component: NumberOfRestrictionsWrapperComponent
            },
            {
                property: 'modifiedtime',
                i18n: 'se.cms.trashedpagelist.trashed.date',
                sortable: true,
                component: ModifiedTimeWrapperComponent
            },
            {
                property: 'pageStatus',
                i18n: 'se.cms.pagelist.headerpagestatus',
                sortable: false,
                component: PageStatusWrapperComponent
            },
            {
                property: 'dropdownitems',
                i18n: '',
                sortable: false,
                component: TrashListDropdownItemsWrapperComponent
            }
        ];
    }
};
TrashedPageListComponent.$inject = ["catalogService", "route", "urlService", "systemEventService", "cdr"];
/* @ngInject */ TrashedPageListComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-trashed-page-list',
        template: `<div class="se-page-list"><se-toolbar cssClass="se-toolbar--shell" imageRoot="imageRoot" toolbarName="smartEditHeaderToolbar"></se-toolbar><se-toolbar cssClass="se-toolbar--shell ySmartEditTrashPageToolbar" imageRoot="imageRoot" toolbarName="smartEditTrashPageToolbar"></se-toolbar><div class="se-page-list__header"><span class="se-page-list__catalog-name" translate="se.cms.trashedpagelist.title"></span><p class="se-page-list__sub-title">{{ catalogName | seL10n | async }} - {{ catalogVersion }}</p></div><div class="se-page-list__body"><div class="se-page-list__table-header"><span class="se-paged-list__page-count-wrapper"><span class="span-page-list__page-count-text" translate="se.pagelist.countsearchresult"></span> <span>&nbsp;</span> <span class="se-page-list__page-count">({{ count }})</span></span><div class="fd-form__group se-page-list__search"><div class="se-input-group"><input type="search" class="se-input-group__input-area ySEPage-list-search-input" placeholder="{{ 'se.cms.pagelist.searchplaceholder' | translate }}" [ngModel]="mask" (ngModelChange)="onMaskChange($event)" name="mask"/> <span class="sap-icon--search se-input-group__addon"></span><div *ngIf="mask" aria-label="clear" class="se-input-group__addon se-input-group__clear-btn" (click)="reset()"><span class="sap-icon--decline"></span></div></div></div></div><div class="se-page-list__table-body"><se-dynamic-paged-list class="se-trashed-pages" [config]="trashedPageListConfig" [mask]="mask" (getApi)="getApi($event);" (onItemsUpdate)="onPageItemsUpdate($event.pagination)"></se-dynamic-paged-list></div></div></div>`,
        styles: [`.se-page-list{background-color:#edeff0;min-height:100vh;height:100%}.se-page-list__page-link-anchor{text-decoration:none!important;color:#51555a}.se-page-list__page-link-anchor:hover{color:#0a6ed1}.se-page-list__header{padding:16px 30px;background-color:#fff}.se-page-list__page-link-icon{font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;color:#51555a}.se-page-list__catalog-name{font-size:1.7142857143rem;line-height:1.3333333333;font-weight:400;display:block;margin-bottom:4px}.se-page-list__sub-title{color:#6a6d70}.se-page-list__body{padding:20px 20px 70px}.se-page-list__page-link--left{cursor:pointer}.se-page-list__page-link--left .se-page-list__page-link-anchor{margin-left:3px}.se-page-list__page-link--right{cursor:pointer}.se-page-list__page-link--right .se-page-list__page-link-anchor{margin-right:3px}.se-page-list__table-header{display:flex;flex-direction:row;align-items:center;justify-content:space-between;background-color:#fff;height:56px;padding:20px;border-radius:4px 4px 0 0}.se-page-list__table-header--right{display:flex;flex-direction:row;align-items:center}.se-page-list__table-header .se-paged-list__page-count-wrapper{font-size:1.1428571429rem;line-height:1.25;font-weight:400;margin-right:auto}.se-page-list__table-body{padding-bottom:16px}.se-page-list__table-body .se-data-table__arrow{margin-left:2px}.se-page-list__table-body .se-paged-list-item{cursor:default}.se-page-list__search{margin-right:16px;width:380px}.se-page-list__add{text-transform:capitalize}.se-paged-list__header{font-size:1rem;line-height:1.4285714286;font-weight:400}.se-paged-list__header-dropdownitems,.se-paged-list__header-pageStatus,.se-paged-list__header-syncStatus{cursor:default}.se-paged-list-item-name a{text-decoration:none!important}.se-sync-btn__status--done{color:#0a7e3e}.se-sync-btn__status--not{color:#e9730c}.ySmartEditTrashPageToolbar{background-color:#fff}.fd-table td.se-paged-list-item-numberOfRestrictions,.fd-table td.se-paged-list-item-syncStatus,.fd-table th.se-paged-list__header-numberOfRestrictions,.fd-table th.se-paged-list__header-syncStatus{text-align:center}.fd-table td.se-paged-list-item-syncStatus{font-size:1.1428571429rem;line-height:1.25;font-weight:400}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush,
        encapsulation: core.ViewEncapsulation.None
    }),
    __metadata("design:paramtypes", [smarteditcommons.ICatalogService,
        router.ActivatedRoute,
        smarteditcommons.IUrlService,
        smarteditcommons.SystemEventService,
        core.ChangeDetectorRef])
], /* @ngInject */ TrashedPageListComponent);

let TrashedPageListModule = class TrashedPageListModule {
};
TrashedPageListModule = __decorate([
    core.NgModule({
        imports: [
            common.CommonModule,
            smarteditcommons.SeTranslationModule.forChild(),
            forms.FormsModule,
            smarteditcontainer.ToolbarModule,
            smarteditcommons.L10nPipeModule,
            smarteditcommons.DynamicPagedListModule
        ],
        declarations: [TrashedPageListComponent]
    })
], TrashedPageListModule);

window.__smartedit__.addDecoratorPayload("Component", "VersionItemContextComponent", {
    selector: 'se-version-item-context',
    template: `<div class="se-version-item-context"><span class="sap-icon--navigation-right-arrow"></span><se-tooltip *ngIf="(pageVersion$ | async) as pageVersion" [triggers]="['mouseenter', 'mouseleave']" [placement]="'bottom'" [isChevronVisible]="true"><div se-tooltip-trigger class="se-version-item-context__info"><div class="se-version-item-context__info-label" [title]="pageVersion.label">{{ pageVersion.label }}</div><div class="se-version-item-context__info-date">{{ pageVersion.creationtime | date: 'M/d/yy h:mm a' }}</div></div><div se-tooltip-body class="se-version-item-context__description-wrapper"><span class="se-version-item-context__description">{{ pageVersion.description || (EMPTY_DESCRIPTION_MSG_KEY | translate) }}</span></div></se-tooltip><button type="button" (click)="deselectPageVersion()" class="se-version-item-context__remove-btn fd-button--light sap-icon--decline"></button></div>`,
    styles: [`.se-version-item-context{display:flex;flex-direction:row;align-items:center;height:40px;border-right:1px solid #d9d9d9}.se-version-item-context .sap-icon--navigation-right-arrow{padding-right:12px;color:#51555a}.se-version-item-context__info{display:flex;flex-direction:column}.se-version-item-context__info-label{font-weight:700;font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;max-width:90px}.se-version-item-context__info-date{color:#6a6d70;font-size:.8571428571rem;line-height:1.3333333333;font-weight:400}.se-version-item-context__remove-btn{padding:0;margin:8px;min-width:20px;height:20px;color:#32363a;background:0 0;border:transparent;line-height:1}.se-version-item-context__remove-btn::before{margin:0!important}.se-version-item-context__description-wrapper{word-wrap:break-word}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ VersionItemContextComponent = class /* @ngInject */ VersionItemContextComponent {
    constructor(pageVersionSelectionService) {
        this.pageVersionSelectionService = pageVersionSelectionService;
        this.EMPTY_DESCRIPTION_MSG_KEY = 'se.cms.versions.no.description';
    }
    ngOnInit() {
        this.pageVersion$ = this.pageVersionSelectionService.getSelectedPageVersion$();
        this.pageVersionSelectionService.hideToolbarContextIfNotNeeded();
    }
    deselectPageVersion() {
        this.pageVersionSelectionService.deselectPageVersion();
    }
};
VersionItemContextComponent.$inject = ["pageVersionSelectionService"];
/* @ngInject */ VersionItemContextComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-version-item-context',
        template: `<div class="se-version-item-context"><span class="sap-icon--navigation-right-arrow"></span><se-tooltip *ngIf="(pageVersion$ | async) as pageVersion" [triggers]="['mouseenter', 'mouseleave']" [placement]="'bottom'" [isChevronVisible]="true"><div se-tooltip-trigger class="se-version-item-context__info"><div class="se-version-item-context__info-label" [title]="pageVersion.label">{{ pageVersion.label }}</div><div class="se-version-item-context__info-date">{{ pageVersion.creationtime | date: 'M/d/yy h:mm a' }}</div></div><div se-tooltip-body class="se-version-item-context__description-wrapper"><span class="se-version-item-context__description">{{ pageVersion.description || (EMPTY_DESCRIPTION_MSG_KEY | translate) }}</span></div></se-tooltip><button type="button" (click)="deselectPageVersion()" class="se-version-item-context__remove-btn fd-button--light sap-icon--decline"></button></div>`,
        styles: [`.se-version-item-context{display:flex;flex-direction:row;align-items:center;height:40px;border-right:1px solid #d9d9d9}.se-version-item-context .sap-icon--navigation-right-arrow{padding-right:12px;color:#51555a}.se-version-item-context__info{display:flex;flex-direction:column}.se-version-item-context__info-label{font-weight:700;font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;max-width:90px}.se-version-item-context__info-date{color:#6a6d70;font-size:.8571428571rem;line-height:1.3333333333;font-weight:400}.se-version-item-context__remove-btn{padding:0;margin:8px;min-width:20px;height:20px;color:#32363a;background:0 0;border:transparent;line-height:1}.se-version-item-context__remove-btn::before{margin:0!important}.se-version-item-context__description-wrapper{word-wrap:break-word}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [smarteditcommons.PageVersionSelectionService])
], /* @ngInject */ VersionItemContextComponent);

window.__smartedit__.addDecoratorPayload("Component", "VersionItemComponent", {
    selector: 'se-version-item',
    template: `<div class="se-version-item" [ngClass]="{ 'se-version-item--selected': isSelectedVersion() }"><div class="se-version-item__header" [title]="pageVersion.label"><button class="se-version-item__label se-button--text" (click)="selectVersion()">{{ pageVersion.label }}</button><se-version-item-menu *ngIf="isVersionMenuEnabled()" [item]="pageVersion"></se-version-item-menu></div><div class="se-version-item__date">{{ pageVersion.creationtime | date: 'M/d/yy h:mm a' }}</div><div class="se-version-item__description" *ngIf="pageVersion.description"><se-more-text class="se-version-item__description-text" [text]="pageVersion.description" [limit]="32" [ellipsis]="'...'" [capitalizeLabel]="true"></se-more-text></div></div>`,
    styles: [`:host(.se-version-item--last) .se-version-item{border-bottom:none}.se-version-item{padding:10px 20px;border-bottom:1px solid #d9d9d9}.se-version-item:hover{background-color:#fafafa}.se-version-item--selected{background-color:rgba(10,110,209,.07)}.se-version-item--selected:hover{background-color:rgba(10,110,209,.1)}.se-version-item__header{display:flex;flex-direction:row;align-items:center;justify-content:space-between}.se-version-item__label{font-weight:700;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;max-width:225px;color:#0a6ed1}.se-version-item__date{color:#6a6d70}.se-version-item__description{display:flex;flex-direction:row;align-items:center;max-width:260px}.se-version-item__description-text{padding-right:2px;width:230px;word-break:break-all;white-space:normal}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ VersionItemComponent = class /* @ngInject */ VersionItemComponent {
    constructor(pageVersionSelectionService, perspectiveService, cMSModesService) {
        this.pageVersionSelectionService = pageVersionSelectionService;
        this.perspectiveService = perspectiveService;
        this.cMSModesService = cMSModesService;
        this.VERSIONING_MODE_KEY = smarteditcommons.CMSModesService.VERSIONING_PERSPECTIVE_KEY;
    }
    selectVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const isVersioningModeActive = yield this.cMSModesService.isVersioningPerspectiveActive();
            if (!isVersioningModeActive) {
                this.perspectiveService.switchTo(this.VERSIONING_MODE_KEY);
            }
            this.pageVersionSelectionService.selectPageVersion(this.pageVersion);
        });
    }
    isSelectedVersion() {
        const selectedVersion = this.pageVersionSelectionService.getSelectedPageVersion();
        return selectedVersion && selectedVersion.uid === this.pageVersion.uid;
    }
    isVersionMenuEnabled() {
        const activePerspective = this.perspectiveService.getActivePerspective();
        return activePerspective && activePerspective.key === this.VERSIONING_MODE_KEY;
    }
};
VersionItemComponent.$inject = ["pageVersionSelectionService", "perspectiveService", "cMSModesService"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ VersionItemComponent.prototype, "pageVersion", void 0);
/* @ngInject */ VersionItemComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-version-item',
        template: `<div class="se-version-item" [ngClass]="{ 'se-version-item--selected': isSelectedVersion() }"><div class="se-version-item__header" [title]="pageVersion.label"><button class="se-version-item__label se-button--text" (click)="selectVersion()">{{ pageVersion.label }}</button><se-version-item-menu *ngIf="isVersionMenuEnabled()" [item]="pageVersion"></se-version-item-menu></div><div class="se-version-item__date">{{ pageVersion.creationtime | date: 'M/d/yy h:mm a' }}</div><div class="se-version-item__description" *ngIf="pageVersion.description"><se-more-text class="se-version-item__description-text" [text]="pageVersion.description" [limit]="32" [ellipsis]="'...'" [capitalizeLabel]="true"></se-more-text></div></div>`,
        styles: [`:host(.se-version-item--last) .se-version-item{border-bottom:none}.se-version-item{padding:10px 20px;border-bottom:1px solid #d9d9d9}.se-version-item:hover{background-color:#fafafa}.se-version-item--selected{background-color:rgba(10,110,209,.07)}.se-version-item--selected:hover{background-color:rgba(10,110,209,.1)}.se-version-item__header{display:flex;flex-direction:row;align-items:center;justify-content:space-between}.se-version-item__label{font-weight:700;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;word-break:break-all;max-width:225px;color:#0a6ed1}.se-version-item__date{color:#6a6d70}.se-version-item__description{display:flex;flex-direction:row;align-items:center;max-width:260px}.se-version-item__description-text{padding-right:2px;width:230px;word-break:break-all;white-space:normal}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [smarteditcommons.PageVersionSelectionService,
        smarteditcommons.IPerspectiveService,
        smarteditcommons.CMSModesService])
], /* @ngInject */ VersionItemComponent);

/**
 * Used to manage a page version.
 */
let /* @ngInject */ ManagePageVersionService = class /* @ngInject */ ManagePageVersionService {
    constructor(alertService, experienceService, confirmationModalService, genericEditorModalService, pageInfoService, pageVersioningService, pageVersionSelectionService) {
        this.alertService = alertService;
        this.experienceService = experienceService;
        this.confirmationModalService = confirmationModalService;
        this.genericEditorModalService = genericEditorModalService;
        this.pageInfoService = pageInfoService;
        this.pageVersioningService = pageVersioningService;
        this.pageVersionSelectionService = pageVersionSelectionService;
    }
    createPageVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const pageUuid = yield this.pageInfoService.getPageUUID();
            const componentData = this.getComponentDataForEditor(pageUuid, null);
            return this.genericEditorModalService.open(componentData, (result) => __awaiter(this, void 0, void 0, function* () {
                const experience = {
                    versionId: result.uid
                };
                yield this.experienceService.updateExperience(experience);
                this.alertService.showSuccess('se.cms.versions.create.alert.success');
                this.pageVersionSelectionService.selectPageVersion(result);
            }));
        });
    }
    editPageVersion(versionDetails) {
        return __awaiter(this, void 0, void 0, function* () {
            const pageUuid = yield this.pageInfoService.getPageUUID();
            const componentData = this.getComponentDataForEditor(pageUuid, versionDetails);
            return this.genericEditorModalService.open(componentData, (result) => {
                this.pageVersionSelectionService.updatePageVersionDetails(result);
            });
        });
    }
    deletePageVersion(versionId) {
        return __awaiter(this, void 0, void 0, function* () {
            const pageUuid = yield this.pageInfoService.getPageUUID();
            yield this.confirmationModalService.confirm({
                title: 'se.cms.actionitem.page.version.delete.confirmation.title',
                description: 'se.cms.actionitem.page.version.delete.confirmation.description'
            });
            yield this.pageVersioningService.deletePageVersion(pageUuid, versionId);
            this.alertService.showSuccess('se.cms.versions.delete.alert.success');
            // reload experience to display current page if deleting the current
            const selectedVersion = this.pageVersionSelectionService.getSelectedPageVersion();
            if (selectedVersion && selectedVersion.uid === versionId) {
                yield this.experienceService.updateExperience();
                this.pageVersionSelectionService.deselectPageVersion();
            }
        });
    }
    /**
     * Returns an object that contains the information to be displayed and edited in the modal.
     *
     * @param pageUuid the uuid of the page.
     * @param content the content to be populated in the editor, null for create mode.
     */
    getComponentDataForEditor(pageUuid, content) {
        const componentData = {
            title: content ? 'se.cms.versions.edit' : 'se.cms.versions.create',
            structure: {
                attributes: [
                    {
                        cmsStructureType: 'ShortString',
                        qualifier: 'label',
                        i18nKey: 'se.cms.versions.editor.label.name',
                        required: true
                    },
                    {
                        cmsStructureType: 'ShortString',
                        qualifier: 'description',
                        i18nKey: 'se.cms.versions.editor.description.name'
                    }
                ]
            },
            contentApi: this.pageVersioningService.getResourceURI().replace(':pageUuid', pageUuid)
        };
        if (content) {
            componentData.content = content;
            componentData.componentUuid = content.uid;
            componentData.componentType = 'versioning';
        }
        return componentData;
    }
};
ManagePageVersionService.$inject = ["alertService", "experienceService", "confirmationModalService", "genericEditorModalService", "pageInfoService", "pageVersioningService", "pageVersionSelectionService"];
/* @ngInject */ ManagePageVersionService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.IAlertService,
        smarteditcommons.IExperienceService,
        smarteditcommons.IConfirmationModalService,
        exports.GenericEditorModalService,
        smarteditcommons.IPageInfoService,
        smarteditcommons.PageVersioningService,
        smarteditcommons.PageVersionSelectionService])
], /* @ngInject */ ManagePageVersionService);

/**
 * This service is used to rollback a page version from the toolbar context.
 */
let /* @ngInject */ RollbackPageVersionService = class /* @ngInject */ RollbackPageVersionService {
    constructor(logService, alertService, confirmationModalService, experienceService, pageInfoService, pageVersioningService, pageVersionSelectionService, systemEventService) {
        this.logService = logService;
        this.alertService = alertService;
        this.confirmationModalService = confirmationModalService;
        this.experienceService = experienceService;
        this.pageInfoService = pageInfoService;
        this.pageVersioningService = pageVersioningService;
        this.pageVersionSelectionService = pageVersionSelectionService;
        this.systemEventService = systemEventService;
    }
    rollbackPageVersion(version) {
        return __awaiter(this, void 0, void 0, function* () {
            const pageVersion = version || this.pageVersionSelectionService.getSelectedPageVersion();
            if (!!pageVersion) {
                const TRANSLATE_NS = 'se.cms.actionitem.page.version.rollback.confirmation';
                const pageUuid = yield this.pageInfoService.getPageUUID();
                yield this.showConfirmationModal(pageVersion.label, TRANSLATE_NS);
                yield this.performRollback(pageUuid, pageVersion);
            }
        });
    }
    // Warning! This method is patched in personalization module, be careful when modifying it.
    showConfirmationModal(versionLabel, translateNs) {
        return this.confirmationModalService.confirm({
            title: `${translateNs}.title`,
            description: `${translateNs}.description`,
            descriptionPlaceholders: {
                versionLabel
            }
        });
    }
    performRollback(pageUuid, pageVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.pageVersioningService.rollbackPageVersion(pageUuid, pageVersion.uid);
                // invalidate the content catalog cache: a rollback of a page could replace the existing homepage.
                this.systemEventService.publishAsync(smarteditcommons.EVENT_CONTENT_CATALOG_UPDATE);
                this.alertService.showSuccess('se.cms.versions.rollback.alert.success');
                // reload experience
                yield this.experienceService.updateExperience({});
                this.pageVersionSelectionService.deselectPageVersion(false);
            }
            catch (_a) {
                this.logService.error('RollbackPageVersionService::performRollback - unable to perform page rollback');
            }
        });
    }
};
RollbackPageVersionService.$inject = ["logService", "alertService", "confirmationModalService", "experienceService", "pageInfoService", "pageVersioningService", "pageVersionSelectionService", "systemEventService"];
/* @ngInject */ RollbackPageVersionService = __decorate([
    smarteditcommons.SeDowngradeService(),
    __metadata("design:paramtypes", [smarteditcommons.LogService,
        smarteditcommons.IAlertService,
        smarteditcommons.IConfirmationModalService,
        smarteditcommons.IExperienceService,
        smarteditcommons.IPageInfoService,
        smarteditcommons.PageVersioningService,
        smarteditcommons.PageVersionSelectionService,
        smarteditcommons.SystemEventService])
], /* @ngInject */ RollbackPageVersionService);

window.__smartedit__.addDecoratorPayload("Component", "VersionItemMenuComponent", {
    selector: 'se-version-item-menu',
    template: `<se-popup-overlay class="se-version-item-menu__popup-anchor" [ngClass]="{ 'se-version-item-menu__popup-anchor--open': isMenuOpen }" [popupOverlay]="popupConfig" [popupOverlayTrigger]="isMenuOpen" (popupOverlayOnHide)="hideMenu()"><div *ngIf="menuItems.length > 0" (click)="onButtonClick($event)" class="sap-icon--overflow se-version-item-menu__toggle"></div><div se-popup-overlay-body class="se-version-item-menu fd-menu"><div class="se-version-item-menu__item fd-menu__list" *ngFor="let item of menuItems" (click)="executeItemCallback(item)"><span class="se-version-item-menu__item-link fd-menu__item">{{ item.i18nKey | translate }}</span></div></div></se-popup-overlay>`,
    styles: [`.se-version-item-menu{box-shadow:0 6px 12px rgba(0,0,0,.175);background-color:#fff;border-radius:4px!important;min-width:100px;width:fit-content;position:absolute;border:1px solid #d9d9d9;z-index:2000;top:96%;left:initial!important;right:0;transform:translate(5px,8px);right:-11px;top:-8px}.se-version-item-menu::before{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#d9d9d9;border-bottom-color:var(var(--fd-color-neutral-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-8px}.se-version-item-menu::after{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#fff;border-bottom-color:var(var(--fd-color-background-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-7px}.se-version-item-menu::after,.se-version-item-menu::before{right:10px}.se-version-item-menu::after,.se-version-item-menu::before{display:none}.se-version-item-menu__item:last-child .se-version-item-menu__item-link{color:#b00}.se-version-item-menu__popup-anchor{display:flex;flex-direction:row;align-items:center;justify-content:center;font-size:1.1428571429rem;line-height:1.25;font-weight:400}.se-version-item-menu__toggle{height:20px;width:20px;cursor:pointer}.sap-icon--overflow{color:#0a6ed1}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ VersionItemMenuComponent = class /* @ngInject */ VersionItemMenuComponent {
    constructor(managePageVersionService, pageVersionSelectionService, rollbackPageVersionService, permissionService, cdr, userTrackingService) {
        this.managePageVersionService = managePageVersionService;
        this.pageVersionSelectionService = pageVersionSelectionService;
        this.rollbackPageVersionService = rollbackPageVersionService;
        this.permissionService = permissionService;
        this.cdr = cdr;
        this.userTrackingService = userTrackingService;
        this.menuItems = [];
        this.popupConfig = {
            halign: 'left',
            valign: 'bottom'
        };
        this.isMenuOpen = false;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.menuItems = yield this.getPermittedButtons(this.getButtonsConfiguration());
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    onButtonClick(event) {
        event.stopPropagation();
        this.isMenuOpen = !this.isMenuOpen;
    }
    hideMenu() {
        this.isMenuOpen = false;
    }
    executeItemCallback(menuItem) {
        this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.VERSION_MANAGEMENT, menuItem.i18nKey);
        menuItem.callback(this.item);
        this.hideMenu();
    }
    getPermittedButtons(menuItemsConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const buttonsPermissions = menuItemsConfig.map((menuItem) => this.permissionService.isPermitted([
                {
                    names: menuItem.permissions
                }
            ]));
            const permissions = yield Promise.all(buttonsPermissions);
            return menuItemsConfig.filter((_menuItem, index) => permissions[index]);
        });
    }
    getButtonsConfiguration() {
        return [
            {
                i18nKey: 'se.cms.version.item.menu.view.label',
                callback: (versionItem) => this.viewItemCallback(versionItem),
                permissions: ['se.version.page']
            },
            {
                i18nKey: 'se.cms.version.item.menu.edit.label',
                callback: (versionItem) => this.editItemCallback(versionItem),
                permissions: ['se.edit.version.page']
            },
            {
                i18nKey: 'se.cms.version.item.menu.rollback.label',
                callback: (versionItem) => this.rollbackItemCallback(versionItem),
                permissions: ['se.rollback.version.page.versions.menu']
            },
            {
                i18nKey: 'se.cms.version.item.menu.delete.label',
                callback: (versionItem) => this.deleteItemCallback(versionItem),
                permissions: ['se.delete.version.page']
            }
        ];
    }
    deleteItemCallback(versionItem) {
        this.managePageVersionService.deletePageVersion(versionItem.uid);
    }
    editItemCallback(versionItem) {
        this.managePageVersionService.editPageVersion(versionItem);
    }
    viewItemCallback(versionItem) {
        this.pageVersionSelectionService.selectPageVersion(versionItem);
    }
    rollbackItemCallback(versionItem) {
        this.rollbackPageVersionService.rollbackPageVersion(versionItem);
    }
};
VersionItemMenuComponent.$inject = ["managePageVersionService", "pageVersionSelectionService", "rollbackPageVersionService", "permissionService", "cdr", "userTrackingService"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ VersionItemMenuComponent.prototype, "item", void 0);
/* @ngInject */ VersionItemMenuComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-version-item-menu',
        template: `<se-popup-overlay class="se-version-item-menu__popup-anchor" [ngClass]="{ 'se-version-item-menu__popup-anchor--open': isMenuOpen }" [popupOverlay]="popupConfig" [popupOverlayTrigger]="isMenuOpen" (popupOverlayOnHide)="hideMenu()"><div *ngIf="menuItems.length > 0" (click)="onButtonClick($event)" class="sap-icon--overflow se-version-item-menu__toggle"></div><div se-popup-overlay-body class="se-version-item-menu fd-menu"><div class="se-version-item-menu__item fd-menu__list" *ngFor="let item of menuItems" (click)="executeItemCallback(item)"><span class="se-version-item-menu__item-link fd-menu__item">{{ item.i18nKey | translate }}</span></div></div></se-popup-overlay>`,
        styles: [`.se-version-item-menu{box-shadow:0 6px 12px rgba(0,0,0,.175);background-color:#fff;border-radius:4px!important;min-width:100px;width:fit-content;position:absolute;border:1px solid #d9d9d9;z-index:2000;top:96%;left:initial!important;right:0;transform:translate(5px,8px);right:-11px;top:-8px}.se-version-item-menu::before{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#d9d9d9;border-bottom-color:var(var(--fd-color-neutral-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-8px}.se-version-item-menu::after{height:0;width:0;border-style:solid;border-width:0 8px 8px 8px;border-bottom-color:#fff;border-bottom-color:var(var(--fd-color-background-4));border-left-color:transparent;border-right-color:transparent;content:"";position:absolute;top:-7px}.se-version-item-menu::after,.se-version-item-menu::before{right:10px}.se-version-item-menu::after,.se-version-item-menu::before{display:none}.se-version-item-menu__item:last-child .se-version-item-menu__item-link{color:#b00}.se-version-item-menu__popup-anchor{display:flex;flex-direction:row;align-items:center;justify-content:center;font-size:1.1428571429rem;line-height:1.25;font-weight:400}.se-version-item-menu__toggle{height:20px;width:20px;cursor:pointer}.sap-icon--overflow{color:#0a6ed1}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [ManagePageVersionService,
        smarteditcommons.PageVersionSelectionService,
        RollbackPageVersionService,
        smarteditcommons.IPermissionService,
        core.ChangeDetectorRef,
        smarteditcommons.UserTrackingService])
], /* @ngInject */ VersionItemMenuComponent);

window.__smartedit__.addDecoratorPayload("Component", "VersionsSearchComponent", {
    selector: 'se-versions-search',
    template: `<div class="se-versions-panel__search" *ngIf="showSearchControls"><div class="se-input-group"><input type="text" class="se-input-group__input-area" name="search-term" [ngModel]="searchTerm" (ngModelChange)="onChange($event)" [placeholder]="'se.cms.versions.search.placeholder' | translate"/> <span class="sap-icon--search se-input-group__addon"></span> <button class="se-input-group__addon se-input-group__clear-btn sap-icon--decline" [style.visibility]="showResetButton ? 'visible' : 'hidden'" (click)="resetSearchBox()"></button></div><span class="se-versions-panel__count" [translate]="'se.cms.versions.search.versions.found'" [translateParams]="{ versionsFound: versionsFoundCount }"></span></div>`,
    styles: [`.se-versions-panel__search{display:flex;flex-direction:row;align-items:center;justify-content:space-between;padding:8px 20px;border-bottom:1px solid #d9d9d9}.se-versions-panel__count{display:flex;flex-direction:row;align-items:center;font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;white-space:nowrap}.se-input-group{flex-grow:1;margin-right:16px}`],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ VersionsSearchComponent = class /* @ngInject */ VersionsSearchComponent {
    constructor() {
        this.searchTermChange = new core.EventEmitter();
        this.showResetButton = false;
    }
    ngOnInit() {
        this.initSearchInputFilter();
    }
    ngOnDestroy() {
        this.searchTermSubscription.unsubscribe();
    }
    onChange(value) {
        this.searchTermSubject.next(value);
    }
    resetSearchBox() {
        this.setSearchTermAndEmit('');
    }
    initSearchInputFilter() {
        this.searchTermSubject = new rxjs.Subject();
        this.searchTerm$ = this.searchTermSubject
            .asObservable()
            .pipe(operators.debounceTime(500), operators.distinctUntilChanged());
        this.searchTermSubscription = this.searchTerm$.subscribe((value) => this.setSearchTermAndEmit(value));
    }
    setSearchTermAndEmit(value) {
        this.searchTerm = value;
        this.showResetButton = this.searchTerm !== '';
        this.searchTermChange.emit(this.searchTerm);
    }
};
__decorate([
    core.Input(),
    __metadata("design:type", Number)
], /* @ngInject */ VersionsSearchComponent.prototype, "versionsFoundCount", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", Boolean)
], /* @ngInject */ VersionsSearchComponent.prototype, "showSearchControls", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", Object)
], /* @ngInject */ VersionsSearchComponent.prototype, "searchTermChange", void 0);
/* @ngInject */ VersionsSearchComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-versions-search',
        template: `<div class="se-versions-panel__search" *ngIf="showSearchControls"><div class="se-input-group"><input type="text" class="se-input-group__input-area" name="search-term" [ngModel]="searchTerm" (ngModelChange)="onChange($event)" [placeholder]="'se.cms.versions.search.placeholder' | translate"/> <span class="sap-icon--search se-input-group__addon"></span> <button class="se-input-group__addon se-input-group__clear-btn sap-icon--decline" [style.visibility]="showResetButton ? 'visible' : 'hidden'" (click)="resetSearchBox()"></button></div><span class="se-versions-panel__count" [translate]="'se.cms.versions.search.versions.found'" [translateParams]="{ versionsFound: versionsFoundCount }"></span></div>`,
        styles: [`.se-versions-panel__search{display:flex;flex-direction:row;align-items:center;justify-content:space-between;padding:8px 20px;border-bottom:1px solid #d9d9d9}.se-versions-panel__count{display:flex;flex-direction:row;align-items:center;font-size:.8571428571rem;line-height:1.3333333333;font-weight:400;white-space:nowrap}.se-input-group{flex-grow:1;margin-right:16px}`],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    })
], /* @ngInject */ VersionsSearchComponent);

window.__smartedit__.addDecoratorPayload("Component", "VersionsPanelComponent", {
    selector: 'se-versions-panel',
    template: `<div class="se-toolbar-menu-content--wrapper"><div class="se-toolbar-menu-content__header"><div class="se-toolbar-menu-content__header-title" translate="se.cms.actionitem.page.versions"></div><button class="se-versions-panel__manage-btn fd-button fd-button--compact" *ngIf="showManageButton" (click)="switchToVersioningMode()" translate="se.cms.toolbaritem.versioning.manageversions.name"></button></div><div class="se-versions-toolbar-menu-content__body" [ngClass]="{ 'se-versions-toolbar-menu-content__body--narrow': showManageButton }"><se-versions-search [versionsFoundCount]="versionsFound" [showSearchControls]="pageHasVersions()" (searchTermChange)="onSearchTermChanged($event)"></se-versions-search><div><se-infinite-scrolling class="se-versions-panel__infinite-scroll" *ngIf="pageHasVersionsOrIsLoading()" [pageSize]="10" [mask]="searchTerm" [fetchPage]="fetchPageOfVersions" (itemsChange)="onVersionItemsLoaded($event)"><div *ngFor="let item of versionItems; let isLast = last"><se-version-item [ngClass]="{ 'se-version-item--last': isLast }" [pageVersion]="item"></se-version-item></div></se-infinite-scrolling><div class="se-versions-panel__empty-list" *ngIf="!pageHasVersionsOrIsLoading()"><img src="static-resources/images/emptyVersions.svg" alt="no versions"/> <span class="se-versions-panel__no-versions-message" translate="se.cms.toolbaritem.versioning.noversionsfound"></span> <a class="se-versions-panel__manage-link fd-link" *ngIf="showManageLink" (click)="switchToVersioningMode()" translate="se.cms.toolbaritem.versioning.manageversionslink.name"></a></div></div></div></div>`,
    styles: [`.se-versions-panel .se-toolbar-menu-content__header{padding:20px;display:flex;flex-direction:row;align-items:center;justify-content:space-between;border-bottom:1px solid #d9d9d9;height:53px;padding-top:15px;height:48px}.se-versions-panel .se-toolbar-menu-content__header:first-child{font-size:1.1428571429rem;line-height:1.25;font-weight:400;color:#32363a}.se-versions-panel .se-versions-toolbar-menu-content__body .se-infinite-scrolling__container{width:340px;max-height:350px;overflow-y:auto;margin-bottom:8px}.se-versions-panel .se-versions-toolbar-menu-content__body--narrow .se-infinite-scrolling__container{width:300px}.se-versions-panel__empty-list{display:flex;flex-direction:column;align-items:center;color:#51555a;width:280px;padding:20px}.se-versions-panel__no-versions-message{padding:8px 0 4px}.se-versions-panel__manage-link{margin-bottom:20px;cursor:pointer}.se-versions-panel__manage-link:hover{text-decoration:none}`],
    encapsulation: core.ViewEncapsulation.None,
    host: {
        '[class.se-versions-panel]': 'true'
    },
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let /* @ngInject */ VersionsPanelComponent = class /* @ngInject */ VersionsPanelComponent {
    constructor(pageVersioningService, perspectiveService, logService, cdr) {
        this.pageVersioningService = pageVersioningService;
        this.perspectiveService = perspectiveService;
        this.logService = logService;
        this.cdr = cdr;
        this.switchMode = new core.EventEmitter();
        this.searchTerm = '';
        this.totalPageVersions = 0;
        this.isLoading = true;
        this.VERSIONING_MODE_KEY = smarteditcommons.CMSModesService.VERSIONING_PERSPECTIVE_KEY;
        this.fetchPageOfVersions = (search, pageSize, currentPage) => this.loadVersions(search, pageSize, currentPage);
    }
    ngOnInit() {
        this.showManageLink = this.canShowManageLink();
    }
    onVersionItemsLoaded(versionItems) {
        this.versionItems = versionItems;
    }
    onSearchTermChanged(newSearchTerm) {
        this.searchTerm = newSearchTerm;
    }
    switchToVersioningMode() {
        this.perspectiveService.switchTo(this.VERSIONING_MODE_KEY);
        this.switchMode.emit();
    }
    pageHasVersions() {
        return this.totalPageVersions > 0;
    }
    pageHasVersionsOrIsLoading() {
        return this.pageHasVersions() || this.isLoading;
    }
    canShowManageButton() {
        return this.showManageLink && this.pageHasVersions();
    }
    canShowManageLink() {
        const activePerspective = this.perspectiveService.getActivePerspective();
        return activePerspective && activePerspective.key !== this.VERSIONING_MODE_KEY;
    }
    loadVersions(mask, pageSize, currentPage) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const page = yield this.pageVersioningService.findPageVersions({
                    pageUuid: this.pageUuid,
                    currentPage,
                    mask,
                    pageSize
                });
                this.versionsFound = page.pagination.totalCount;
                if (this.isLoading) {
                    this.isLoading = false;
                    this.totalPageVersions = this.versionsFound;
                    this.showManageButton = this.canShowManageButton();
                }
                if (!this.cdr.destroyed) {
                    this.cdr.detectChanges();
                }
                return page;
            }
            catch (_a) {
                this.logService.error(`Cannot find page versions for page ${this.pageUuid}.`);
                return null;
            }
        });
    }
};
VersionsPanelComponent.$inject = ["pageVersioningService", "perspectiveService", "logService", "cdr"];
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ VersionsPanelComponent.prototype, "pageUuid", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", Object)
], /* @ngInject */ VersionsPanelComponent.prototype, "switchMode", void 0);
/* @ngInject */ VersionsPanelComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-versions-panel',
        template: `<div class="se-toolbar-menu-content--wrapper"><div class="se-toolbar-menu-content__header"><div class="se-toolbar-menu-content__header-title" translate="se.cms.actionitem.page.versions"></div><button class="se-versions-panel__manage-btn fd-button fd-button--compact" *ngIf="showManageButton" (click)="switchToVersioningMode()" translate="se.cms.toolbaritem.versioning.manageversions.name"></button></div><div class="se-versions-toolbar-menu-content__body" [ngClass]="{ 'se-versions-toolbar-menu-content__body--narrow': showManageButton }"><se-versions-search [versionsFoundCount]="versionsFound" [showSearchControls]="pageHasVersions()" (searchTermChange)="onSearchTermChanged($event)"></se-versions-search><div><se-infinite-scrolling class="se-versions-panel__infinite-scroll" *ngIf="pageHasVersionsOrIsLoading()" [pageSize]="10" [mask]="searchTerm" [fetchPage]="fetchPageOfVersions" (itemsChange)="onVersionItemsLoaded($event)"><div *ngFor="let item of versionItems; let isLast = last"><se-version-item [ngClass]="{ 'se-version-item--last': isLast }" [pageVersion]="item"></se-version-item></div></se-infinite-scrolling><div class="se-versions-panel__empty-list" *ngIf="!pageHasVersionsOrIsLoading()"><img src="static-resources/images/emptyVersions.svg" alt="no versions"/> <span class="se-versions-panel__no-versions-message" translate="se.cms.toolbaritem.versioning.noversionsfound"></span> <a class="se-versions-panel__manage-link fd-link" *ngIf="showManageLink" (click)="switchToVersioningMode()" translate="se.cms.toolbaritem.versioning.manageversionslink.name"></a></div></div></div></div>`,
        styles: [`.se-versions-panel .se-toolbar-menu-content__header{padding:20px;display:flex;flex-direction:row;align-items:center;justify-content:space-between;border-bottom:1px solid #d9d9d9;height:53px;padding-top:15px;height:48px}.se-versions-panel .se-toolbar-menu-content__header:first-child{font-size:1.1428571429rem;line-height:1.25;font-weight:400;color:#32363a}.se-versions-panel .se-versions-toolbar-menu-content__body .se-infinite-scrolling__container{width:340px;max-height:350px;overflow-y:auto;margin-bottom:8px}.se-versions-panel .se-versions-toolbar-menu-content__body--narrow .se-infinite-scrolling__container{width:300px}.se-versions-panel__empty-list{display:flex;flex-direction:column;align-items:center;color:#51555a;width:280px;padding:20px}.se-versions-panel__no-versions-message{padding:8px 0 4px}.se-versions-panel__manage-link{margin-bottom:20px;cursor:pointer}.se-versions-panel__manage-link:hover{text-decoration:none}`],
        encapsulation: core.ViewEncapsulation.None,
        host: {
            '[class.se-versions-panel]': 'true'
        },
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [smarteditcommons.PageVersioningService,
        smarteditcommons.IPerspectiveService,
        smarteditcommons.LogService,
        core.ChangeDetectorRef])
], /* @ngInject */ VersionsPanelComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageVersionMenuComponent", {
    selector: 'se-page-version-menu',
    template: `
        <div
            class="se-toolbar-menu-content se-toolbar-menu-content--versions"
            *ngIf="actionItem.isOpen"
        >
            <se-versions-panel
                *ngIf="pageUuid"
                [pageUuid]="pageUuid"
                (switchMode)="onSwitchMode()"
            ></se-versions-panel>
        </div>
    `
});
let /* @ngInject */ PageVersionMenuComponent = class /* @ngInject */ PageVersionMenuComponent {
    constructor(pageInfoService, pageVersionSelectionService, actionItem) {
        this.pageInfoService = pageInfoService;
        this.pageVersionSelectionService = pageVersionSelectionService;
        this.actionItem = actionItem;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.pageVersionSelectionService.showToolbarContextIfNeeded();
            this.pageUuid = yield this.pageInfoService.getPageUUID();
        });
    }
    onSwitchMode() {
        this.actionItem.isOpen = false;
    }
};
PageVersionMenuComponent.$inject = ["pageInfoService", "pageVersionSelectionService", "actionItem"];
/* @ngInject */ PageVersionMenuComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-version-menu',
        template: `
        <div
            class="se-toolbar-menu-content se-toolbar-menu-content--versions"
            *ngIf="actionItem.isOpen"
        >
            <se-versions-panel
                *ngIf="pageUuid"
                [pageUuid]="pageUuid"
                (switchMode)="onSwitchMode()"
            ></se-versions-panel>
        </div>
    `
    }),
    __param(2, core.Inject(smarteditcommons.TOOLBAR_ITEM)),
    __metadata("design:paramtypes", [smarteditcommons.IPageInfoService,
        smarteditcommons.PageVersionSelectionService, Object])
], /* @ngInject */ PageVersionMenuComponent);

let VersioningModule = class VersioningModule {
};
VersioningModule = __decorate([
    core.NgModule({
        imports: [
            smarteditcommons.TranslationModule.forChild(),
            common.CommonModule,
            forms.FormsModule,
            smarteditcommons.TooltipModule,
            smarteditcommons.PopupOverlayModule,
            smarteditcommons.MoreTextModule,
            smarteditcommons.InfiniteScrollingModule
        ],
        declarations: [
            VersionItemContextComponent,
            VersionItemMenuComponent,
            VersionItemComponent,
            VersionsSearchComponent,
            VersionsPanelComponent,
            PageVersionMenuComponent
        ],
        entryComponents: [PageVersionMenuComponent, VersionItemContextComponent],
        providers: [ManagePageVersionService, RollbackPageVersionService]
    })
], VersioningModule);

window.__smartedit__.addDecoratorPayload("Component", "PageTreeComponent", {
    selector: 'se-page-tree-component',
    template: `<div><div class="se-page-tree-node" [ngClass]="component.isExpanded && 'se-page-tree-node-expand'" [attr.node-smartedit-element-uuid]="!component.isHidden ?
                     component.elementUuid :
                     'hidden-component-has-no-uuid'"><div (click)="onClickComponentNode($event)" class="se-page-tree-component-node--content"><span [ngClass]="component.isExpanded ?
                                'sap-icon--navigation-down-arrow' :
                                'sap-icon--navigation-right-arrow'" class="se-page-tree-node--icon se-page-tree-component-node se-page-tree-component-node--icon"></span> <span class="se-page-tree-node--icon se-page-tree-component-node--icon sap-icon--vertical-grip"></span> <span class="se-page-tree-node--icon se-page-tree-component-node--icon sap-icon--background"></span><div class="se-page-tree-component-node--name"><span class="se-page-tree-component-node--name--up">{{component.name}}</span> <span class="se-page-tree-component-node--name--down">{{component.typeCode}}</span></div></div><se-page-tree-component-menu [component]="component" [slotId]="slotId" [slotUuid]="slotUuid" class="se-page-tree-component-node-menu"></se-page-tree-component-menu></div></div>`,
    styles: [`.se-page-tree-component-node{margin-left:8px}.se-page-tree-component-node--icon{height:32px}.se-page-tree-component-node--name{display:flex;flex-direction:column;font-family:"72";font-size:14px;line-height:16px;color:var(--sapContent_LabelColor);overflow:hidden}.se-page-tree-component-node--name--up{font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.se-page-tree-component-node--name--down{font-style:oblique;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.se-page-tree-component-node-menu{margin:0 0 0 auto}.se-page-tree-component-node--content{min-width:calc(100% - 88.25px);display:flex}`, `.se-page-tree-node{height:48px;display:flex;align-items:center;padding:0 12px;border-bottom:1px solid #f1f1f1;width:100%}.se-page-tree-node-expand{background:#e7f1fa}.se-page-tree-node--icon{font-size:14px;line-height:16px;color:var(--sapContent_IconColor);margin-right:10px}.se-page-tree-slot-node--name{font-family:"72";font-size:14px;line-height:16px;color:var(--sapContent_LabelColor);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.se-page-tree-slot-node-menu{margin:0 0 0 auto;min-width:60px}.se-page-tree-slot-node-menu--icon{margin:0 0 0 16px;font-size:14px;line-height:16px;color:var(--sapContent_IconColor)}`]
});
let /* @ngInject */ PageTreeComponent = class /* @ngInject */ PageTreeComponent {
    constructor(pageTreeNodeService, nodeInfoService, logService) {
        this.pageTreeNodeService = pageTreeNodeService;
        this.nodeInfoService = nodeInfoService;
        this.logService = logService;
        this.onComponentExpanded = new core.EventEmitter();
        this.publishComponentInterval = null;
    }
    onClickComponentNode($event) {
        return __awaiter(this, void 0, void 0, function* () {
            clearInterval(this.publishComponentInterval);
            this.component.isExpanded = !this.component.isExpanded;
            if (this.component.isExpanded) {
                this.onComponentExpanded.emit(this.component);
                yield this.pageTreeNodeService.scrollToElement(this.component.elementUuid);
                if (!(yield this.checkComponentAndPublishSelected())) {
                    let retries = 0;
                    this.publishComponentInterval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                        if (yield this.checkComponentAndPublishSelected()) {
                            clearInterval(this.publishComponentInterval);
                        }
                        if (retries > INTERVAL_RETRIES) {
                            this.logService.error(`PageTreeComponent:: onClickComponentNode error: smartedit-element ${this.component.elementUuid} is not existed`);
                            clearInterval(this.publishComponentInterval);
                        }
                        retries++;
                    }), INTERVAL_MILLISEC);
                }
            }
            else {
                this.nodeInfoService.publishComponentSelected(this.component, false, this.slotElementUuid);
            }
        });
    }
    checkComponentAndPublishSelected() {
        return __awaiter(this, void 0, void 0, function* () {
            const existedSmartEditElement = yield this.pageTreeNodeService.existedSmartEditElement(this.component.elementUuid);
            if (existedSmartEditElement) {
                this.nodeInfoService.publishComponentSelected(this.component, true, this.slotElementUuid);
                return true;
            }
            return false;
        });
    }
};
PageTreeComponent.$inject = ["pageTreeNodeService", "nodeInfoService", "logService"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ PageTreeComponent.prototype, "component", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ PageTreeComponent.prototype, "slotId", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ PageTreeComponent.prototype, "slotUuid", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], /* @ngInject */ PageTreeComponent.prototype, "slotElementUuid", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ PageTreeComponent.prototype, "onComponentExpanded", void 0);
/* @ngInject */ PageTreeComponent = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-tree-component',
        template: `<div><div class="se-page-tree-node" [ngClass]="component.isExpanded && 'se-page-tree-node-expand'" [attr.node-smartedit-element-uuid]="!component.isHidden ?
                     component.elementUuid :
                     'hidden-component-has-no-uuid'"><div (click)="onClickComponentNode($event)" class="se-page-tree-component-node--content"><span [ngClass]="component.isExpanded ?
                                'sap-icon--navigation-down-arrow' :
                                'sap-icon--navigation-right-arrow'" class="se-page-tree-node--icon se-page-tree-component-node se-page-tree-component-node--icon"></span> <span class="se-page-tree-node--icon se-page-tree-component-node--icon sap-icon--vertical-grip"></span> <span class="se-page-tree-node--icon se-page-tree-component-node--icon sap-icon--background"></span><div class="se-page-tree-component-node--name"><span class="se-page-tree-component-node--name--up">{{component.name}}</span> <span class="se-page-tree-component-node--name--down">{{component.typeCode}}</span></div></div><se-page-tree-component-menu [component]="component" [slotId]="slotId" [slotUuid]="slotUuid" class="se-page-tree-component-node-menu"></se-page-tree-component-menu></div></div>`,
        styles: [`.se-page-tree-component-node{margin-left:8px}.se-page-tree-component-node--icon{height:32px}.se-page-tree-component-node--name{display:flex;flex-direction:column;font-family:"72";font-size:14px;line-height:16px;color:var(--sapContent_LabelColor);overflow:hidden}.se-page-tree-component-node--name--up{font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.se-page-tree-component-node--name--down{font-style:oblique;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.se-page-tree-component-node-menu{margin:0 0 0 auto}.se-page-tree-component-node--content{min-width:calc(100% - 88.25px);display:flex}`, `.se-page-tree-node{height:48px;display:flex;align-items:center;padding:0 12px;border-bottom:1px solid #f1f1f1;width:100%}.se-page-tree-node-expand{background:#e7f1fa}.se-page-tree-node--icon{font-size:14px;line-height:16px;color:var(--sapContent_IconColor);margin-right:10px}.se-page-tree-slot-node--name{font-family:"72";font-size:14px;line-height:16px;color:var(--sapContent_LabelColor);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.se-page-tree-slot-node-menu{margin:0 0 0 auto;min-width:60px}.se-page-tree-slot-node-menu--icon{margin:0 0 0 16px;font-size:14px;line-height:16px;color:var(--sapContent_IconColor)}`]
    }),
    __metadata("design:paramtypes", [smarteditcommons.IPageTreeNodeService,
        exports.NodeInfoService,
        smarteditcommons.LogService])
], /* @ngInject */ PageTreeComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageTreeSlot", {
    selector: 'se-page-tree-slot',
    template: `<div><div class="se-page-tree-node" [ngClass]="node.isExpanded && 'se-page-tree-node-expand'" [attr.node-smartedit-element-uuid]="node.elementUuid"><span (click)="onClickSlotNode($event)" [ngClass]="node.isExpanded ?
                    'sap-icon--navigation-down-arrow' :
                    'sap-icon--navigation-right-arrow'" class="se-page-tree-node--icon"></span> <span class="se-page-tree-slot-node--name" (click)="onClickSlotNode($event)">{{node.componentId}}</span><div class="se-page-tree-slot-node-menu"><span class="se-page-tree-slot-node-menu--icon sap-icon--chain-link"></span> <span class="se-page-tree-slot-node-menu--icon sap-icon--synchronize"></span></div></div><div *ngIf="node.isExpanded && node.componentNodes.length"><div *ngFor="let child of node.componentNodes"><se-page-tree-component [component]="child" [slotId]="node.componentId" [slotUuid]="node.componentUuid" [slotElementUuid]="node.elementUuid" (onComponentExpanded)="onComponentExpanded($event)"></se-page-tree-component></div></div></div>`,
    styles: [`.se-page-tree-node{height:48px;display:flex;align-items:center;padding:0 12px;border-bottom:1px solid #f1f1f1;width:100%}.se-page-tree-node-expand{background:#e7f1fa}.se-page-tree-node--icon{font-size:14px;line-height:16px;color:var(--sapContent_IconColor);margin-right:10px}.se-page-tree-slot-node--name{font-family:"72";font-size:14px;line-height:16px;color:var(--sapContent_LabelColor);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.se-page-tree-slot-node-menu{margin:0 0 0 auto;min-width:60px}.se-page-tree-slot-node-menu--icon{margin:0 0 0 16px;font-size:14px;line-height:16px;color:var(--sapContent_IconColor)}`]
});
let /* @ngInject */ PageTreeSlot = class /* @ngInject */ PageTreeSlot {
    constructor(pageTreeNodeService, nodeInfoService, logService, userTrackingService) {
        this.pageTreeNodeService = pageTreeNodeService;
        this.nodeInfoService = nodeInfoService;
        this.logService = logService;
        this.userTrackingService = userTrackingService;
        this.onSlotExpanded = new core.EventEmitter();
        this.publishSlotInterval = null;
    }
    onClickSlotNode($event) {
        return __awaiter(this, void 0, void 0, function* () {
            this.userTrackingService.trackingUserAction(smarteditcommons.USER_TRACKING_FUNCTIONALITY.PAGE_STRUCTURE, 'Slot');
            clearInterval(this.publishSlotInterval);
            this.node.isExpanded = !this.node.isExpanded;
            if (!this.node.isExpanded) {
                this.node.componentNodes.forEach((component) => (component.isExpanded = false));
                this.nodeInfoService.publishSlotSelected(this.node);
            }
            else {
                this.onSlotExpanded.emit(this.node);
                yield this.pageTreeNodeService.scrollToElement(this.node.elementUuid);
                if (!(yield this.checkSlotAndPublishSelected())) {
                    let retries = 0;
                    this.publishSlotInterval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                        if (yield this.checkSlotAndPublishSelected()) {
                            clearInterval(this.publishSlotInterval);
                        }
                        if (retries > INTERVAL_RETRIES) {
                            this.logService.error(`PageTreeComponent:: onClickSlotNode error: smartedit-element ${this.node.elementUuid} is not existed`);
                            clearInterval(this.publishSlotInterval);
                        }
                        retries++;
                    }), INTERVAL_MILLISEC);
                }
            }
        });
    }
    onComponentExpanded(component) {
        this.node.componentNodes
            .filter((node) => node.elementUuid !== component.elementUuid)
            .forEach((node) => {
            if (node.isExpanded) {
                node.isExpanded = false;
                this.nodeInfoService.publishComponentSelected(node, false, this.node.elementUuid);
            }
        });
    }
    checkSlotAndPublishSelected() {
        return __awaiter(this, void 0, void 0, function* () {
            const existedSmartEditElement = yield this.pageTreeNodeService.existedSmartEditElement(this.node.elementUuid);
            if (existedSmartEditElement) {
                this.nodeInfoService.publishSlotSelected(this.node);
                return true;
            }
            return false;
        });
    }
};
PageTreeSlot.$inject = ["pageTreeNodeService", "nodeInfoService", "logService", "userTrackingService"];
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], /* @ngInject */ PageTreeSlot.prototype, "node", void 0);
__decorate([
    core.Output(),
    __metadata("design:type", core.EventEmitter)
], /* @ngInject */ PageTreeSlot.prototype, "onSlotExpanded", void 0);
/* @ngInject */ PageTreeSlot = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-tree-slot',
        template: `<div><div class="se-page-tree-node" [ngClass]="node.isExpanded && 'se-page-tree-node-expand'" [attr.node-smartedit-element-uuid]="node.elementUuid"><span (click)="onClickSlotNode($event)" [ngClass]="node.isExpanded ?
                    'sap-icon--navigation-down-arrow' :
                    'sap-icon--navigation-right-arrow'" class="se-page-tree-node--icon"></span> <span class="se-page-tree-slot-node--name" (click)="onClickSlotNode($event)">{{node.componentId}}</span><div class="se-page-tree-slot-node-menu"><span class="se-page-tree-slot-node-menu--icon sap-icon--chain-link"></span> <span class="se-page-tree-slot-node-menu--icon sap-icon--synchronize"></span></div></div><div *ngIf="node.isExpanded && node.componentNodes.length"><div *ngFor="let child of node.componentNodes"><se-page-tree-component [component]="child" [slotId]="node.componentId" [slotUuid]="node.componentUuid" [slotElementUuid]="node.elementUuid" (onComponentExpanded)="onComponentExpanded($event)"></se-page-tree-component></div></div></div>`,
        styles: [`.se-page-tree-node{height:48px;display:flex;align-items:center;padding:0 12px;border-bottom:1px solid #f1f1f1;width:100%}.se-page-tree-node-expand{background:#e7f1fa}.se-page-tree-node--icon{font-size:14px;line-height:16px;color:var(--sapContent_IconColor);margin-right:10px}.se-page-tree-slot-node--name{font-family:"72";font-size:14px;line-height:16px;color:var(--sapContent_LabelColor);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.se-page-tree-slot-node-menu{margin:0 0 0 auto;min-width:60px}.se-page-tree-slot-node-menu--icon{margin:0 0 0 16px;font-size:14px;line-height:16px;color:var(--sapContent_IconColor)}`]
    }),
    __metadata("design:paramtypes", [smarteditcommons.IPageTreeNodeService,
        exports.NodeInfoService,
        smarteditcommons.LogService,
        smarteditcommons.UserTrackingService])
], /* @ngInject */ PageTreeSlot);

window.__smartedit__.addDecoratorPayload("Component", "PageTreePanel", {
    selector: 'se-page-tree',
    template: `<div class="se-page-tree"><div class="se-page-tree--header"><span class="se-page-tree--header--icon sap-icon--Chart-Tree-Map"></span> <span class="se-page-tree--header--title">{{ 'se.page.tree.title' | translate }}</span></div><div *ngFor="let node of slotNodes"><se-page-tree-slot [node]="node" (onSlotExpanded)="onSlotExpanded($event)"></se-page-tree-slot></div></div>`,
    styles: [`.se-page-tree{background:#fff;width:100%;height:100%;filter:drop-shadow(0 4px 4px rgba(0, 0, 0, .25));border-radius:4px;overflow-y:scroll}.se-page-tree::-webkit-scrollbar{display:none}.se-page-tree--header{height:48px;padding:0 12px;display:flex;align-items:center;box-shadow:0 1px 0 #dedede}.se-page-tree--header--icon{width:16px;height:18px;line-height:19px;font-size:16px;color:var(--sapContent_IconColor);text-align:center}.se-page-tree--header--title{font-family:"72";font-size:18px;line-height:21px;margin:0 10px;color:#595959}`]
});
let /* @ngInject */ PageTreePanel = class /* @ngInject */ PageTreePanel {
    constructor(crossFrameEventService, nodeInfoService, yjQuery, cdr, logService) {
        this.crossFrameEventService = crossFrameEventService;
        this.nodeInfoService = nodeInfoService;
        this.yjQuery = yjQuery;
        this.cdr = cdr;
        this.logService = logService;
        this.slotNodes = null;
        this.scrollToNodeInterval = null;
        this.expandComponentNodeInterval = null;
        this.crossFrameEventService.subscribe(smarteditcommons.EVENT_OPEN_IN_PAGE_TREE, this.handleEventOpenInPageTree.bind(this));
        this.crossFrameEventService.subscribe(smarteditcommons.EVENT_PART_REFRESH_TREE_NODE, (_eventId, eventData) => __awaiter(this, void 0, void 0, function* () { return (this.slotNodes = yield this.nodeInfoService.updatePartTreeNodesInfo(eventData)); }));
        this.crossFrameEventService.subscribe(smarteditcommons.EVENT_OVERALL_REFRESH_TREE_NODE, () => __awaiter(this, void 0, void 0, function* () { return (this.slotNodes = yield this.nodeInfoService.buildNodesInfo()); }));
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.slotNodes = yield this.nodeInfoService.buildNodesInfo();
        });
    }
    onSlotExpanded(slot) {
        this.slotNodes
            .filter((node) => slot.elementUuid !== node.elementUuid)
            .forEach((node) => {
            node.isExpanded = false;
            node.componentNodes.forEach((component) => (component.isExpanded = false));
        });
    }
    handleEventOpenInPageTree(eventId, elementUuid) {
        clearInterval(this.expandComponentNodeInterval);
        if (!this.expandComponentNode(elementUuid)) {
            let retries = 0;
            this.expandComponentNodeInterval = setInterval(() => {
                if (this.expandComponentNode(elementUuid)) {
                    clearInterval(this.expandComponentNodeInterval);
                }
                if (retries > INTERVAL_RETRIES) {
                    this.logService.error(`PageTreeComponent:: handleEventOpenInPageTree error: expand component node ${elementUuid} failed`);
                    clearInterval(this.expandComponentNodeInterval);
                }
                retries++;
            }, INTERVAL_MILLISEC);
        }
    }
    expandComponentNode(elementUuid) {
        if (this.slotNodes) {
            this.slotNodes.forEach((slot) => {
                let componentNode = null;
                slot.componentNodes.forEach((component) => {
                    if (component.elementUuid === elementUuid) {
                        component.isExpanded = true;
                        componentNode = component;
                    }
                    else {
                        component.isExpanded = false;
                    }
                });
                if (componentNode) {
                    slot.isExpanded = true;
                    this.scrollToNodeByInterval(componentNode.elementUuid);
                }
                else {
                    slot.isExpanded = false;
                }
            });
            return true;
        }
        return false;
    }
    scrollToNode(elementUuid) {
        const element = this.yjQuery(`div[node-smartedit-element-uuid="${elementUuid}"]`)
            .get()
            .shift();
        if (element) {
            element.scrollIntoView({ behavior: 'smooth', block: 'center' });
            return true;
        }
        return false;
    }
    scrollToNodeByInterval(elementUuid) {
        clearInterval(this.scrollToNodeInterval);
        if (!this.scrollToNode(elementUuid)) {
            let retries = 0;
            this.scrollToNodeInterval = setInterval(() => {
                if (this.scrollToNode(elementUuid)) {
                    clearInterval(this.scrollToNodeInterval);
                }
                if (retries > INTERVAL_RETRIES) {
                    this.logService.error(`PageTreeComponent:: scrollToNodeByInterval error: scroll to tree node ${elementUuid} failed!`);
                    clearInterval(this.scrollToNodeInterval);
                }
                retries++;
            }, INTERVAL_MILLISEC);
        }
    }
};
PageTreePanel.$inject = ["crossFrameEventService", "nodeInfoService", "yjQuery", "cdr", "logService"];
/* @ngInject */ PageTreePanel = __decorate([
    smarteditcommons.SeDowngradeComponent(),
    core.Component({
        selector: 'se-page-tree',
        template: `<div class="se-page-tree"><div class="se-page-tree--header"><span class="se-page-tree--header--icon sap-icon--Chart-Tree-Map"></span> <span class="se-page-tree--header--title">{{ 'se.page.tree.title' | translate }}</span></div><div *ngFor="let node of slotNodes"><se-page-tree-slot [node]="node" (onSlotExpanded)="onSlotExpanded($event)"></se-page-tree-slot></div></div>`,
        styles: [`.se-page-tree{background:#fff;width:100%;height:100%;filter:drop-shadow(0 4px 4px rgba(0, 0, 0, .25));border-radius:4px;overflow-y:scroll}.se-page-tree::-webkit-scrollbar{display:none}.se-page-tree--header{height:48px;padding:0 12px;display:flex;align-items:center;box-shadow:0 1px 0 #dedede}.se-page-tree--header--icon{width:16px;height:18px;line-height:19px;font-size:16px;color:var(--sapContent_IconColor);text-align:center}.se-page-tree--header--title{font-family:"72";font-size:18px;line-height:21px;margin:0 10px;color:#595959}`]
    }),
    __param(2, core.Inject(smarteditcommons.YJQUERY_TOKEN)),
    __metadata("design:paramtypes", [smarteditcommons.CrossFrameEventService,
        exports.NodeInfoService, Function, core.ChangeDetectorRef,
        smarteditcommons.LogService])
], /* @ngInject */ PageTreePanel);

class ParentMenu {
    constructor() {
        this.remainOpenMap = {};
    }
}

window.__smartedit__.addDecoratorPayload("Component", "PageTreeMenuItemOverlayComponent", {
    template: `
        <div *ngIf="item.action.component">
            <ng-container
                *ngComponentOutlet="item.action.component; injector: componentInjector"
            ></ng-container>
        </div>
    `,
    selector: 'se-contextual-menu-item-overlay'
});
let PageTreeMenuItemOverlayComponent = class PageTreeMenuItemOverlayComponent {
    constructor(data, parent, injector) {
        this.data = data;
        this.parent = parent;
        this.injector = injector;
    }
    ngOnInit() {
        this.createComponentInjector();
    }
    get item() {
        return this.data.item;
    }
    createComponentInjector() {
        this.componentInjector = core.Injector.create({
            parent: this.injector,
            providers: [
                {
                    provide: smarteditcommons.CONTEXTUAL_MENU_ITEM_DATA,
                    useValue: {
                        componentAttributes: this.parent.componentAttributes,
                        setRemainOpen: (key, remainOpen) => this.parent.setRemainOpen(key, remainOpen)
                    }
                }
            ]
        });
    }
};
PageTreeMenuItemOverlayComponent = __decorate([
    core.Component({
        template: `
        <div *ngIf="item.action.component">
            <ng-container
                *ngComponentOutlet="item.action.component; injector: componentInjector"
            ></ng-container>
        </div>
    `,
        selector: 'se-contextual-menu-item-overlay'
    }),
    __param(0, core.Inject(smarteditcommons.POPUP_OVERLAY_DATA)),
    __metadata("design:paramtypes", [Object, ParentMenu,
        core.Injector])
], PageTreeMenuItemOverlayComponent);

window.__smartedit__.addDecoratorPayload("Component", "PageTreeMoreItemsComponent", {
    selector: 'se-page-tree-more-items',
    styles: [`.se-page-tree-component-menu{margin:0 0 0 auto;display:flex;flex-direction:row}.se-page-tree-component-menu--icon{margin:0 0 0 16px;font-size:14px;line-height:16px;color:var(--sapContent_IconColor)}.se-page-tree-component-more{min-width:118px}.se-page-tree-component-more-menu{display:block}.se-page-tree-component-more-menu--span{margin-left:12px;font-family:"72";font-size:14px;line-height:24px;color:#000;display:block;min-width:104px}.is-storefront .fd-popover__popper{border-radius:0}`],
    template: `
        <div class="se-page-tree-component-more">
            <ul id="{{ parent.component.uid }}-{{ parent.component.typeCode }}-more-menu">
                <li
                    *ngFor="let item of parent.getItems(); let $index = index"
                    [attr.data-smartedit-id]="parent.component.uid"
                    [attr.data-smartedit-type]="parent.component.typeCode"
                    class="se-page-tree-component-more-menu"
                >
                    <se-popup-overlay
                        [popupOverlay]="itemTemplateOverlayWrapper"
                        [popupOverlayTrigger]="parent.canShowTemplate(item)"
                        [popupOverlayData]="{ item: item }"
                        (popupOverlayOnHide)="parent.onHideItemPopup(true)"
                    >
                        <span
                            class="se-page-tree-component-more-menu--span"
                            (click)="parent.triggerMenuItemAction(item, $event)"
                        >
                            {{ item.i18nKey | translate }}
                        </span>
                    </se-popup-overlay>
                </li>
            </ul>
        </div>
    `
});
let PageTreeMoreItemsComponent = class PageTreeMoreItemsComponent {
    constructor(parent) {
        this.parent = parent;
        this.itemTemplateOverlayWrapper = {
            component: PageTreeMenuItemOverlayComponent
        };
    }
};
PageTreeMoreItemsComponent = __decorate([
    core.Component({
        selector: 'se-page-tree-more-items',
        styles: [`.se-page-tree-component-menu{margin:0 0 0 auto;display:flex;flex-direction:row}.se-page-tree-component-menu--icon{margin:0 0 0 16px;font-size:14px;line-height:16px;color:var(--sapContent_IconColor)}.se-page-tree-component-more{min-width:118px}.se-page-tree-component-more-menu{display:block}.se-page-tree-component-more-menu--span{margin-left:12px;font-family:"72";font-size:14px;line-height:24px;color:#000;display:block;min-width:104px}.is-storefront .fd-popover__popper{border-radius:0}`],
        template: `
        <div class="se-page-tree-component-more">
            <ul id="{{ parent.component.uid }}-{{ parent.component.typeCode }}-more-menu">
                <li
                    *ngFor="let item of parent.getItems(); let $index = index"
                    [attr.data-smartedit-id]="parent.component.uid"
                    [attr.data-smartedit-type]="parent.component.typeCode"
                    class="se-page-tree-component-more-menu"
                >
                    <se-popup-overlay
                        [popupOverlay]="itemTemplateOverlayWrapper"
                        [popupOverlayTrigger]="parent.canShowTemplate(item)"
                        [popupOverlayData]="{ item: item }"
                        (popupOverlayOnHide)="parent.onHideItemPopup(true)"
                    >
                        <span
                            class="se-page-tree-component-more-menu--span"
                            (click)="parent.triggerMenuItemAction(item, $event)"
                        >
                            {{ item.i18nKey | translate }}
                        </span>
                    </se-popup-overlay>
                </li>
            </ul>
        </div>
    `
    }),
    __metadata("design:paramtypes", [ParentMenu])
], PageTreeMoreItemsComponent);

var PageTreeComponentMenuComponent_1;
window.__smartedit__.addDecoratorPayload("Component", "PageTreeComponentMenuComponent", {
    selector: 'se-page-tree-component-menu',
    template: `<div class="se-page-tree-component-menu"><span [ngClass]="component.isHidden ? 'sap-icon--hide' : 'sap-icon--show'" class="se-page-tree-component-menu--icon"></span><se-popup-overlay *ngIf="!!leftButton" [popupOverlay]="itemTemplateOverlayWrapper" [popupOverlayTrigger]="canShowTemplate(leftButton)" [popupOverlayData]="{ item: leftButton }" (popupOverlayOnHide)="onHideItemPopup(false)"><span class="se-page-tree-component-menu--icon" [ngClass]="leftButton.displayIconClass" (click)="triggerMenuItemAction(leftButton, $event)"></span></se-popup-overlay><se-popup-overlay [popupOverlay]="moreMenuPopupConfig" [popupOverlayTrigger]="moreMenuIsOpen"><span *ngIf="items && items.length > 0" (click)="toggleMoreMenu()" class="se-page-tree-component-menu--icon sap-icon--overflow"></span></se-popup-overlay></div>`,
    styles: [`.se-page-tree-component-menu{margin:0 0 0 auto;display:flex;flex-direction:row}.se-page-tree-component-menu--icon{margin:0 0 0 16px;font-size:14px;line-height:16px;color:var(--sapContent_IconColor)}.se-page-tree-component-more{min-width:118px}.se-page-tree-component-more-menu{display:block}.se-page-tree-component-more-menu--span{margin-left:12px;font-family:"72";font-size:14px;line-height:24px;color:#000;display:block;min-width:104px}.is-storefront .fd-popover__popper{border-radius:0}`],
    providers: [
        { provide: ParentMenu, useExisting: core.forwardRef(() => PageTreeComponentMenuComponent_1) }
    ],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
let PageTreeComponentMenuComponent = PageTreeComponentMenuComponent_1 = class PageTreeComponentMenuComponent {
    constructor(pageTreeComponentMenuService, cdr) {
        this.pageTreeComponentMenuService = pageTreeComponentMenuService;
        this.cdr = cdr;
        this.remainOpenMap = {};
        this.moreMenuIsOpen = false;
        this.moreMenuPopupConfig = {
            component: PageTreeMoreItemsComponent,
            halign: 'left'
        };
        this.itemTemplateOverlayWrapper = {
            component: PageTreeMenuItemOverlayComponent
        };
    }
    getItems() {
        return this.items;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.componentAttributes = {
                smarteditCatalogVersionUuid: this.component.catalogVersion,
                smarteditComponentId: this.component.uid,
                smarteditComponentType: this.component.typeCode,
                smarteditComponentUuid: this.component.uuid,
                smarteditElementUuid: this.component.elementUuid
            };
            this.menuConfiguration = {
                componentType: this.component.typeCode,
                componentId: this.component.uid,
                componentUuid: this.component.uuid,
                containerType: this.component.containerType,
                containerId: this.component.containerId,
                componentAttributes: this.componentAttributes,
                slotId: this.slotId,
                slotUuid: this.slotUuid,
                isComponentHidden: this.component.isHidden
            };
            const newItems = yield this.pageTreeComponentMenuService.getPageTreeComponentMenus(this.menuConfiguration);
            if (newItems && newItems.length > 0) {
                this.items = newItems.filter((item) => !!item);
                this.leftButton = this.items.shift();
            }
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        });
    }
    setRemainOpen(key, remainOpen) {
        this.remainOpenMap[key] = remainOpen;
    }
    showOverlay(active) {
        if (active) {
            return true;
        }
        return Object.keys(this.remainOpenMap).reduce((isOpen, key) => isOpen || this.remainOpenMap[key], false);
    }
    canShowTemplate(menuItem) {
        return this.displayedItem === menuItem;
    }
    onHideItemPopup(hideMoreMenu = false) {
        this.displayedItem = null;
        if (hideMoreMenu) {
            this.moreMenuIsOpen = false;
        }
    }
    triggerMenuItemAction(item, $event) {
        this.moreMenuIsOpen = false;
        if (item.action.component) {
            if (this.displayedItem === item) {
                this.displayedItem = null;
            }
            else {
                this.displayedItem = item;
            }
        }
        else if (item.action.callback) {
            item.action.callback(this.menuConfiguration, $event);
        }
    }
    toggleMoreMenu() {
        this.moreMenuIsOpen = !this.moreMenuIsOpen;
    }
};
__decorate([
    core.Input(),
    __metadata("design:type", Object)
], PageTreeComponentMenuComponent.prototype, "component", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], PageTreeComponentMenuComponent.prototype, "slotId", void 0);
__decorate([
    core.Input(),
    __metadata("design:type", String)
], PageTreeComponentMenuComponent.prototype, "slotUuid", void 0);
PageTreeComponentMenuComponent = PageTreeComponentMenuComponent_1 = __decorate([
    core.Component({
        selector: 'se-page-tree-component-menu',
        template: `<div class="se-page-tree-component-menu"><span [ngClass]="component.isHidden ? 'sap-icon--hide' : 'sap-icon--show'" class="se-page-tree-component-menu--icon"></span><se-popup-overlay *ngIf="!!leftButton" [popupOverlay]="itemTemplateOverlayWrapper" [popupOverlayTrigger]="canShowTemplate(leftButton)" [popupOverlayData]="{ item: leftButton }" (popupOverlayOnHide)="onHideItemPopup(false)"><span class="se-page-tree-component-menu--icon" [ngClass]="leftButton.displayIconClass" (click)="triggerMenuItemAction(leftButton, $event)"></span></se-popup-overlay><se-popup-overlay [popupOverlay]="moreMenuPopupConfig" [popupOverlayTrigger]="moreMenuIsOpen"><span *ngIf="items && items.length > 0" (click)="toggleMoreMenu()" class="se-page-tree-component-menu--icon sap-icon--overflow"></span></se-popup-overlay></div>`,
        styles: [`.se-page-tree-component-menu{margin:0 0 0 auto;display:flex;flex-direction:row}.se-page-tree-component-menu--icon{margin:0 0 0 16px;font-size:14px;line-height:16px;color:var(--sapContent_IconColor)}.se-page-tree-component-more{min-width:118px}.se-page-tree-component-more-menu{display:block}.se-page-tree-component-more-menu--span{margin-left:12px;font-family:"72";font-size:14px;line-height:24px;color:#000;display:block;min-width:104px}.is-storefront .fd-popover__popper{border-radius:0}`],
        providers: [
            { provide: ParentMenu, useExisting: core.forwardRef(() => PageTreeComponentMenuComponent_1) }
        ],
        changeDetection: core.ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [exports.PageTreeComponentMenuService,
        core.ChangeDetectorRef])
], PageTreeComponentMenuComponent);

let PageTreeModule = class PageTreeModule {
};
PageTreeModule = __decorate([
    core.NgModule({
        imports: [common.CommonModule, smarteditcommons.PopupOverlayModule, smarteditcommons.TranslationModule.forChild()],
        declarations: [
            PageTreePanel,
            PageTreeSlot,
            PageTreeComponent,
            PageTreeMoreItemsComponent,
            PageTreeMenuItemOverlayComponent,
            PageTreeComponentMenuComponent
        ],
        entryComponents: [
            PageTreePanel,
            PageTreeSlot,
            PageTreeComponent,
            PageTreeMoreItemsComponent,
            PageTreeMenuItemOverlayComponent,
            PageTreeComponentMenuComponent
        ]
    })
], PageTreeModule);

exports.CmssmarteditContainerModule = class CmssmarteditContainerModule {
};
exports.CmssmarteditContainerModule = __decorate([
    smarteditcommons.SeEntryModule('cmssmarteditContainer'),
    core.NgModule({
        imports: [
            cmscommons.CmsCommonsModule,
            platformBrowser.BrowserModule,
            _static.UpgradeModule,
            smarteditcommons.SharedComponentsModule,
            smarteditcommons.SeGenericEditorModule,
            smarteditcommons.MessageModule,
            smarteditcommons.TooltipModule,
            WorkflowModule,
            VersioningModule,
            SynchronizationModule,
            smarteditcommons.SeTranslationModule.forChild(),
            smarteditcommons.L10nPipeModule,
            NavigationModule,
            GenericEditorWidgetsModule,
            MediaModule,
            PageComponentsModule,
            TrashedPageListModule,
            RestrictionsModule,
            exports.CmsComponentsModule,
            PageTreeModule,
            forms.FormsModule,
            // Routes are "flat" because there are routes registered also in smarteditcontainer.ts
            // And they conflict each (overriding themselves)
            smarteditcommons.SeRouteService.provideNgRoute([
                {
                    path: `${smarteditcommons.NG_ROUTE_PREFIX}${cmscommons.TRASHED_PAGE_LIST_PATH}`,
                    component: TrashedPageListComponent,
                    canActivate: [exports.ExperienceGuard]
                },
                {
                    path: `${smarteditcommons.NG_ROUTE_PREFIX}${cmscommons.PAGE_LIST_PATH}`,
                    component: PageListComponent,
                    canActivate: [exports.ExperienceGuard],
                    titleI18nKey: 'se.cms.pagelist.title',
                    priority: 20
                },
                {
                    path: `${smarteditcommons.NG_ROUTE_PREFIX}${cmscommons.NAVIGATION_MANAGEMENT_PAGE_PATH}`,
                    component: NavigationManagementPageComponent,
                    titleI18nKey: 'se.cms.toolbaritem.navigationmenu.name',
                    canActivate: [exports.ExperienceGuard],
                    priority: 10
                }
            ], { useHash: true, initialNavigation: true, onSameUrlNavigation: 'reload' })
        ],
        providers: [
            PageRestrictionsRestService,
            exports.PageRestrictionsCriteriaService,
            exports.ExperienceGuard,
            exports.ActionableAlertService,
            exports.PageRestrictionsCriteriaService,
            exports.PageRestoredAlertService,
            exports.PageRestoreModalService,
            exports.HomepageService,
            exports.ManagePageService,
            PageTypesRestrictionTypesRestService,
            exports.PageTypesRestrictionTypesService,
            RestrictionTypesRestService,
            exports.RestrictionTypesService,
            exports.ProductCategoryService,
            CatalogVersionRestService,
            PagesRestService,
            PagesVariationsRestService,
            PagesFallbacksRestService,
            PageTypeService,
            StructuresRestService,
            StructureModeManagerFactory,
            TypeStructureRestService,
            exports.RestrictionsService,
            exports.PageRestrictionsService,
            exports.GenericEditorModalService,
            exports.RestrictionsStepHandlerFactory,
            PageFacade,
            exports.PageDisplayConditionsService,
            exports.PageTemplateService,
            DisplayConditionsFacade,
            exports.CmsDragAndDropService,
            exports.DisplayConditionsEditorModel,
            exports.ContextAwareCatalogService,
            exports.RulesAndPermissionsRegistrationService,
            exports.AddPageWizardService,
            exports.ClonePageAlertService,
            exports.NodeInfoService,
            exports.PageTreeComponentMenuService,
            {
                provide: http.HTTP_INTERCEPTORS,
                useClass: cmscommons.VersionExperienceInterceptor,
                multi: true
            },
            {
                provide: http.HTTP_INTERCEPTORS,
                useClass: smarteditcommons.ResponseAdapterInterceptor,
                multi: true
            },
            {
                provide: cmscommons.IPageContentSlotsComponentsRestService,
                useClass: PageContentSlotsComponentsRestService
            },
            {
                provide: smarteditcommons.ISyncPollingService,
                useClass: exports.SyncPollingService
            },
            {
                provide: cmscommons.IRemoveComponentService,
                useClass: exports.RemoveComponentService
            },
            {
                provide: smarteditcommons.IPageService,
                useClass: exports.PageService
            },
            {
                provide: cmscommons.IContextAwareEditableItemService,
                useClass: exports.ContextAwareEditableItemService
            },
            {
                provide: smarteditcommons.IEditorModalService,
                useClass: exports.EditorModalService
            },
            {
                provide: cmscommons.IComponentVisibilityAlertService,
                useClass: exports.ComponentVisibilityAlertService
            },
            {
                provide: cmscommons.IComponentSharedService,
                useClass: exports.ComponentSharedService
            },
            {
                provide: smarteditcommons.ISlotRestrictionsService,
                useClass: exports.SlotRestrictionsService
            },
            {
                provide: cmscommons.ISlotVisibilityService,
                useClass: exports.SlotVisibilityService
            },
            {
                provide: cmscommons.IEditorEnablerService,
                useClass: exports.EditorEnablerService
            },
            {
                provide: cmscommons.IComponentMenuConditionAndCallbackService,
                useClass: exports.ComponentMenuConditionAndCallbackService
            },
            smarteditcommons.moduleUtils.bootstrap((toolbarServiceFactory, rulesAndPermissionsRegistrationService, cmsGenericEditorConfigurationService, featureService, systemEventService, clonePageWizardService, managePageVersionService, rollbackPageVersionService, catalogDetailsService, cmsDragAndDropService, perspectiveService, inViewElementObserver, 
            // Iframe does not work properly without it. Nothing happens when you click on "Edit" component button.
            editorModalService, 
            // Need to inject for gatewayProxy initialization of componentVisibilityAlertService.
            componentVisibilityAlertService, nodeInfoService, crossFrameEventService, pageTreeService, settingsService) => __awaiter(void 0, void 0, void 0, function* () {
                const smartEditTrashPageToolbarService = toolbarServiceFactory.getToolbarService('smartEditTrashPageToolbar');
                smartEditTrashPageToolbarService.addItems([
                    {
                        key: 'se.cms.pages.list.link',
                        type: smarteditcommons.ToolbarItemType.TEMPLATE,
                        component: PagesLinkComponent,
                        priority: 1,
                        section: smarteditcommons.ToolbarSection.left
                    }
                ]);
                rulesAndPermissionsRegistrationService.register();
                cmsGenericEditorConfigurationService.setDefaultEditorFieldMappings();
                cmsGenericEditorConfigurationService.setDefaultTabFieldMappings();
                cmsGenericEditorConfigurationService.setDefaultTabsConfiguration();
                const pageTreeEnabled = yield settingsService.get('smartedit.pagetree.enabled');
                if (pageTreeEnabled === 'true') {
                    featureService.addToolbarItem({
                        toolbarId: 'smartEditPerspectiveToolbar',
                        key: 'se.cms.pageTreeMenu',
                        nameI18nKey: 'se.cms.toolbaritem.pagetreemenu.name',
                        type: 'ACTION',
                        iconClassName: 'icon-tree se-toolbar-menu-ddlb--button__icon',
                        priority: 100,
                        section: 'left',
                        callback: () => {
                            crossFrameEventService.publish(smarteditcommons.EVENT_PAGE_TREE_PANEL_SWITCH);
                        },
                        permissions: ['se.read.page']
                    });
                    pageTreeService.registerTreeComponent({
                        component: PageTreePanel
                    });
                }
                featureService.addToolbarItem({
                    toolbarId: 'smartEditPerspectiveToolbar',
                    key: 'se.cms.componentMenuTemplate',
                    type: 'HYBRID_ACTION',
                    nameI18nKey: 'se.cms.componentmenu.btn.label.addcomponent',
                    descriptionI18nKey: 'cms.toolbaritem.componentmenutemplate.description',
                    priority: 101,
                    section: 'left',
                    dropdownPosition: 'left',
                    iconClassName: 'icon-add se-toolbar-menu-ddlb--button__icon',
                    callback: () => {
                        systemEventService.publish(OPEN_COMPONENT_EVENT, {});
                    },
                    component: exports.ComponentMenuComponent,
                    permissions: ['se.add.component'],
                    keepAliveOnClose: true
                });
                featureService.addToolbarItem({
                    toolbarId: 'smartEditPerspectiveToolbar',
                    key: 'se.cms.pageInfoMenu',
                    type: 'TEMPLATE',
                    nameI18nKey: 'se.cms.pageinfo.menu.btn.label',
                    priority: 140,
                    section: 'left',
                    component: PageInfoMenuComponent,
                    permissions: ['se.read.page']
                });
                featureService.addToolbarItem({
                    toolbarId: 'smartEditPerspectiveToolbar',
                    key: 'se.cms.clonePageMenu',
                    type: 'ACTION',
                    nameI18nKey: 'se.cms.clonepage.menu.btn.label',
                    iconClassName: 'icon-duplicate se-toolbar-menu-ddlb--button__icon',
                    callback: () => {
                        clonePageWizardService.openClonePageWizard();
                    },
                    priority: 130,
                    section: 'left',
                    permissions: ['se.clone.page']
                });
                // sync 120
                featureService.addToolbarItem({
                    toolbarId: 'smartEditPerspectiveToolbar',
                    key: 'se.cms.pageSyncMenu',
                    nameI18nKey: 'se.cms.toolbaritem.pagesyncmenu.name',
                    type: 'TEMPLATE',
                    component: PageSyncMenuToolbarItemComponent,
                    priority: 102,
                    section: 'left',
                    permissions: ['se.sync.page']
                });
                featureService.addToolbarItem({
                    toolbarId: 'smartEditPerspectiveToolbar',
                    key: 'deletePageMenu',
                    nameI18nKey: 'se.cms.actionitem.page.trash',
                    type: 'TEMPLATE',
                    component: DeletePageToolbarItemComponent,
                    priority: 150,
                    section: 'left',
                    permissions: ['se.delete.page.menu']
                });
                // versions 102
                featureService.addToolbarItem({
                    toolbarId: 'smartEditPerspectiveToolbar',
                    key: 'se.cms.pageVersionsMenu',
                    type: 'HYBRID_ACTION',
                    nameI18nKey: 'se.cms.actionitem.page.versions',
                    priority: 104,
                    section: 'left',
                    iconClassName: 'icon-timesheet se-toolbar-menu-ddlb--button__icon',
                    component: PageVersionMenuComponent,
                    contextComponent: VersionItemContextComponent,
                    permissions: ['se.version.page'],
                    keepAliveOnClose: true
                });
                featureService.addToolbarItem({
                    toolbarId: 'smartEditPerspectiveToolbar',
                    key: 'se.cms.createVersionMenu',
                    type: 'ACTION',
                    nameI18nKey: 'se.cms.actionitem.page.versions.create',
                    iconClassName: 'icon-add se-toolbar-menu-ddlb--button__icon',
                    callback: () => {
                        managePageVersionService.createPageVersion();
                    },
                    priority: 120,
                    section: 'left',
                    permissions: ['se.version.page', 'se.create.version.page']
                });
                featureService.addToolbarItem({
                    toolbarId: 'smartEditPerspectiveToolbar',
                    key: 'se.cms.rollbackVersionMenu',
                    type: 'ACTION',
                    nameI18nKey: 'se.cms.actionitem.page.versions.rollback',
                    iconClassName: 'hyicon hyicon-rollback se-toolbar-menu-ddlb--button__icon',
                    callback: () => {
                        rollbackPageVersionService.rollbackPageVersion();
                    },
                    priority: 120,
                    section: 'left',
                    permissions: ['se.version.page', 'se.rollback.version.page']
                });
                featureService.addToolbarItem({
                    toolbarId: 'smartEditPerspectiveToolbar',
                    key: 'se.cms.pageWorkflowMenu',
                    type: 'TEMPLATE',
                    nameI18nKey: 'se.cms.workflow.toolbar.view.workflow.menu',
                    component: PageWorkflowMenuComponent,
                    priority: 110,
                    section: 'right'
                });
                featureService.addToolbarItem({
                    toolbarId: 'smartEditPerspectiveToolbar',
                    key: 'se.cms.pageDisplayStatus',
                    type: 'TEMPLATE',
                    nameI18nKey: 'se.cms.page.display.status',
                    component: PageDisplayStatusWrapperComponent,
                    priority: 120,
                    section: 'right',
                    permissions: ['se.show.page.status']
                });
                featureService.addToolbarItem({
                    toolbarId: 'smartEditPerspectiveToolbar',
                    key: 'se.cms.pageApprovalSelector',
                    type: 'TEMPLATE',
                    nameI18nKey: 'se.cms.page.approval.selector',
                    component: PageApprovalSelectorComponent,
                    priority: 165,
                    section: 'right',
                    permissions: ['se.force.page.approval']
                });
                const smartEditHeaderToolbarService = toolbarServiceFactory.getToolbarService('smartEditHeaderToolbar');
                smartEditHeaderToolbarService.addItems([
                    {
                        key: 'se.cms.workflowInbox',
                        type: smarteditcommons.ToolbarItemType.TEMPLATE,
                        component: WorkflowInboxComponent,
                        priority: 5,
                        section: smarteditcommons.ToolbarSection.right,
                        dropdownPosition: smarteditcommons.ToolbarDropDownPosition.right
                    }
                ]);
                const smartEditNavigationToolbarService = toolbarServiceFactory.getToolbarService('smartEditNavigationToolbar');
                smartEditNavigationToolbarService.addItems([
                    {
                        key: 'se.cms.shortcut',
                        type: smarteditcommons.ToolbarItemType.TEMPLATE,
                        component: smarteditcommons.ShortcutLinkComponent,
                        priority: 1,
                        section: smarteditcommons.ToolbarSection.left
                    }
                ]);
                const smartEditPagesToolbarService = toolbarServiceFactory.getToolbarService('smartEditPagesToolbar');
                smartEditPagesToolbarService.addItems([
                    {
                        key: 'se.cms.shortcut',
                        type: smarteditcommons.ToolbarItemType.TEMPLATE,
                        component: smarteditcommons.ShortcutLinkComponent,
                        priority: 1,
                        section: smarteditcommons.ToolbarSection.left
                    },
                    {
                        key: 'se.cms.trash.page.link',
                        type: smarteditcommons.ToolbarItemType.TEMPLATE,
                        component: TrashLinkComponent,
                        priority: 1,
                        section: smarteditcommons.ToolbarSection.right
                    }
                ]);
                catalogDetailsService.addItems([
                    {
                        component: PageListLinkComponent
                    },
                    {
                        component: NavigationEditorLinkComponent
                    }
                ]);
                catalogDetailsService.addItems([
                    {
                        component: CatalogDetailsSyncComponent
                    }
                ], smarteditcommons.CATALOG_DETAILS_COLUMNS.RIGHT);
                featureService.register({
                    key: 'se.cms.html5DragAndDrop.outer',
                    nameI18nKey: 'se.cms.dragAndDrop.name',
                    descriptionI18nKey: 'se.cms.dragAndDrop.description',
                    enablingCallback: () => {
                        cmsDragAndDropService.register();
                        cmsDragAndDropService.apply();
                    },
                    disablingCallback: () => {
                        cmsDragAndDropService.unregister();
                    }
                });
                perspectiveService.register({
                    key: smarteditcommons.CMSModesService.BASIC_PERSPECTIVE_KEY,
                    nameI18nKey: 'se.cms.perspective.basic.name',
                    descriptionI18nKey: 'se.hotkey.tooltip',
                    features: [
                        'se.contextualMenu',
                        'se.cms.dragandropbutton',
                        'se.cms.remove',
                        'se.cms.edit',
                        'se.cms.componentMenuTemplate',
                        'se.cms.clonePageMenu',
                        'se.cms.pageInfoMenu',
                        'se.emptySlotFix',
                        'se.cms.html5DragAndDrop',
                        'disableSharedSlotEditing',
                        'sharedSlotDisabledDecorator',
                        'se.cms.html5DragAndDrop.outer',
                        'externalComponentDecorator',
                        'externalcomponentbutton',
                        'externalSlotDisabledDecorator',
                        'clonecomponentbutton',
                        'deletePageMenu',
                        'se.cms.pageWorkflowMenu',
                        'se.cms.pageDisplayStatus',
                        'se.cms.pageApprovalSelector',
                        'se.cms.sharedcomponentbutton'
                    ],
                    perspectives: []
                });
                /* Note: For advance edit mode, the ordering of the entries in the features list will determine the order the buttons will show in the slot contextual menu */
                /* externalSlotDisabledDecorator will be removed after 2105 release */
                perspectiveService.register({
                    key: smarteditcommons.CMSModesService.ADVANCED_PERSPECTIVE_KEY,
                    nameI18nKey: 'se.cms.perspective.advanced.name',
                    descriptionI18nKey: 'se.hotkey.tooltip',
                    features: [
                        'se.slotContextualMenu',
                        'se.slotSyncButton',
                        'se.slotSharedButton',
                        'se.slotContextualMenuVisibility',
                        'se.contextualMenu',
                        'se.cms.dragandropbutton',
                        'se.cms.remove',
                        'se.cms.edit',
                        'se.cms.componentMenuTemplate',
                        'se.cms.clonePageMenu',
                        'se.cms.pageInfoMenu',
                        'se.cms.pageSyncMenu',
                        'se.emptySlotFix',
                        'se.cms.html5DragAndDrop',
                        'se.cms.html5DragAndDrop.outer',
                        'syncIndicator',
                        'externalComponentDecorator',
                        'externalcomponentbutton',
                        'clonecomponentbutton',
                        'slotUnsharedButton',
                        'deletePageMenu',
                        'se.cms.pageVersionsMenu',
                        'se.cms.pageWorkflowMenu',
                        'se.cms.pageDisplayStatus',
                        'se.cms.pageApprovalSelector',
                        'se.cms.sharedcomponentbutton',
                        'se.cms.pageTreeMenu',
                        'se.cms.openInPageTreeButton'
                    ],
                    perspectives: []
                });
                perspectiveService.register({
                    key: smarteditcommons.CMSModesService.VERSIONING_PERSPECTIVE_KEY,
                    nameI18nKey: 'se.cms.perspective.versioning.name',
                    descriptionI18nKey: 'se.cms.perspective.versioning.description',
                    features: [
                        'se.cms.pageVersionsMenu',
                        'se.cms.createVersionMenu',
                        'se.cms.rollbackVersionMenu',
                        'se.cms.pageInfoMenu',
                        'disableSharedSlotEditing',
                        'sharedSlotDisabledDecorator',
                        'externalSlotDisabledDecorator',
                        'externalComponentDecorator'
                    ],
                    perspectives: [],
                    permissions: ['se.version.page'],
                    isHotkeyDisabled: true
                });
                inViewElementObserver.addSelector(`.${smarteditcommons.COMPONENT_CLASS}`, () => {
                    cmsDragAndDropService.update();
                });
            }), [
                smarteditcommons.IToolbarServiceFactory,
                exports.RulesAndPermissionsRegistrationService,
                CmsGenericEditorConfigurationService,
                smarteditcommons.IFeatureService,
                smarteditcommons.SystemEventService,
                ClonePageWizardService,
                ManagePageVersionService,
                RollbackPageVersionService,
                smarteditcommons.ICatalogDetailsService,
                exports.CmsDragAndDropService,
                smarteditcommons.IPerspectiveService,
                smarteditcommons.InViewElementObserver,
                smarteditcommons.IEditorModalService,
                cmscommons.IComponentVisibilityAlertService,
                exports.NodeInfoService,
                smarteditcommons.CrossFrameEventService,
                smarteditcommons.IPageTreeService,
                smarteditcommons.ISettingsService
            ])
        ],
        declarations: [
            exports.GenericEditorModalComponent,
            exports.PageRestoredAlertComponent,
            exports.ClonePageAlertComponent
        ],
        entryComponents: [
            exports.GenericEditorModalComponent,
            exports.PageRestoredAlertComponent,
            exports.ClonePageAlertComponent
        ]
    })
], exports.CmssmarteditContainerModule);

exports.CMS_EVENT_HIDE_REPLACE_PARENT_HOMEPAGE_INFO = CMS_EVENT_HIDE_REPLACE_PARENT_HOMEPAGE_INFO;
exports.CMS_EVENT_SHOW_REPLACE_PARENT_HOMEPAGE_INFO = CMS_EVENT_SHOW_REPLACE_PARENT_HOMEPAGE_INFO;
exports.ENABLE_CLONE_ON_DROP = ENABLE_CLONE_ON_DROP;
exports.INTERVAL_MILLISEC = INTERVAL_MILLISEC;
exports.INTERVAL_RETRIES = INTERVAL_RETRIES;
exports.OPEN_COMPONENT_EVENT = OPEN_COMPONENT_EVENT;
exports.PRODUCT_CATEGORY_RESOURCE_BASE_URI = PRODUCT_CATEGORY_RESOURCE_BASE_URI;
exports.PRODUCT_CATEGORY_RESOURCE_URI = PRODUCT_CATEGORY_RESOURCE_URI;
exports.PRODUCT_CATEGORY_SEARCH_RESOURCE_URI = PRODUCT_CATEGORY_SEARCH_RESOURCE_URI;
exports.RESET_COMPONENT_MENU_EVENT = RESET_COMPONENT_MENU_EVENT;
exports.RestrictionsStepHandler = RestrictionsStepHandler;
